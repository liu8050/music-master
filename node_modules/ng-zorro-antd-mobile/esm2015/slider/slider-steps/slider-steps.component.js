/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Component, ElementRef, Input, HostBinding, ViewEncapsulation } from '@angular/core';
export class SliderStepsComponent {
    /**
     * @param {?} _elf
     */
    constructor(_elf) {
        this._elf = _elf;
        this.prefixCls = 'am-slider';
        this.stepArray = [];
        this._min = 0;
        this._max = 100;
        this._marks = {};
        this._included = true;
        this._dots = false;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set min(value) {
        if (value && value <= this._max) {
            this._min = value;
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set max(value) {
        if (value && value >= this._min) {
            this._max = value;
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set marks(value) {
        this._marks = value;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set step(value) {
        this._step = value;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set included(value) {
        this._included = value;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set dots(value) {
        this._dots = value;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set upperBound(value) {
        if (value !== undefined && value !== this._upperBound) {
            this._upperBound = value;
            this.setActiveCls();
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set lowerBound(value) {
        if (value !== undefined && value !== this.lowerBound) {
            this._lowerBound = value;
            this.setActiveCls();
        }
    }
    /**
     * @return {?}
     */
    get class() {
        return 'am-slider-step';
    }
    /**
     * @return {?}
     */
    calPoints() {
        /** @type {?} */
        const points = Object.keys(this._marks).map(parseFloat);
        if (this._dots) {
            for (let i = this._min; i <= this._max; i = i + this._step) {
                if (points.indexOf(i) < 0) {
                    points.push(i);
                }
            }
        }
        return points;
    }
    /**
     * @param {?} points
     * @return {?}
     */
    getSteps(points) {
        /** @type {?} */
        const range = this._max - this._min;
        this.stepArray = [];
        points.map((/**
         * @param {?} point
         * @return {?}
         */
        point => {
            /** @type {?} */
            const stepItem = {
                stepStyle: {},
                stepClass: {},
                point: null
            };
            /** @type {?} */
            const offset = `${(Math.abs(point - this._min) / range) * 100}%`;
            /** @type {?} */
            const isActived = (!this._included && point === this._upperBound) ||
                (this._included && point <= this._upperBound && point >= this._lowerBound);
            /** @type {?} */
            let style = Object.assign({ left: offset }, this._dotStyle);
            if (isActived) {
                style = Object.assign({}, style, this._activeDotStyle);
            }
            /** @type {?} */
            const pointClassName = {
                [`${this.prefixCls}-dot`]: true,
                [`${this.prefixCls}-dot-active`]: isActived
            };
            stepItem.point = point;
            stepItem.stepStyle = style;
            stepItem.stepClass = pointClassName;
            this.stepArray.push(stepItem);
        }));
    }
    /**
     * @return {?}
     */
    setActiveCls() {
        for (let i = 0; i < this.stepArray.length; i++) {
            /** @type {?} */
            const point = this.stepArray[i].point;
            /** @type {?} */
            const isActived = (!this._included && point === this._upperBound) ||
                (this._included && point <= this._upperBound && point >= this._lowerBound);
            this.stepArray[i].stepClass = {
                [`${this.prefixCls}-dot`]: true,
                [`${this.prefixCls}-dot-active`]: isActived
            };
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        /** @type {?} */
        const points = this.calPoints();
        this.getSteps(points);
    }
}
SliderStepsComponent.decorators = [
    { type: Component, args: [{
                selector: 'SliderSteps, nzm-slider-steps',
                template: "<span *ngFor=\"let item of stepArray\"\n      [ngClass]=\"item.stepClass\"\n      [ngStyle]=\"item.stepStyle\">\n</span>",
                encapsulation: ViewEncapsulation.None
            }] }
];
/** @nocollapse */
SliderStepsComponent.ctorParameters = () => [
    { type: ElementRef }
];
SliderStepsComponent.propDecorators = {
    min: [{ type: Input }],
    max: [{ type: Input }],
    marks: [{ type: Input }],
    step: [{ type: Input }],
    included: [{ type: Input }],
    dots: [{ type: Input }],
    upperBound: [{ type: Input }],
    lowerBound: [{ type: Input }],
    class: [{ type: HostBinding }]
};
if (false) {
    /** @type {?} */
    SliderStepsComponent.prototype.prefixCls;
    /** @type {?} */
    SliderStepsComponent.prototype.stepArray;
    /**
     * @type {?}
     * @private
     */
    SliderStepsComponent.prototype._min;
    /**
     * @type {?}
     * @private
     */
    SliderStepsComponent.prototype._max;
    /**
     * @type {?}
     * @private
     */
    SliderStepsComponent.prototype._step;
    /**
     * @type {?}
     * @private
     */
    SliderStepsComponent.prototype._marks;
    /**
     * @type {?}
     * @private
     */
    SliderStepsComponent.prototype._included;
    /**
     * @type {?}
     * @private
     */
    SliderStepsComponent.prototype._upperBound;
    /**
     * @type {?}
     * @private
     */
    SliderStepsComponent.prototype._lowerBound;
    /**
     * @type {?}
     * @private
     */
    SliderStepsComponent.prototype._dots;
    /**
     * @type {?}
     * @private
     */
    SliderStepsComponent.prototype._dotStyle;
    /**
     * @type {?}
     * @private
     */
    SliderStepsComponent.prototype._activeDotStyle;
    /**
     * @type {?}
     * @private
     */
    SliderStepsComponent.prototype._elf;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2xpZGVyLXN0ZXBzLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL25nLXpvcnJvLWFudGQtbW9iaWxlLyIsInNvdXJjZXMiOlsic2xpZGVyL3NsaWRlci1zdGVwcy9zbGlkZXItc3RlcHMuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFBQSxPQUFPLEVBQUUsU0FBUyxFQUFVLFVBQVUsRUFBRSxLQUFLLEVBQUUsV0FBVyxFQUFFLGlCQUFpQixFQUFFLE1BQU0sZUFBZSxDQUFDO0FBT3JHLE1BQU0sT0FBTyxvQkFBb0I7Ozs7SUErRC9CLFlBQW9CLElBQWdCO1FBQWhCLFNBQUksR0FBSixJQUFJLENBQVk7UUE5RHBDLGNBQVMsR0FBRyxXQUFXLENBQUM7UUFDeEIsY0FBUyxHQUFHLEVBQUUsQ0FBQztRQUVQLFNBQUksR0FBVyxDQUFDLENBQUM7UUFDakIsU0FBSSxHQUFXLEdBQUcsQ0FBQztRQUVuQixXQUFNLEdBQVcsRUFBRSxDQUFDO1FBQ3BCLGNBQVMsR0FBWSxJQUFJLENBQUM7UUFHMUIsVUFBSyxHQUFZLEtBQUssQ0FBQztJQW9EUSxDQUFDOzs7OztJQWhEeEMsSUFDSSxHQUFHLENBQUMsS0FBYTtRQUNuQixJQUFJLEtBQUssSUFBSSxLQUFLLElBQUksSUFBSSxDQUFDLElBQUksRUFBRTtZQUMvQixJQUFJLENBQUMsSUFBSSxHQUFHLEtBQUssQ0FBQztTQUNuQjtJQUNILENBQUM7Ozs7O0lBQ0QsSUFDSSxHQUFHLENBQUMsS0FBYTtRQUNuQixJQUFJLEtBQUssSUFBSSxLQUFLLElBQUksSUFBSSxDQUFDLElBQUksRUFBRTtZQUMvQixJQUFJLENBQUMsSUFBSSxHQUFHLEtBQUssQ0FBQztTQUNuQjtJQUNILENBQUM7Ozs7O0lBQ0QsSUFDSSxLQUFLLENBQUMsS0FBYTtRQUNyQixJQUFJLENBQUMsTUFBTSxHQUFHLEtBQUssQ0FBQztJQUN0QixDQUFDOzs7OztJQUNELElBQ0ksSUFBSSxDQUFDLEtBQWE7UUFDcEIs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TCxLQUFLO21CQUlMLEtBQUs7dUJBSUwsS0FBSzttQkFJTCxLQUFLO3lCQUlMLEtBQUs7eUJBT0wsS0FBSztvQkFRTCxXQUFXOzs7O0lBekRaLHlDQUF3Qjs7SUFDeEIseUNBQWU7Ozs7O0lBRWYsb0NBQXlCOzs7OztJQUN6QixvQ0FBMkI7Ozs7O0lBQzNCLHFDQUFzQjs7Ozs7SUFDdEIsc0NBQTRCOzs7OztJQUM1Qix5Q0FBa0M7Ozs7O0lBQ2xDLDJDQUE0Qjs7Ozs7SUFDNUIsMkNBQTRCOzs7OztJQUM1QixxQ0FBK0I7Ozs7O0lBQy9CLHlDQUEwQjs7Ozs7SUFDMUIsK0NBQWdDOzs7OztJQWtEcEIsb0NBQXdCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29tcG9uZW50LCBPbkluaXQsIEVsZW1lbnRSZWYsIElucHV0LCBIb3N0QmluZGluZywgVmlld0VuY2Fwc3VsYXRpb24gfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnU2xpZGVyU3RlcHMsIG56bS1zbGlkZXItc3RlcHMnLFxuICB0ZW1wbGF0ZVVybDogJy4vc2xpZGVyLXN0ZXBzLmNvbXBvbmVudC5odG1sJyxcbiAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZVxufSlcbmV4cG9ydCBjbGFzcyBTbGlkZXJTdGVwc0NvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCB7XG4gIHByZWZpeENscyA9ICdhbS1zbGlkZXInO1xuICBzdGVwQXJyYXkgPSBbXTtcblxuICBwcml2YXRlIF9taW46IG51bWJlciA9IDA7XG4gIHByaXZhdGUgX21heDogbnVtYmVyID0gMTAwO1xuICBwcml2YXRlIF9zdGVwOiBudW1iZXI7XG4gIHByaXZhdGUgX21hcmtzOiBvYmplY3QgPSB7fTtcbiAgcHJpdmF0ZSBfaW5jbHVkZWQ6IGJvb2xlYW4gPSB0cnVlO1xuICBwcml2YXRlIF91cHBlckJvdW5kOiBudW1iZXI7XG4gIHByaXZhdGUgX2xvd2VyQm91bmQ6IG51bWJlcjtcbiAgcHJpdmF0ZSBfZG90czogYm9vbGVhbiA9IGZhbHNlO1xuICBwcml2YXRlIF9kb3RTdHlsZTogb2JqZWN0O1xuICBwcml2YXRlIF9hY3RpdmVEb3RTdHlsZTogb2JqZWN0O1xuXG4gIEBJbnB1dCgpXG4gIHNldCBtaW4odmFsdWU6IG51bWJlcikge1xuICAgIGlmICh2YWx1ZSAmJiB2YWx1ZSA8PSB0aGlzLl9tYXgpIHtcbiAgICAgIHRoaXMuX21pbiA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICBASW5wdXQoKVxuICBzZXQgbWF4KHZhbHVlOiBudW1iZXIpIHtcbiAgICBpZiAodmFsdWUgJiYgdmFsdWUgPj0gdGhpcy5fbWluKSB7XG4gICAgICB0aGlzLl9tYXggPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgQElucHV0KClcbiAgc2V0IG1hcmtzKHZhbHVlOiBvYmplY3QpIHtcbiAgICB0aGlzLl9tYXJrcyA9IHZhbHVlO1xuICB9XG4gIEBJbnB1dCgpXG4gIHNldCBzdGVwKHZhbHVlOiBudW1iZXIpIHtcbiAgICB0aGlzLl9zdGVwID0gdmFsdWU7XG4gIH1cbiAgQElucHV0KClcbiAgc2V0IGluY2x1ZGVkKHZhbHVlOiBib29sZWFuKSB7XG4gICAgdGhpcy5faW5jbHVkZWQgPSB2YWx1ZTtcbiAgfVxuICBASW5wdXQoKVxuICBzZXQgZG90cyh2YWx1ZTogYm9vbGVhbikge1xuICAgIHRoaXMuX2RvdHMgPSB2YWx1ZTtcbiAgfVxuICBASW5wdXQoKVxuICBzZXQgdXBwZXJCb3VuZCh2YWx1ZTogbnVtYmVyKSB7XG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IHRoaXMuX3VwcGVyQm91bmQpIHtcbiAgICAgIHRoaXMuX3VwcGVyQm91bmQgPSB2YWx1ZTtcbiAgICAgIHRoaXMuc2V0QWN0aXZlQ2xzKCk7XG4gICAgfVxuICB9XG4gIEBJbnB1dCgpXG4gIHNldCBsb3dlckJvdW5kKHZhbHVlOiBudW1iZXIpIHtcbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gdGhpcy5sb3dlckJvdW5kKSB7XG4gICAgICB0aGlzLl9sb3dlckJvdW5kID0gdmFsdWU7XG4gICAgICB0aGlzLnNldEFjdGl2ZUNscygpO1xuICAgIH1cbiAgfVxuXG4gIEBIb3N0QmluZGluZygpXG4gIGdldCBjbGFzcygpIHtcbiAgICByZXR1cm4gJ2FtLXNsaWRlci1zdGVwJztcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgX2VsZjogRWxlbWVudFJlZikge31cblxuICBjYWxQb2ludHMoKSB7XG4gICAgY29uc3QgcG9pbnRzID0gT2JqZWN0LmtleXModGhpcy5fbWFya3MpLm1hcChwYXJzZUZsb2F0KTtcbiAgICBpZiAodGhpcy5fZG90cykge1xuICAgICAgZm9yIChsZXQgaSA9IHRoaXMuX21pbjsgaSA8PSB0aGlzLl9tYXg7IGkgPSBpICsgdGhpcy5fc3RlcCkge1xuICAgICAgICBpZiAocG9pbnRzLmluZGV4T2YoaSkgPCAwKSB7XG4gICAgICAgICAgcG9pbnRzLnB1c2goaSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBvaW50cztcbiAgfVxuXG4gIGdldFN0ZXBzKHBvaW50cykge1xuICAgIGNvbnN0IHJhbmdlID0gdGhpcy5fbWF4IC0gdGhpcy5fbWluO1xuICAgIHRoaXMuc3RlcEFycmF5ID0gW107XG4gICAgcG9pbnRzLm1hcChwb2ludCA9PiB7XG4gICAgICBjb25zdCBzdGVwSXRlbSA9IHtcbiAgICAgICAgc3RlcFN0eWxlOiB7fSxcbiAgICAgICAgc3RlcENsYXNzOiB7fSxcbiAgICAgICAgcG9pbnQ6IG51bGxcbiAgICAgIH07XG4gICAgICBjb25zdCBvZmZzZXQgPSBgJHsoTWF0aC5hYnMocG9pbnQgLSB0aGlzLl9taW4pIC8gcmFuZ2UpICogMTAwfSVgO1xuICAgICAgY29uc3QgaXNBY3RpdmVkID1cbiAgICAgICAgKCF0aGlzLl9pbmNsdWRlZCAmJiBwb2ludCA9PT0gdGhpcy5fdXBwZXJCb3VuZCkgfHxcbiAgICAgICAgKHRoaXMuX2luY2x1ZGVkICYmIHBvaW50IDw9IHRoaXMuX3VwcGVyQm91bmQgJiYgcG9pbnQgPj0gdGhpcy5fbG93ZXJCb3VuZCk7XG4gICAgICBsZXQgc3R5bGUgPSB7IGxlZnQ6IG9mZnNldCwgLi4udGhpcy5fZG90U3R5bGUgfTtcbiAgICAgIGlmIChpc0FjdGl2ZWQpIHtcbiAgICAgICAgc3R5bGUgPSB7IC4uLnN0eWxlLCAuLi50aGlzLl9hY3RpdmVEb3RTdHlsZSB9O1xuICAgICAgfVxuXG4gICAgICBjb25zdCBwb2ludENsYXNzTmFtZSA9IHtcbiAgICAgICAgW2Ake3RoaXMucHJlZml4Q2xzfS1kb3RgXTogdHJ1ZSxcbiAgICAgICAgW2Ake3RoaXMucHJlZml4Q2xzfS1kb3QtYWN0aXZlYF06IGlzQWN0aXZlZFxuICAgICAgfTtcbiAgICAgIHN0ZXBJdGVtLnBvaW50ID0gcG9pbnQ7XG4gICAgICBzdGVwSXRlbS5zdGVwU3R5bGUgPSBzdHlsZTtcbiAgICAgIHN0ZXBJdGVtLnN0ZXBDbGFzcyA9IHBvaW50Q2xhc3NOYW1lO1xuICAgICAgdGhpcy5zdGVwQXJyYXkucHVzaChzdGVwSXRlbSk7XG4gICAgfSk7XG4gIH1cblxuICBzZXRBY3RpdmVDbHMoKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnN0ZXBBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgcG9pbnQgPSB0aGlzLnN0ZXBBcnJheVtpXS5wb2ludDtcbiAgICAgIGNvbnN0IGlzQWN0aXZlZCA9XG4gICAgICAgICghdGhpcy5faW5jbHVkZWQgJiYgcG9pbnQgPT09IHRoaXMuX3VwcGVyQm91bmQpIHx8XG4gICAgICAgICh0aGlzLl9pbmNsdWRlZCAmJiBwb2ludCA8PSB0aGlzLl91cHBlckJvdW5kICYmIHBvaW50ID49IHRoaXMuX2xvd2VyQm91bmQpO1xuICAgICAgdGhpcy5zdGVwQXJyYXlbaV0uc3RlcENsYXNzID0ge1xuICAgICAgICBbYCR7dGhpcy5wcmVmaXhDbHN9LWRvdGBdOiB0cnVlLFxuICAgICAgICBbYCR7dGhpcy5wcmVmaXhDbHN9LWRvdC1hY3RpdmVgXTogaXNBY3RpdmVkXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIG5nT25Jbml0KCkge1xuICAgIGNvbnN0IHBvaW50cyA9IHRoaXMuY2FsUG9pbnRzKCk7XG4gICAgdGhpcy5nZXRTdGVwcyhwb2ludHMpO1xuICB9XG59XG4iXX0=