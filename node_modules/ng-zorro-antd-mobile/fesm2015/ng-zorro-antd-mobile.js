import { Component, Input, HostBinding, NgModule, ViewEncapsulation, TemplateRef, ElementRef, Renderer2, EventEmitter, forwardRef, ViewChild, Output, InjectionToken, Injectable, Inject, Optional, SkipSelf, ApplicationRef, ComponentFactoryResolver, NgZone, HostListener, Pipe, ContentChildren, ChangeDetectionStrategy, ChangeDetectorRef, Compiler, Injector, Directive, ViewContainerRef, defineInjectable, inject } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormsModule, NG_VALUE_ACCESSOR, ReactiveFormsModule } from '@angular/forms';
import { BehaviorSubject, Subject, merge } from 'rxjs';
import { takeUntil, startWith } from 'rxjs/operators';
import { trigger, state, style, transition, animate } from '@angular/animations';
import { DomSanitizer } from '@angular/platform-browser';
import { OverlayConfig, Overlay, OverlayModule } from '@angular/cdk/overlay';
import { ComponentPortal } from '@angular/cdk/portal';
import { ObserversModule } from '@angular/cdk/observers';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ActivityIndicatorComponent {
    constructor() {
        this.prefixCls = 'am-activity-indicator';
        this.spinnerClass = {};
        this._size = 'small';
        this._toast = false;
        this._animating = true;
        this.clsActIndicator = true;
    }
    /**
     * @return {?}
     */
    get animating() {
        return this._animating;
    }
    /**
     * @param {?} v
     * @return {?}
     */
    set animating(v) {
        this._animating = v;
        this.setClass();
    }
    /**
     * @param {?} v
     * @return {?}
     */
    set size(v) {
        this._size = v;
        this.setClass();
    }
    /**
     * @return {?}
     */
    get toast() {
        return this._toast;
    }
    /**
     * @param {?} v
     * @return {?}
     */
    set toast(v) {
        this._toast = v;
        this.setClass();
    }
    /**
     * @return {?}
     */
    get text() {
        return this._text;
    }
    /**
     * @param {?} v
     * @return {?}
     */
    set text(v) {
        this._text = v;
    }
    /**
     * @return {?}
     */
    setClass() {
        if (this._animating) {
            this.clsActIndicator = true;
            this.clsActIndicatorToast = !!this._toast;
            this.clsActIndicatorLg = this._size === 'large';
            this.clsActIndicatorSm = this._size === 'small';
            this.spinnerClass = {
                [`${this.prefixCls}-spinner`]: true,
                [`${this.prefixCls}-spinner-lg`]: !!this._toast || this._size === 'large'
            };
        }
        else {
            this.clsActIndicator = false;
            this.clsActIndicatorLg = false;
            this.clsActIndicatorSm = false;
            this.clsActIndicatorToast = false;
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.setClass();
    }
}
ActivityIndicatorComponent.decorators = [
    { type: Component, args: [{
                selector: 'ActivityIndicator , nzm-ctivity-indicator',
                template: "<div *ngIf=\"animating && toast && text && text.length>0\">\n  <div class=\"{{prefixCls}}-content\">\n    <span [ngClass]=\"spinnerClass\" aria-hidden=\"'true'\"></span>\n    <span class=\"{{prefixCls}}-toast\">{{text}}</span>\n  </div>\n</div>\n<div *ngIf=\"animating && toast && !text\">\n  <div class=\"{{prefixCls}}-content\">\n    <span [ngClass]=\"spinnerClass\" aria-label=\"'Loading'\"></span>\n  </div>\n</div>\n<div *ngIf=\"animating && !toast && text && text.length>0\">\n  <span [ngClass]=\"spinnerClass\" aria-hidden=\"true\"></span>\n  <span class=\"{{prefixCls}}-tip\">{{text}}</span>\n</div>\n<div *ngIf=\"animating &&! toast && !text\">\n  <span [ngClass]=\"spinnerClass\" aria-label=\"'loading'\"></span>\n</div>\n"
            }] }
];
/** @nocollapse */
ActivityIndicatorComponent.ctorParameters = () => [];
ActivityIndicatorComponent.propDecorators = {
    animating: [{ type: Input }],
    size: [{ type: Input }],
    toast: [{ type: Input }],
    text: [{ type: Input }],
    clsActIndicator: [{ type: HostBinding, args: ['class.am-activity-indicator',] }],
    clsActIndicatorToast: [{ type: HostBinding, args: ['class.am-activity-indicator-toast',] }],
    clsActIndicatorLg: [{ type: HostBinding, args: ['class.am-activity-indicator-lg',] }],
    clsActIndicatorSm: [{ type: HostBinding, args: ['class.am-activity-indicator-sm',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ActivityIndicatorModule {
}
ActivityIndicatorModule.decorators = [
    { type: NgModule, args: [{
                exports: [ActivityIndicatorComponent],
                declarations: [ActivityIndicatorComponent],
                imports: [CommonModule, FormsModule]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CardComponent {
    constructor() {
        this.full = false;
        this.cardWrapper = true;
    }
    /**
     * @return {?}
     */
    get cardFull() {
        return this.full;
    }
}
CardComponent.decorators = [
    { type: Component, args: [{
                selector: 'Card, nzm-card',
                template: "<ng-content></ng-content>",
                encapsulation: ViewEncapsulation.None
            }] }
];
/** @nocollapse */
CardComponent.ctorParameters = () => [];
CardComponent.propDecorators = {
    full: [{ type: Input }],
    cardWrapper: [{ type: HostBinding, args: ['class.am-card',] }],
    cardFull: [{ type: HostBinding, args: ['class.am-card-full',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CardHeaderComponent {
    constructor() {
        this.prefixCls = 'am-card-header';
        this.thumb = null;
        this.thumbStyle = null;
        this.title = null;
        this.extra = null;
        this.cardBodyWrapper = true;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    isTemplateRef(value) {
        return value instanceof TemplateRef;
    }
}
CardHeaderComponent.decorators = [
    { type: Component, args: [{
                selector: 'CardHeader, nzm-card-header',
                template: "<div class=\"{{prefixCls}}-content\">\n  <img *ngIf='thumb && !isTemplateRef(thumb)' src=\"{{thumb}}\" [ngStyle]=\"thumbStyle\">\n  <ng-container *ngIf=\"thumb && isTemplateRef(thumb)\" [ngTemplateOutlet]=\"thumb\"></ng-container>\n  <ng-container *ngIf=\"!isTemplateRef(title);else titleTemplate\">{{title}}</ng-container>\n</div>\n<div *ngIf=\"extra\" class=\"{{prefixCls}}-extra\">\n  <ng-container *ngIf=\"!isTemplateRef(extra);else extraTemplate\">{{extra}}</ng-container>\n</div>\n<ng-template #titleTemplate>\n  <ng-template [ngTemplateOutlet]=\"title\"></ng-template>\n</ng-template>\n<ng-template #extraTemplate>\n  <ng-template [ngTemplateOutlet]=\"extra\"></ng-template>\n</ng-template>",
                encapsulation: ViewEncapsulation.None
            }] }
];
/** @nocollapse */
CardHeaderComponent.ctorParameters = () => [];
CardHeaderComponent.propDecorators = {
    thumb: [{ type: Input }],
    thumbStyle: [{ type: Input }],
    title: [{ type: Input }],
    extra: [{ type: Input }],
    cardBodyWrapper: [{ type: HostBinding, args: ['class.am-card-header',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CardBodyComponent {
    constructor() {
        this.cardBodyWrapper = true;
    }
}
CardBodyComponent.decorators = [
    { type: Component, args: [{
                selector: 'CardBody, nzm-card-body',
                template: `<ng-content></ng-content>`,
                encapsulation: ViewEncapsulation.None
            }] }
];
/** @nocollapse */
CardBodyComponent.ctorParameters = () => [];
CardBodyComponent.propDecorators = {
    cardBodyWrapper: [{ type: HostBinding, args: ['class.am-card-body',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CardFooterComponent {
    constructor() {
        this.prefixCls = 'am-card-footer';
        this.content = null;
        this.extra = null;
        this.cardFooterWrapper = true;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    isTemplateRef(value) {
        return value instanceof TemplateRef;
    }
}
CardFooterComponent.decorators = [
    { type: Component, args: [{
                selector: 'CardFooter, nzm-card-footer',
                template: "<div class=\"{{prefixCls}}-content\">\n  <ng-container *ngIf=\"!isTemplateRef(content);else contentTemplate\">{{content}}</ng-container>\n</div>\n<div *ngIf=\"extra\" class=\"{{prefixCls}}-extra\">\n  <ng-container *ngIf=\"!isTemplateRef(extra);else extraTemplate\">{{extra}}</ng-container>\n</div>\n<ng-template #contentTemplate>\n  <ng-template [ngTemplateOutlet]=\"content\"></ng-template>\n</ng-template>\n<ng-template #extraTemplate>\n  <ng-template [ngTemplateOutlet]=\"extra\"></ng-template>\n</ng-template>",
                encapsulation: ViewEncapsulation.None
            }] }
];
/** @nocollapse */
CardFooterComponent.ctorParameters = () => [];
CardFooterComponent.propDecorators = {
    content: [{ type: Input }],
    extra: [{ type: Input }],
    cardFooterWrapper: [{ type: HostBinding, args: ['class.am-card-footer',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CardModule {
}
CardModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                declarations: [CardComponent, CardHeaderComponent, CardBodyComponent, CardFooterComponent],
                exports: [CardComponent, CardHeaderComponent, CardBodyComponent, CardFooterComponent]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class BadgeComponent {
    /**
     * @param {?} _ref
     * @param {?} render
     */
    constructor(_ref, render) {
        this._ref = _ref;
        this.render = render;
        this.prefixCls = 'am-badge';
        this.scrollNumberCls = {};
        this.style = {};
        this._size = 'small';
        this._dot = false;
        this._hot = false;
        this._corner = false;
        this._children = false;
        this._overflowCount = 99;
        this.clsBadge = true;
        this.clsBadgeWrp = !this._children;
        this.clsBadgeCornerWrp = this._corner;
        this.clsBadgeHot = !!this._hot;
        this.clsBadgeCornerWrpLg = this._corner && this._size === 'large';
    }
    /**
     * @param {?} v
     * @return {?}
     */
    set size(v) {
        this._size = v;
        this.setCls();
    }
    /**
     * @return {?}
     */
    get text() {
        return this._text;
    }
    /**
     * @param {?} v
     * @return {?}
     */
    set text(v) {
        this._text = v;
        this.setCls();
    }
    /**
     * @param {?} v
     * @return {?}
     */
    set corner(v) {
        this._corner = v;
        this.setCls();
    }
    /**
     * @return {?}
     */
    get dot() {
        return this._dot;
    }
    /**
     * @param {?} v
     * @return {?}
     */
    set dot(v) {
        this._dot = v;
        if (this._dot) {
            this._text = '';
        }
        this.setCls();
    }
    /**
     * @param {?} v
     * @return {?}
     */
    set overflowCount(v) {
        this._overflowCount = v;
    }
    /**
     * @param {?} v
     * @return {?}
     */
    set hot(v) {
        this._hot = v;
        this.setCls();
    }
    /**
     * @param {?} v
     * @return {?}
     */
    set setStyle(v) {
        this.style = v;
    }
    /**
     * @param {?} v
     * @return {?}
     */
    set className(v) {
        this._setClass = v;
        /** @type {?} */
        const clsArr = this._setClass.split(' ');
        clsArr.forEach((/**
         * @param {?} cls
         * @return {?}
         */
        cls => {
            this.render.addClass(this._ref.nativeElement, cls);
        }));
    }
    /**
     * @return {?}
     */
    setCls() {
        this.scrollNumberCls = {
            [`${this.prefixCls}-dot`]: this._dot,
            [`${this.prefixCls}-dot-large`]: this._dot && this._size === 'large',
            [`${this.prefixCls}-text`]: !this._dot && !this._corner,
            [`${this.prefixCls}-corner`]: this._corner,
            [`${this.prefixCls}-corner-large`]: this._corner && this._size === 'large'
        };
        this.clsBadgeWrp = !this._children;
        this.clsBadgeCornerWrp = this._corner;
        this.clsBadgeHot = !!this._hot;
        this.clsBadgeCornerWrpLg = this._corner && this._size === 'large';
    }
    /**
     * @return {?}
     */
    ngOnChanges() {
        if (typeof this._text === 'number' && this._text > this._overflowCount) {
            this._text = this._overflowCount + '+';
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.setCls();
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        setTimeout((/**
         * @return {?}
         */
        () => {
            if (this._ref.nativeElement.children.length > 1 || (this._ref.nativeElement.children.length === 1 && !this.dot && !this.text)) {
                this._children = true;
                this.setCls();
            }
        }), 10);
    }
}
BadgeComponent.decorators = [
    { type: Component, args: [{
                selector: 'Badge, nzm-badge',
                template: "<ng-content></ng-content>\n<sup *ngIf=\"dot || text\"\n    [ngClass]=\"scrollNumberCls\"\n    [ngStyle]=\"style\">\n    <span>{{text}}</span>\n</sup>\n"
            }] }
];
/** @nocollapse */
BadgeComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
BadgeComponent.propDecorators = {
    size: [{ type: Input }],
    text: [{ type: Input }],
    corner: [{ type: Input }],
    dot: [{ type: Input }],
    overflowCount: [{ type: Input }],
    hot: [{ type: Input }],
    setStyle: [{ type: Input }],
    className: [{ type: Input }],
    clsBadge: [{ type: HostBinding, args: ['class.am-badge',] }],
    clsBadgeWrp: [{ type: HostBinding, args: ['class.am-badge-not-a-wrapper',] }],
    clsBadgeCornerWrp: [{ type: HostBinding, args: ['class.am-badge-corner-wrapper',] }],
    clsBadgeHot: [{ type: HostBinding, args: ['class.am-badge-hot',] }],
    clsBadgeCornerWrpLg: [{ type: HostBinding, args: ['class.am-badge-corner-wrapper-large',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class BadgeModule {
}
BadgeModule.decorators = [
    { type: NgModule, args: [{
                exports: [BadgeComponent],
                declarations: [BadgeComponent],
                imports: [CommonModule, FormsModule]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class InputItemComponent {
    /**
     * @param {?} element
     * @param {?} render
     */
    constructor(element, render) {
        this.element = element;
        this.render = render;
        this.prefixCls = 'am-input';
        this.setFocus = {};
        this.pattern = '';
        this.autoFocus = false;
        this.inputType = 'text';
        this.ngTemplate = false;
        this._type = 'text';
        this._defaultValue = '';
        this._placeholder = '';
        this._editable = true;
        this._disabled = false;
        this._clear = false;
        this._error = false;
        this._extra = '';
        this._labelNumber = 5;
        this._updatePlaceholder = false;
        this._prefixListCls = 'am-list';
        this._moneyKeyboardAlign = 'right';
        this._focus = false;
        this._isClear = false;
        this._inputLock = false;
        this.onChange = new EventEmitter();
        this.onBlur = new EventEmitter();
        this.onFocus = new EventEmitter();
        this.onErrorClick = new EventEmitter();
        this.onExtraClick = new EventEmitter();
        this.clsItem = true;
        this.clsDisabled = this._disabled;
        this.clsError = this._error;
        this.clsFocus = this._focus;
        this.clsAndroid = this._focus;
        this._onChange = (/**
         * @param {?} _
         * @return {?}
         */
        (_) => { });
        this._el = element.nativeElement;
    }
    /**
     * @return {?}
     */
    get type() {
        return this._type;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set type(value) {
        if (value && value.length > 0) {
            this.inputType = value;
            if (value === 'bankCard' || value === 'phone') {
                this._type = 'tel';
            }
            else if (value === 'password') {
                this._type = 'password';
            }
            else if (value === 'digit') {
                this._type = 'number';
            }
            else if (value !== 'text' && value !== 'number') {
                this._type = value;
            }
            if (value === 'number') {
                this.pattern = '[0-9]*';
            }
        }
    }
    /**
     * @return {?}
     */
    get value() {
        return this._value;
    }
    /**
     * @param {?} v
     * @return {?}
     */
    set value(v) {
        if (typeof v === 'undefined' || v === null) {
            this._value = '';
        }
        else {
            this._value = v;
        }
    }
    /**
     * @return {?}
     */
    get defaultValue() {
        return this._defaultValue;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set defaultValue(value) {
        this._defaultValue = value;
        if (!this._value) {
            this._value = this._defaultValue;
        }
    }
    /**
     * @return {?}
     */
    get placeholder() {
        return this._placeholder;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set placeholder(value) {
        this._placeholder = value;
    }
    /**
     * @return {?}
     */
    get editable() {
        return this._editable;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set editable(value) {
        this._editable = value;
    }
    /**
     * @return {?}
     */
    get disabled() {
        return this._disabled;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set disabled(value) {
        this._disabled = value;
        this.clsDisabled = value;
    }
    /**
     * @return {?}
     */
    get clear() {
        return this._clear;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set clear(value) {
        this._clear = value;
    }
    /**
     * @return {?}
     */
    get maxLength() {
        return this._maxLength;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set maxLength(value) {
        this._maxLength = value;
    }
    /**
     * @return {?}
     */
    get error() {
        return this._error;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set error(value) {
        this._error = value;
        this.clsError = value;
    }
    /**
     * @return {?}
     */
    get extra() {
        return this._extra;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set extra(value) {
        if (value instanceof TemplateRef) {
            this.ngTemplate = true;
        }
        else {
            this.ngTemplate = false;
        }
        this._extra = value;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set labelNumber(value) {
        this._labelNumber = value;
        this.setCls();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set updatePlaceholder(value) {
        this._updatePlaceholder = value;
    }
    /**
     * @return {?}
     */
    get prefixListCls() {
        return this._prefixListCls;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set prefixListCls(value) {
        this._prefixListCls = value;
        this.render.addClass(this._el, value + '-item');
        this.render.addClass(this._el, value + '-item-middle');
    }
    /**
     * @return {?}
     */
    get name() {
        return this._name;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set name(value) {
        this._name = value;
    }
    /**
     * @return {?}
     */
    get moneyKeyboardAlign() {
        return this._moneyKeyboardAlign;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set moneyKeyboardAlign(value) {
        this._moneyKeyboardAlign = value;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set locale(value) {
        this._locale = value;
    }
    /**
     * @return {?}
     */
    get fontColor() {
        return this._fontColor;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set fontColor(value) {
        this._fontColor = value;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set focus(value) {
        if (value && value.focus) {
            this.autoFocus = value.focus;
            if (this._type === 'money') {
                this.setFocus = value;
            }
            else if (this.inputElementRef) {
                this._focus = true;
                this.inputElementRef.nativeElement.focus();
                this.inputFocus('');
            }
        }
    }
    /**
     * @return {?}
     */
    setCls() {
        if (this.lableRef.nativeElement.children.length > 0 ||
            (this.lableRef.nativeElement && this.lableRef.nativeElement.innerText !== '')) {
            this.labelCls = {
                [`${this.prefixCls}-label`]: true,
                [`${this.prefixCls}-label-2`]: this._labelNumber === 2,
                [`${this.prefixCls}-label-3`]: this._labelNumber === 3,
                [`${this.prefixCls}-label-4`]: this._labelNumber === 4,
                [`${this.prefixCls}-label-5`]: this._labelNumber === 5,
                [`${this.prefixCls}-label-6`]: this._labelNumber === 6,
                [`${this.prefixCls}-label-7`]: this._labelNumber === 7
            };
        }
        this.controlCls = { [`${this.prefixCls}-control`]: true };
    }
    /**
     * @param {?} e
     * @return {?}
     */
    inputChange(e) {
        setTimeout((/**
         * @return {?}
         */
        () => {
            if (this._inputLock && this.inputType === 'text') {
                return;
            }
            /** @type {?} */
            let value = e;
            switch (this.inputType) {
                case 'text':
                    break;
                case 'bankCard':
                    value = value.replace(/\D/g, '').replace(/(....)(?=.)/g, '$1 ');
                    break;
                case 'phone':
                    value = value.replace(/\D/g, '').substring(0, 11);
                    /** @type {?} */
                    const valueLen = value.length;
                    if (valueLen > 3 && valueLen < 8) {
                        value = `${value.substr(0, 3)} ${value.substr(3)}`;
                    }
                    else if (valueLen >= 8) {
                        value = `${value.substr(0, 3)} ${value.substr(3, 4)} ${value.substr(7)}`;
                    }
                    break;
                case 'number':
                    value = value.replace(/\D/g, '');
                    break;
                case 'password':
                    break;
                default:
                    this._value = value;
                    break;
            }
            this._value = value;
            if (this._type !== 'money') {
                this.inputElementRef.nativeElement.value = this._value;
            }
            this._onChange(this._value);
            this.onChange.emit(this._value);
        }), 0);
    }
    /**
     * @return {?}
     */
    compositionStart() {
        this._inputLock = true;
    }
    /**
     * @return {?}
     */
    compositionEnd() {
        this._inputLock = false;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    inputFocus(value) {
        setTimeout((/**
         * @return {?}
         */
        () => {
            this._focus = true;
            this.clsFocus = true;
            this.clsAndroid = true;
        }), 100);
        this.onFocus.emit(value);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    inputBlur(value) {
        setTimeout((/**
         * @return {?}
         */
        () => {
            if (!this._isClear) {
                this._focus = false;
                this.clsFocus = false;
                this.clsAndroid = false;
                this.onBlur.emit(value);
            }
            this._isClear = false;
        }), 100);
    }
    /**
     * @return {?}
     */
    clearInput() {
        if (this._type !== 'password' && this._updatePlaceholder) {
            this._placeholder = this._value;
        }
        this._value = '';
        this.onChange.emit(this._value);
        this._onChange(this._value);
        this._isClear = true;
        if (this._type !== 'money') {
            this.inputElementRef.nativeElement.value = this._value;
        }
        this.inputFocus(this._value);
    }
    /**
     * @param {?} e
     * @return {?}
     */
    errorClick(e) {
        if (this.onErrorClick) {
            this.onErrorClick.emit(e);
        }
    }
    /**
     * @param {?} e
     * @return {?}
     */
    extraClick(e) {
        if (this.onExtraClick) {
            this.onExtraClick.emit(e);
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        if (typeof value === undefined || value === null) {
            this._value = '';
        }
        else {
            this._value = value;
        }
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this._onChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) { }
    /**
     * @return {?}
     */
    ngOnChanges() {
        if (this.inputElementRef && this._type !== 'money' && this._value !== undefined) {
            this.inputElementRef.nativeElement.value = this._value;
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.setCls();
        this.render.addClass(this._el, this._prefixListCls + '-item');
        this.render.addClass(this._el, this._prefixListCls + '-item-middle');
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        setTimeout((/**
         * @return {?}
         */
        () => {
            this.setCls();
        }), 0);
    }
}
InputItemComponent.decorators = [
    { type: Component, args: [{
                selector: 'InputItem, nzm-input-item',
                template: "<div class=\"{{prefixListCls}}-line\">\n  <div #lableContent [ngClass]=\"labelCls\">\n    <ng-content></ng-content>\n  </div>\n  <div [ngClass]=\"controlCls\">\n    <CustomInput *ngIf=\"type==='money'\"\n                 [value]=\"value\"\n                 [defaultValue]=\"defaultValue\"\n                 [placeholder]=\"placeholder\"\n                 [disabled]=\"disabled\"\n                 [editable]=\"editable\"\n                 [fontColor]=\"fontColor\"\n                 [moneyKeyboardAlign]=\"moneyKeyboardAlign\"\n                 [setFocus]=\"setFocus\"\n                 [maxLength]=\"maxLength\"\n                 (onChange)=\"inputChange($event)\"\n                 (onBlur)=\"inputBlur(value)\"\n                 (onFocus)=\"inputFocus(value)\">\n    </CustomInput>\n    <div *ngIf=\"type!=='money'\">\n      <input #inputElement\n             [type]=\"type\"\n             [name]=\"name\"\n             [ngModel]=\"value\"\n             [defaultValue]=\"defaultValue\"\n             [placeholder]=\"placeholder\"\n             [disabled]=\"disabled\"\n             [readOnly]=\"!editable\"\n             [autofocus]=\"autoFocus\"\n             [maxlength]=\"maxLength\"\n             [pattern]=\"pattern\"\n             [style.color]='fontColor'\n             (ngModelChange)=\"inputChange($event)\"\n             (compositionstart)=\"compositionStart()\"\n             (compositionend)=\"compositionEnd()\"\n             (blur)=\"inputBlur(value)\"\n             (focus)=\"inputFocus(value)\"\n             style=\"outline:none\" />\n    </div>\n  </div>\n  <div  *ngIf=\"clear && editable && !disabled && (value && value.length >0 )\"\n        class=\"{{prefixCls}}-clear\"\n        (click)=\"clearInput()\"\n  ></div>\n  <div *ngIf=\"error\"\n       class=\"{{prefixCls}}-error-extra\"\n       (click)=\"errorClick($event)\"\n  ></div>\n  <div *ngIf=\"extra!==''\"\n       class=\"{{prefixCls}}-extra\"\n       (click)=\"extraClick($event)\">\n    <ng-container *ngIf=\"!ngTemplate\">{{extra}}</ng-container>\n    <ng-template *ngIf=\"ngTemplate\" [ngTemplateOutlet]=\"extra\"></ng-template>\n  </div>\n</div>",
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => InputItemComponent)),
                        multi: true
                    }
                ]
            }] }
];
/** @nocollapse */
InputItemComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
InputItemComponent.propDecorators = {
    lableRef: [{ type: ViewChild, args: ['lableContent',] }],
    inputElementRef: [{ type: ViewChild, args: ['inputElement',] }],
    type: [{ type: Input }],
    value: [{ type: Input }],
    defaultValue: [{ type: Input }],
    placeholder: [{ type: Input }],
    editable: [{ type: Input }],
    disabled: [{ type: Input }],
    clear: [{ type: Input }],
    maxLength: [{ type: Input }],
    error: [{ type: Input }],
    extra: [{ type: Input }],
    labelNumber: [{ type: Input }],
    updatePlaceholder: [{ type: Input }],
    prefixListCls: [{ type: Input }],
    name: [{ type: Input }],
    moneyKeyboardAlign: [{ type: Input }],
    locale: [{ type: Input }],
    fontColor: [{ type: Input }],
    focus: [{ type: Input }],
    onChange: [{ type: Output }],
    onBlur: [{ type: Output }],
    onFocus: [{ type: Output }],
    onErrorClick: [{ type: Output }],
    onExtraClick: [{ type: Output }],
    clsItem: [{ type: HostBinding, args: ['class.am-input-item',] }],
    clsDisabled: [{ type: HostBinding, args: ['class.am-input-disabled',] }],
    clsError: [{ type: HostBinding, args: ['class.am-input-error',] }],
    clsFocus: [{ type: HostBinding, args: ['class.am-input-focus',] }],
    clsAndroid: [{ type: HostBinding, args: ['class.am-input-android,',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const LOCAL_PROVIDER_TOKEN = new InjectionToken('locale-provider-token');

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var Picker = {
    okText: '确定',
    dismissText: '取消',
    extra: '请选择',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// import DatePickerLocale from 'rmc-date-picker/lib/locale/zh_CN';
var DatePicker = {
    errorMessage: '当前时间与设定最大或最小日期格式不一致',
    curTMorethanMax: '当前时间大于设定最大日期',
    curTLessthanMin: '当前时间小于设定最最小日期',
    okText: '确定',
    dismissText: '取消',
    extra: '请选择',
    // DatePickerLocale,
    year: '年',
    month: '月',
    day: '日',
    hour: '时',
    minute: '分',
    am: '上午',
    pm: '下午'
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// import DatePickerLocale from 'rmc-date-picker/lib/locale/zh_CN';
var DatePickerView = {
    okText: '确定',
    dismissText: '取消',
    extra: '请选择',
    // DatePickerLocale,
    year: '年',
    month: '月',
    day: '日',
    hour: '时',
    minute: '分',
    am: '上午',
    pm: '下午'
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var Menu = {
    okText: '确定',
    cancelText: '取消',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// 同步自 'rmc-calendar/lib/locale/zh_CN';
var zhCN = {
    title: '日期选择',
    today: '今天',
    month: '月',
    year: '年',
    am: '上午',
    pm: '下午',
    dateTimeFormat: 'yyyy年MM月dd日 星期w hh:mm',
    dateFormat: 'yyyy年MM月dd日 星期w',
    noChoose: '未选择',
    week: ['日', '一', '二', '三', '四', '五', '六'],
    clear: '清除',
    selectTime: '选择时间',
    selectStartTime: '选择开始时间',
    selectEndTime: '选择结束时间',
    start: '开始',
    end: '结束',
    begin: '起',
    over: '止',
    begin_over: '起/止',
    confirm: '确认',
    monthTitle: 'yyyy年MM月',
    loadPrevMonth: '加载上一个月',
    yesterday: '昨天',
    lastWeek: '近一周',
    lastMonth: '近一个月'
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var SearchBar = {
    cancelText: '取消',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var InputItem = {
    confirmLabel: '确定',
    backspaceLabel: '退格',
    cancelKeyboardLabel: '收起键盘',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var Pagination = {
    prevText: '上一页',
    nextText: '下一页',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var PullToRefresh = {
    activateText: '松开立即刷新',
    deactivateText: '下拉可以刷新',
    finishText: '完成刷新',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var ActionSheet = {
    dismissText: '取消'
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var zh_CN = {
    locale: 'zh_CN',
    Picker,
    DatePicker,
    DatePickerView,
    Menu,
    Calendar: zhCN,
    SearchBar,
    InputItem,
    Pagination,
    PullToRefresh,
    ActionSheet
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class LocaleProviderService {
    /**
     * @param {?} locale
     */
    constructor(locale) {
        this._change = new BehaviorSubject(this._locale);
        this.setLocale(locale || zh_CN);
    }
    /**
     * @return {?}
     */
    get localeChange() {
        return this._change.asObservable();
    }
    /**
     * @param {?} keyPath
     * @return {?}
     */
    getLocaleValue(keyPath) {
        /** @type {?} */
        const content = (/** @type {?} */ (this._getObjectPath(this._locale, keyPath)));
        if (typeof content === 'string') {
            return content;
        }
        return '';
    }
    /**
     * @param {?} keyPath
     * @return {?}
     */
    getLocaleSubObj(keyPath) {
        /** @type {?} */
        const content = (/** @type {?} */ (this._getObjectPath(this._locale, keyPath)));
        if (typeof content === 'object') {
            return content;
        }
        return null;
    }
    /**
     * @param {?} locale
     * @return {?}
     */
    setLocale(locale) {
        if (!locale || (this._locale && this._locale.locale === locale.locale)) {
            return;
        }
        this._locale = locale;
        this._change.next(locale);
    }
    /**
     * @return {?}
     */
    getLocaleId() {
        return this._locale && this._locale.locale ? this._locale.locale : '';
    }
    /**
     * @return {?}
     */
    getLocale() {
        return this._locale;
    }
    /**
     * @private
     * @param {?} obj
     * @param {?} path
     * @return {?}
     */
    _getObjectPath(obj, path) {
        /** @type {?} */
        let res = obj;
        /** @type {?} */
        const paths = path.split('.');
        /** @type {?} */
        const depth = paths.length;
        /** @type {?} */
        let index = 0;
        while (res && index < depth) {
            res = res[paths[index++]];
        }
        return index === depth ? res : null;
    }
}
LocaleProviderService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
LocaleProviderService.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [LOCAL_PROVIDER_TOKEN,] }] }
];
/**
 * @param {?} exist
 * @param {?} locale
 * @return {?}
 */
function LOCALE_PROVIDER_SERVICE_FACTORY(exist, locale) {
    return exist || new LocaleProviderService(locale);
}
/** @type {?} */
const LOCALE_PROVIDER_SERVICE_PROVIDER = {
    provide: LocaleProviderService,
    useFactory: LOCALE_PROVIDER_SERVICE_FACTORY,
    deps: [[new Optional(), new SkipSelf(), LocaleProviderService], LOCAL_PROVIDER_TOKEN]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CustomKeyboardComponent {
    /**
     * @param {?} _localeProvider
     */
    constructor(_localeProvider) {
        this._localeProvider = _localeProvider;
        this.prefixCls = 'am-number-keyboard';
        this.okText = '';
        this._locale = {};
        this._unsubscribe$ = new Subject();
        this.onClick = new EventEmitter();
    }
    /**
     * @param {?} e
     * @return {?}
     */
    tdClick(e) {
        this.onClick.emit(e);
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.wrapCls = {
            [`${this.prefixCls}-item`]: true
        };
        this.wrapperCls = {
            [`${this.prefixCls}-wrapper`]: true
        };
        this._localeProvider.localeChange.pipe(takeUntil(this._unsubscribe$)).subscribe((/**
         * @param {?} _
         * @return {?}
         */
        _ => {
            this._locale = this._localeProvider.getLocaleSubObj('InputItem');
            this.okText = this._locale.confirmLabel;
        }));
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._unsubscribe$.next();
        this._unsubscribe$.complete();
    }
}
CustomKeyboardComponent.decorators = [
    { type: Component, args: [{
                selector: 'CustomKeyboard',
                template: "<div [ngClass]=\"wrapperCls\">\n<table>\n  <tbody>\n    <tr>\n      <td [ngClass]=\"wrapCls\" (click)=\"tdClick(1)\">1\n      </td>\n      <td [ngClass]=\"wrapCls\" (click)=\"tdClick(2)\">2\n      </td>\n      <td [ngClass]=\"wrapCls\" (click)=\"tdClick(3)\">3\n      </td>\n      <td class=\"keyboard-delete\" [rowSpan]=\"2\" [ngClass]=\"wrapCls\" (click)=\"tdClick('delete')\">\n      </td>\n    </tr>\n    <tr>\n      <td [ngClass]=\"wrapCls\" (click)=\"tdClick(4)\">4\n      </td>\n      <td [ngClass]=\"wrapCls\" (click)=\"tdClick(5)\">5\n      </td>\n      <td [ngClass]=\"wrapCls\" (click)=\"tdClick(6)\">6\n      </td>\n\n    </tr>\n    <tr>\n      <td [ngClass]=\"wrapCls\" (click)=\"tdClick(7)\">7\n      </td>\n      <td [ngClass]=\"wrapCls\" (click)=\"tdClick(8)\">8\n      </td>\n      <td [ngClass]=\"wrapCls\" (click)=\"tdClick(9)\">9\n      </td>\n      <td class=\"keyboard-confirm\" [rowSpan]=\"2\" [ngClass]=\"wrapCls\" (click)=\"tdClick('confirm')\">{{okText}}\n      </td>\n    </tr>\n    <tr>\n      <td [ngClass]=\"wrapCls\" (click)=\"tdClick('.')\">.\n      </td>\n      <td [ngClass]=\"wrapCls\" (click)=\"tdClick(0)\">0\n      </td>\n      <td class=\"keyboard-hide\" [ngClass]=\"wrapCls\" (click)=\"tdClick('hide')\">\n      </td>\n    </tr>\n  </tbody>\n</table>\n</div>\n\n",
                encapsulation: ViewEncapsulation.None,
                providers: [LocaleProviderService]
            }] }
];
/** @nocollapse */
CustomKeyboardComponent.ctorParameters = () => [
    { type: LocaleProviderService }
];
CustomKeyboardComponent.propDecorators = {
    onClick: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CustomInputService {
    /**
     * @param {?} _appRef
     * @param {?} _cfr
     */
    constructor(_appRef, _cfr) {
        this._appRef = _appRef;
        this._cfr = _cfr;
        CustomInputService.appRef = this._appRef;
        CustomInputService._inputCompFactory = this._cfr.resolveComponentFactory(CustomKeyboardComponent);
    }
    /**
     * @return {?}
     */
    static getShowStatus() {
        return CustomInputService.isShow;
    }
    /**
     * @return {?}
     */
    static showKeyboard() {
        if (!this.isShow) {
            if (this.compRef) {
                this.compRef.instance.wrapperCls = {
                    [`am-number-keyboard-wrapper`]: true
                };
            }
            else {
                /** @type {?} */
                let container = document.querySelector(`#${this._keyboardPrefixCls}-container`);
                if (!container) {
                    container = document.createElement('div');
                    container.setAttribute('id', `${this._keyboardPrefixCls}-container`);
                    document.body.appendChild(container);
                    container.appendChild(document.createElement(CustomInputService._inputCompFactory.selector));
                    this.compRef = this.appRef.bootstrap(CustomInputService._inputCompFactory);
                    this.compRef.instance.onClick.subscribe((/**
                     * @param {?} e
                     * @return {?}
                     */
                    e => {
                        this.clickValue = e;
                    }));
                }
            }
            this.isShow = true;
        }
    }
    /**
     * @return {?}
     */
    static hideKeyboard() {
        if (this.compRef && this.isShow) {
            this.isShow = false;
            this.compRef.instance.wrapperCls = {
                [`am-number-keyboard-wrapper`]: true,
                [`am-number-keyboard-wrapper-hide`]: true
            };
        }
    }
}
CustomInputService.compRef = null;
CustomInputService.appRef = null;
CustomInputService.isShow = false;
CustomInputService.clickValue = null;
CustomInputService._inputCompFactory = null;
CustomInputService._keyboardPrefixCls = 'am-number-keyboard';
CustomInputService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
CustomInputService.ctorParameters = () => [
    { type: ApplicationRef },
    { type: ComponentFactoryResolver }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CustomInputComponent {
    /**
     * @param {?} _ref
     * @param {?} _customInputService
     * @param {?} _ngZone
     */
    constructor(_ref, _customInputService, _ngZone) {
        this._ref = _ref;
        this._customInputService = _customInputService;
        this._ngZone = _ngZone;
        this.keyboardPrefixCls = 'am-number-keyboard';
        this.focus = false;
        this._value = '';
        this._defaultValue = '';
        this._placeholder = '';
        this._editable = true;
        this._disabled = false;
        this._setFocus = false;
        this.onChange = new EventEmitter();
        this.onBlur = new EventEmitter();
        this.onFocus = new EventEmitter();
        this.clsFakeContainer = true;
        this.inputFocus = (/**
         * @return {?}
         */
        () => {
            this.removeBlurListener();
            /** @type {?} */
            const focus = this.focus;
            if (!focus || this._setFocus) {
                this.onInputFocus();
            }
            setTimeout((/**
             * @return {?}
             */
            () => {
                this.addBlurListener();
            }), 50);
        });
        this.doBlur = (/**
         * @param {?} ev
         * @return {?}
         */
        ev => {
            /** @type {?} */
            const value = this._value;
            // 点击是否是组件本身
            /** @type {?} */
            let parentFound = false;
            // 点击目标是否是custom-input
            /** @type {?} */
            let isInput = false;
            // 点击目标是否是custom-keyboard
            /** @type {?} */
            let isKeyboard = false;
            /** @type {?} */
            let isClear = false;
            /** @type {?} */
            let target = ev.target;
            while (target && target !== null && !parentFound) {
                if (target === this._ref.nativeElement) {
                    parentFound = true;
                }
                if (target.localName === 'custominput') {
                    isInput = true;
                }
                if (target.localName === 'customkeyboard') {
                    isKeyboard = true;
                }
                if (target.className.indexOf('am-input-clear') >= 0) {
                    isClear = true;
                }
                target = target.parentElement;
            }
            // 当点击目标是本身的时候，获取焦点、不隐藏keyboard
            // 当点击目标不是本身但是其他的custom-input时，失去焦点、不隐藏keyboard
            // 当点击目标是keyboard时，不失去焦点，不隐藏keyboard
            if (parentFound) {
                this.focus = true;
            }
            else if (isInput) {
                this._setFocus = false;
                this.focus = false;
                this.onBlur.emit(this._value);
            }
            if (this.focus && isKeyboard) {
                this.focus = true;
                this.onKeyboardClick(CustomInputService.clickValue);
            }
            if (!parentFound && !isInput && !isKeyboard && !isClear && !this._setFocus) {
                this.focus = false;
                this._setFocus = false;
                this.onBlur.emit(this._value);
                CustomInputService.hideKeyboard();
            }
            this.setFakeInputCls();
        });
        this.removeBlurListener = (/**
         * @return {?}
         */
        () => {
            document.removeEventListener('click', this.doBlur, false);
        });
        this.addBlurListener = (/**
         * @return {?}
         */
        () => {
            document.addEventListener('click', this.doBlur, false);
        });
        this.onInputBlur = (/**
         * @param {?} value
         * @return {?}
         */
        value => {
            this.focus = false;
            this.setFakeInputCls();
            this.onBlur.emit(this._value);
            CustomInputService.hideKeyboard();
        });
        this.onInputFocus = (/**
         * @return {?}
         */
        () => {
            this.onFocus.emit(this._value);
            this.focus = true;
            this._setFocus = false;
            this.setFakeInputCls();
            setTimeout((/**
             * @return {?}
             */
            () => {
                CustomInputService.showKeyboard();
            }), 100);
        });
        this.setFakeInputCls = (/**
         * @return {?}
         */
        () => {
            this.fakeInputCls = {
                [`fake-input`]: true,
                ['fake-input-disabled']: this._disabled,
                ['focus']: this.focus
            };
        });
        this.setContainerCls = (/**
         * @return {?}
         */
        () => {
            this.clsFakeContainerLeft = this._moneyKeyboardAlign === 'left';
        });
        this.onKeyboardClick = (/**
         * @param {?} keyboardItemValue
         * @return {?}
         */
        keyboardItemValue => {
            /** @type {?} */
            let valueAfterChange;
            // 删除键
            if (keyboardItemValue === 'delete') {
                valueAfterChange = this._value.substring(0, this._value.length - 1);
                this.onChange.emit(valueAfterChange);
                // 确认键
            }
            else if (keyboardItemValue === 'confirm') {
                valueAfterChange = this._value;
                this.onChange.emit(valueAfterChange);
                this.onInputBlur(this._value);
                // 收起键
            }
            else if (keyboardItemValue === 'hide') {
                valueAfterChange = this._value;
                this.onInputBlur(valueAfterChange);
            }
            else {
                if (this._maxLength !== undefined &&
                    +this._maxLength >= 0 &&
                    (this._value + keyboardItemValue).length > this._maxLength) {
                    valueAfterChange = (this._value + keyboardItemValue).substr(0, this._maxLength);
                    this.onChange.emit(valueAfterChange);
                }
                else {
                    valueAfterChange = this._value + keyboardItemValue;
                    this.onChange.emit(valueAfterChange);
                }
            }
            this._ngZone.run((/**
             * @return {?}
             */
            () => {
                this._value = valueAfterChange;
            }));
        });
    }
    /**
     * @return {?}
     */
    get value() {
        return this._value;
    }
    /**
     * @param {?} v
     * @return {?}
     */
    set value(v) {
        if (typeof v === 'undefined' || v === null) {
            this._value = '';
        }
        else if (this._maxLength !== undefined && this._maxLength >= 0) {
            this._value = v.toString().substr(0, this._maxLength);
        }
        else {
            this._value = v.toString();
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set defaultValue(value) {
        this._defaultValue = value;
        if (!this._value) {
            this._value = this._defaultValue.toString();
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set maxLength(value) {
        this._maxLength = value;
    }
    /**
     * @return {?}
     */
    get placeholder() {
        return this._placeholder;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set placeholder(value) {
        this._placeholder = value;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set editable(value) {
        this._editable = value;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set disabled(value) {
        this._disabled = value;
    }
    /**
     * @return {?}
     */
    get fontColor() {
        return this._fontColor;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set fontColor(value) {
        this._fontColor = value;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set moneyKeyboardAlign(value) {
        this._moneyKeyboardAlign = value;
        this.setContainerCls();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set setFocus(value) {
        if (value) {
            this._setFocus = value.focus;
            if (this._setFocus) {
                this.inputFocus();
            }
        }
    }
    /**
     * @return {?}
     */
    onFakeInputClick() {
        if (this._preventKeyboard) {
            return;
        }
        this.inputFocus();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this._preventKeyboard = this._disabled || !this._editable;
        this.setFakeInputCls();
        this.setContainerCls();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.removeBlurListener();
        if (CustomInputService) {
            CustomInputService.hideKeyboard();
            CustomInputService.compRef = null;
        }
        /** @type {?} */
        const container = document.querySelector(`#${this.keyboardPrefixCls}-container`);
        if (container) {
            container.remove();
        }
    }
}
CustomInputComponent.decorators = [
    { type: Component, args: [{
                selector: 'CustomInput',
                template: "<div *ngIf=\"value===''\" class=\"fake-input-placeholder\">\n  {{placeholder}}\n</div>\n<div [ngClass]=\"fakeInputCls\"  [style.color]='fontColor' (click)=\"onFakeInputClick()\" >\n  {{value}}\n</div>\n",
                encapsulation: ViewEncapsulation.None,
                providers: [CustomInputService]
            }] }
];
/** @nocollapse */
CustomInputComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: CustomInputService },
    { type: NgZone }
];
CustomInputComponent.propDecorators = {
    value: [{ type: Input }],
    defaultValue: [{ type: Input }],
    maxLength: [{ type: Input }],
    placeholder: [{ type: Input }],
    editable: [{ type: Input }],
    disabled: [{ type: Input }],
    fontColor: [{ type: Input }],
    moneyKeyboardAlign: [{ type: Input }],
    setFocus: [{ type: Input }],
    onChange: [{ type: Output }],
    onBlur: [{ type: Output }],
    onFocus: [{ type: Output }],
    clsFakeContainer: [{ type: HostBinding, args: ['class.fake-input-container',] }],
    clsFakeContainerLeft: [{ type: HostBinding, args: ['class.fake-input-container-left',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class InputItemModule {
}
InputItemModule.decorators = [
    { type: NgModule, args: [{
                exports: [InputItemComponent, CustomKeyboardComponent, CustomInputComponent],
                declarations: [InputItemComponent, CustomKeyboardComponent, CustomInputComponent],
                entryComponents: [CustomKeyboardComponent],
                imports: [CommonModule, FormsModule, ReactiveFormsModule]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ButtonComponent {
    /**
     * @param {?} _elementRef
     * @param {?} _render
     */
    constructor(_elementRef, _render) {
        this._elementRef = _elementRef;
        this._render = _render;
        this.prefixCls = 'am-button';
        this.ngTemplate = false;
        this._className = '';
        this._classList = [];
        this._size = 'large';
        this._loading = false;
        this._active = false;
        this._inline = false;
        this._disabled = false;
        this._icon = '';
        this._userAgent = ((/** @type {?} */ (navigator))).userAgent || ((/** @type {?} */ (navigator))).vendor || ((/** @type {?} */ (window))).opera;
        this.onClick = new EventEmitter();
        this._el = this._elementRef.nativeElement;
        this._render.addClass(this._el, this.prefixCls);
        this._className = this._el.className;
    }
    /**
     * @return {?}
     */
    get type() {
        return this._type;
    }
    /**
     * @return {?}
     */
    get size() {
        return this._size;
    }
    /**
     * @return {?}
     */
    get disabled() {
        return this._disabled;
    }
    /**
     * @return {?}
     */
    get loading() {
        return this._loading;
    }
    /**
     * @return {?}
     */
    get inline() {
        return this._inline;
    }
    /**
     * @return {?}
     */
    get icon() {
        return this._icon;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set icon(value) {
        if (value instanceof TemplateRef) {
            this.ngTemplate = true;
            this._icon = value;
        }
        else {
            this.ngTemplate = false;
            this._icon = (/** @type {?} */ (value));
            this.setClassMap();
        }
    }
    /**
     * @param {?} v
     * @return {?}
     */
    set className(v) {
        this._className = this._className + ' ' + v;
        this.setClassMap();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    touchStart(event) {
        if (this._disabled) {
            return;
        }
        this._active = true;
        this.setClassMap();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    touchEnd(event) {
        if (this._disabled) {
            return;
        }
        this._active = false;
        this.setClassMap();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    click(event) {
        if (this._disabled) {
            return;
        }
        this.onClick.emit();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    isTemplateRef(value) {
        if (value) {
            return value instanceof TemplateRef;
        }
        return false;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set type(value) {
        this._type = value;
        this.setClassMap();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set disabled(value) {
        this._disabled = value;
        this.setClassMap();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set loading(value) {
        this._loading = value;
        if (this._el.querySelector('icon')) {
            /** @type {?} */
            const icon = (/** @type {?} */ (this._el.querySelector('icon')));
            icon.style.display = value ? '' : 'none';
        }
        this.setClassMap();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set size(value) {
        this._size = value;
        this.setClassMap();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set inline(value) {
        this._inline = value;
        this.setClassMap();
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        if (this._el.querySelector('img')) {
            /** @type {?} */
            const amSize = this._size === 'small' ? 'am-icon-xxs' : 'am-icon-md';
            this._el.querySelector('img').setAttribute('class', `am-icon ${this.prefixCls}-icon ${amSize}`);
            this._render.addClass(this._el, `${this.prefixCls}-icon`);
        }
    }
    /**
     * @private
     * @return {?}
     */
    setClassMap() {
        this.iconType = this._loading ? 'loading' : this._icon;
        this._classList = [
            this._type && `${this.prefixCls}-${this._type}`,
            this._size === 'small' && `${this.prefixCls}-${this._size}`,
            this._disabled && `${this.prefixCls}-disabled`,
            this._loading && `${this.prefixCls}-loading`,
            this.iconType && `${this.prefixCls}-icon`,
            this._active && `${this.prefixCls}-active`,
            this._inline && `${this.prefixCls}-inline`
        ].filter((/**
         * @param {?} item
         * @return {?}
         */
        item => {
            return !!item;
        }));
        this._el.className = this._className + ' ' + this._classList.join(' ');
    }
}
ButtonComponent.decorators = [
    { type: Component, args: [{
                selector: '[Button], nzm-button',
                encapsulation: ViewEncapsulation.None,
                template: "<Icon *ngIf=\"!ngTemplate\"\n      class=\"{{prefixCls}}-icon\"\n      [type]=\"iconType\"\n      [size]=\"size ==='small' ? 'xxs' : 'md'\"\n></Icon>\n<ng-template *ngIf=\"ngTemplate\" [ngTemplateOutlet]=\"icon\"></ng-template>\n<ng-content select=\"img\"></ng-content>\n<div class=\"{{prefixCls}}-content\">\n  <span>\n    <ng-content></ng-content>\n  </span>\n</div>"
            }] }
];
/** @nocollapse */
ButtonComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
ButtonComponent.propDecorators = {
    type: [{ type: Input }],
    size: [{ type: Input }],
    disabled: [{ type: Input }],
    loading: [{ type: Input }],
    inline: [{ type: Input }],
    icon: [{ type: Input }],
    className: [{ type: Input }],
    onClick: [{ type: Output }],
    touchStart: [{ type: HostListener, args: ['touchstart', ['$event'],] }, { type: HostListener, args: ['mousedown', ['$event'],] }],
    touchEnd: [{ type: HostListener, args: ['touchend', ['$event'],] }, { type: HostListener, args: ['mouseup', ['$event'],] }, { type: HostListener, args: ['touchmove', ['$event'],] }, { type: HostListener, args: ['mousemove', ['$event'],] }, { type: HostListener, args: ['touchcancel', ['$event'],] }],
    click: [{ type: HostListener, args: ['click', ['$event'],] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const svgSprite = (/**
 * @param {?} contents
 * @return {?}
 */
contents => `
<svg
  xmlns="http://www.w3.org/2000/svg"
  xmlns:xlink="https://www.w3.org/1999/xlink"
  id="__ANTD_MOBILE_SVG_SPRITE_NODE__"
  style="position:absolute;width:0;height:0"
>
  <defs>
    ${contents}
  </defs>
</svg>
`);
class IconHandler {
    constructor() {
        this.contents = [];
        // both minified by https://github.com/svg/svgo
        this.icons = {
            check: '<svg viewBox="0 0 44 44"><path fill-rule="evenodd" d="M34.538 8L38 11.518 17.808 32 8 22.033l3.462-3.518 6.346 6.45z"/></svg>',
            'check-circle': '<svg viewBox="0 0 48 48"><path d="M24 48c13.255 0 24-10.745 24-24S37.255 0 24 0 0 10.745 0 24s10.745 24 24 24zM13.1 23.2l-2.2 2.1 10 9.9L38.1 15l-2.2-2-15.2 17.8-7.6-7.6z" fill-rule="evenodd"/></svg>',
            'check-circle-o': '<svg viewBox="0 0 48 48"><g fill-rule="evenodd"><path d="M24 48c13.255 0 24-10.745 24-24S37.255 0 24 0 0 10.745 0 24s10.745 24 24 24zm0-3c11.598 0 21-9.402 21-21S35.598 3 24 3 3 12.402 3 24s9.402 21 21 21z"/><path d="M12.2 23.2L10 25.3l10 9.9L37.2 15 35 13 19.8 30.8z"/></g></svg>',
            cross: '<svg viewBox="0 0 44 44"><path fill-rule="evenodd" d="M24.008 21.852l8.97-8.968L31.092 11l-8.97 8.968L13.157 11l-1.884 1.884 8.968 8.968-9.24 9.24 1.884 1.885 9.24-9.24 9.24 9.24 1.885-1.884-9.24-9.24z"/></svg>',
            'cross-circle': '<svg viewBox="0 0 48 48"><g fill-rule="evenodd"><path d="M24 48c13.255 0 24-10.745 24-24S37.255 0 24 0 0 10.745 0 24s10.745 24 24 24zm0-3c11.598 0 21-9.402 21-21S35.598 3 24 3 3 12.402 3 24s9.402 21 21 21z"/><path d="M24.34 22.22l-7.775-7.775a1.5 1.5 0 1 0-2.12 2.12l7.773 7.775-7.774 7.775a1.5 1.5 0 1 0 2.12 2.12l7.775-7.773 7.774 7.774a1.5 1.5 0 1 0 2.12-2.12L26.46 24.34l7.774-7.774a1.5 1.5 0 1 0-2.12-2.12l-7.776 7.773z"/></g></svg>',
            'cross-circle-o': '<svg viewBox="0 0 48 48"><path d="M24 48c13.255 0 24-10.745 24-24S37.255 0 24 0 0 10.745 0 24s10.745 24 24 24zm.353-25.77l-7.593-7.593c-.797-.8-1.538-.822-2.263-.207-.724.614-.56 1.617-.124 2.067l7.852 7.847-7.72 7.723c-.727.728-.56 1.646-.066 2.177.493.532 1.553.683 2.31-.174l7.588-7.584 7.644 7.623c.796.798 1.608.724 2.21.145.605-.58.72-1.442-.074-2.24l-7.657-7.67 7.545-7.52c.81-.697.9-1.76.297-2.34-.92-.885-1.85-.338-2.264.078l-7.685 7.667z" fill-rule="evenodd"/></svg>',
            // Todo: simplify direction to 2, use css transform
            left: '<svg viewBox="0 0 44 44"><defs><path id="a" d="M-129-845h24v24h-24z"/></defs><clipPath id="b"><use xlink:href="#a" overflow="visible"/></clipPath><g clip-path="url(#b)"><defs><path id="c" d="M-903-949H947V996H-903z"/></defs></g><path d="M16.247 21.4L28.48 9.165l2.12 2.12-10.117 10.12L30.6 31.524l-2.12 2.12-12.233-12.232.007-.006z"/></svg>',
            right: '<svg viewBox="0 0 44 44"><defs><path id="a" d="M-129-845h24v24h-24z"/></defs><clipPath id="b"><use xlink:href="#a" overflow="visible"/></clipPath><g clip-path="url(#b)"><defs><path id="c" d="M-903-949H947V996H-903z"/></defs></g><path d="M30.6 21.4L18.37 9.165l-2.12 2.12 10.117 10.12-10.118 10.118 2.12 2.12 12.234-12.232-.005-.006z"/></svg>',
            down: '<svg viewBox="0 0 44 44"><path d="M22.355 28.237l-11.483-10.9c-.607-.576-1.714-.396-2.48.41l.674-.71c-.763.802-.73 2.07-.282 2.496l11.37 10.793-.04.04 2.088 2.195L23.3 31.52l12.308-11.682c.447-.425.48-1.694-.282-2.496l.674.71c-.766-.806-1.873-.986-2.48-.41L22.355 28.237z" fill-rule="evenodd"/></svg>',
            up: '<svg viewBox="0 0 44 44"><path fill="none" d="M-1-1h46v46H-1z"/><defs><path id="a" d="M-129-845h24v24h-24z"/></defs><clipPath id="b"><use xlink:href="#a"/></clipPath><g clip-path="url(#b)"><defs><path id="c" d="M-903-949H947V996H-903z"/></defs></g><path d="M23.417 14.23L11.184 26.46l2.12 2.12 10.12-10.117 10.118 10.118 2.12-2.12L23.43 14.228l-.006.005z"/></svg>',
            loading: '<svg viewBox="0 -2 59.75 60.25"><path fill="#ccc" d="M29.69-.527C14.044-.527 1.36 12.158 1.36 27.806S14.043 56.14 29.69 56.14c15.65 0 28.334-12.686 28.334-28.334S45.34-.527 29.69-.527zm.185 53.75c-14.037 0-25.417-11.38-25.417-25.417S15.838 2.39 29.875 2.39s25.417 11.38 25.417 25.417-11.38 25.416-25.417 25.416z"/><path fill="none" stroke="#108ee9" stroke-width="3" stroke-linecap="round" stroke-miterlimit="10" d="M56.587 29.766c.37-7.438-1.658-14.7-6.393-19.552"/></svg>',
            search: '<svg viewBox="0 0 44 44"><path d="M32.98 29.255l8.915 8.293L39.603 40l-8.86-8.242a15.952 15.952 0 0 1-10.753 4.147C11.16 35.905 4 28.763 4 19.952 4 11.142 11.16 4 19.99 4s15.99 7.142 15.99 15.952c0 3.472-1.112 6.685-3 9.303zm.05-9.21c0 7.123-5.7 12.918-12.88 12.918-7.176 0-13.015-5.795-13.015-12.918 0-7.12 5.84-12.917 13.017-12.917 7.178 0 12.88 5.797 12.88 12.917z" fill-rule="evenodd"/></svg>',
            ellipsis: '<svg viewBox="0 0 44 44"><circle cx="21.888" cy="22" r="4.045"/><circle cx="5.913" cy="22" r="4.045"/><circle cx="37.863" cy="22" r="4.045"/></svg>',
            'ellipsis-circle': '<svg viewBox="0 0 44 44"><g fill-rule="evenodd"><path d="M22.13.11C10.05.11.255 9.902.255 21.983S10.05 43.86 22.13 43.86s21.875-9.795 21.875-21.876S34.21.11 22.13.11zm0 40.7c-10.396 0-18.825-8.43-18.825-18.826S11.735 3.16 22.13 3.16c10.396 0 18.825 8.428 18.825 18.824S32.525 40.81 22.13 40.81z"/><circle cx="21.888" cy="22.701" r="2.445"/><circle cx="12.23" cy="22.701" r="2.445"/><circle cx="31.546" cy="22.701" r="2.445"/></g></svg>',
            'exclamation-circle': '<svg viewBox="0 0 64 64"><path d="M59.58 40.89L41.193 9.11C39.135 5.382 35.723 3 31.387 3c-3.11 0-6.52 2.382-8.58 6.11L4.42 40.89c-2.788 4.635-3.126 8.81-1.225 12.22C5.015 56.208 7.572 58 13 58h36.773c5.428 0 9.21-1.792 11.03-4.89 1.9-3.41 1.565-7.583-1.224-12.22zm-2.452 11c-.635 1.694-3.802 2.443-7.354 2.443H13c-3.59 0-5.493-.75-6.13-2.444-1.71-2.41-1.374-5.263 0-8.557l18.387-31.777c2.116-3.168 4.394-4.89 6.13-4.89 2.96 0 5.238 1.722 7.354 4.89l18.387 31.777c1.374 3.294 1.713 6.146 0 8.556zm-25.74-33c-.405 0-1.227.835-1.227 2.443v15.89c0 1.608.823 2.444 1.227 2.444 1.628 0 2.452-.836 2.452-2.445v-15.89c0-1.607-.825-2.443-2.453-2.443zm0 23.22c-.405 0-1.227.79-1.227 1.223v2.445c0 .434.823 1.222 1.227 1.222 1.628 0 2.452-.788 2.452-1.222v-2.445c0-.434-.825-1.222-2.453-1.222z" fill-rule="evenodd"/></svg>',
            'info-circle': '<svg viewBox="0 0 44 44"><circle cx="13.828" cy="19.63" r="1.938"/><circle cx="21.767" cy="19.63" r="1.938"/><circle cx="29.767" cy="19.63" r="1.938"/><path d="M22.102 4.16c-9.918 0-17.958 7.147-17.958 15.962 0 4.935 2.522 9.345 6.48 12.273v5.667l.04.012a2.627 2.627 0 1 0 4.5 1.455h.002l5.026-3.54c.628.06 1.265.094 1.91.094 9.92 0 17.96-7.146 17.96-15.96C40.06 11.306 32.02 4.16 22.1 4.16zm-.04 29.902c-.902 0-1.78-.08-2.642-.207l-5.882 4.234c-.024.024-.055.04-.083.06l-.008.005a.51.51 0 0 1-.284.095.525.525 0 0 1-.525-.525l.005-6.375c-3.91-2.516-6.456-6.544-6.456-11.1 0-7.628 7.107-13.812 15.875-13.812s15.875 6.184 15.875 13.812-7.107 13.812-15.875 13.812z"/></svg>',
            'question-circle': '<svg viewBox="0 0 44 44"><g fill-rule="evenodd"><path d="M21.186 3c-10.853 0-19.36 8.506-19.36 19.358C1.827 32.494 10.334 41 21.187 41c10.133 0 18.64-8.506 18.64-18.642C39.827 11.506 31.32 3 21.187 3m15.64 19c0 8.823-7.178 16-16 16s-16-7.177-16-16 7.178-16 16-16 16 7.177 16 16z"/><path d="M22.827 31.5a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0m4-15.48c0 .957-.203 1.822-.61 2.593-.427.792-1.117 1.612-2.073 2.457-.867.734-1.453 1.435-1.754 2.096-.302.7-.453 1.693-.453 2.98a.828.828 0 0 1-.823.854.828.828 0 0 1-.584-.22.877.877 0 0 1-.24-.635c0-1.305.168-2.38.506-3.227.336-.883.93-1.682 1.78-2.4 1.01-.883 1.71-1.692 2.1-2.428.336-.645.503-1.38.503-2.21-.02-.935-.3-1.7-.85-2.288-.655-.717-1.62-1.075-2.897-1.075-1.506 0-2.596.535-3.27 1.6-.46.754-.688 1.645-.688 2.677a.92.92 0 0 1-.266.66.747.747 0 0 1-.56.25.73.73 0 0 1-.584-.194c-.16-.164-.24-.393-.24-.69 0-1.82.585-3.272 1.755-4.357C18.645 11.486 19.928 11 21.434 11h.293c1.452 0 2.638.414 3.56 1.24 1.028.903 1.54 2.163 1.54 3.78z"/></g></svg>',
            voice: '<svg viewBox="0 0 38 33"><g fill-rule="evenodd"><path d="M17.838 28.8c-.564-.468-1.192-.983-1.836-1.496-4.244-3.385-5.294-3.67-6.006-3.67-.014 0-.027.005-.04.005-.015 0-.028-.006-.042-.006H3.562c-.734 0-.903-.203-.903-.928v-12.62c0-.49.057-.8.66-.8H9.1c.694 0 1.76-.28 6.4-3.63.83-.596 1.638-1.196 2.337-1.722V28.8zM19.682.19c-.463-.22-1.014-.158-1.417.157-.02.016-1.983 1.552-4.152 3.125C10.34 6.21 9.243 6.664 9.02 6.737H3.676c-.027 0-.053.003-.08.004H1.183c-.608 0-1.1.487-1.1 1.086V25.14c0 .598.492 1.084 1.1 1.084h8.71c.22.08 1.257.55 4.605 3.24 1.947 1.562 3.694 3.088 3.712 3.103.25.22.568.333.89.333.186 0 .373-.038.55-.116.48-.213.79-.684.79-1.204V1.38c0-.506-.294-.968-.758-1.19z" mask="url(#mask-2)"/><path d="M31.42 16.475c0-3.363-1.854-6.297-4.606-7.876-.125-.067-.42-.193-.625-.193-.613 0-1.11.488-1.11 1.09 0 .404.22.764.55.952 2.13 1.19 3.566 3.44 3.566 6.024 0 2.627-1.486 4.913-3.677 6.087-.32.19-.53.54-.53.935 0 .602.495 1.09 1.106 1.09.26.002.568-.15.568-.15 2.835-1.556 4.754-4.538 4.754-7.96" mask="url(#mask-4)"/><path d="M30.14 3.057c-.205-.122-.41-.22-.658-.22-.608 0-1.1.485-1.1 1.084 0 .434.26.78.627.978 4.042 2.323 6.76 6.636 6.76 11.578 0 4.938-2.715 9.248-6.754 11.572-.354.19-.66.55-.66.993 0 .6.494 1.085 1.102 1.085.243 0 .438-.092.65-.213 4.692-2.695 7.848-7.7 7.848-13.435 0-5.723-3.142-10.718-7.817-13.418" mask="url(#mask-6)"/></g></svg>',
            plus: '<svg viewBox="0 0 30 30"><path d="M14 14H0v2h14v14h2V16h14v-2H16V0h-2v14z" fill-rule="evenodd"/></svg>',
            minus: '<svg viewBox="0 0 30 2"><path d="M0 0h30v2H0z" fill-rule="evenodd"/></svg>',
            dislike: '<svg viewBox="0 0 72 72"><g fill="none" fill-rule="evenodd"><path d="M36 72c19.882 0 36-16.118 36-36S55.882 0 36 0 0 16.118 0 36s16.118 36 36 36zm0-2c18.778 0 34-15.222 34-34S54.778 2 36 2 2 17.222 2 36s15.222 34 34 34z" fill="#FFF"/><path fill="#FFF" d="M47 22h2v6h-2zm-24 0h2v6h-2z"/><path d="M21 51s4.6-7 15-7 15 7 15 7" stroke="#FFF" stroke-width="2"/></g></svg>',
            fail: '<svg viewBox="0 0 72 72"><g fill="none" fill-rule="evenodd"><path d="M36 72c19.882 0 36-16.118 36-36S55.882 0 36 0 0 16.118 0 36s16.118 36 36 36zm0-2c18.778 0 34-15.222 34-34S54.778 2 36 2 2 17.222 2 36s15.222 34 34 34z" fill="#FFF"/><path d="M22 22l28.304 28.304m-28.304 0L50.304 22" stroke="#FFF" stroke-width="2"/></g></svg>',
            success: '<svg viewBox="0 0 72 72"><g fill="none" fill-rule="evenodd"><path d="M36 72c19.882 0 36-16.118 36-36S55.882 0 36 0 0 16.118 0 36s16.118 36 36 36zm0-2c18.778 0 34-15.222 34-34S54.778 2 36 2 2 17.222 2 36s15.222 34 34 34z" fill="#FFF"/><path stroke="#FFF" stroke-width="2" d="M19 34.54l11.545 11.923L52.815 24"/></g></svg>'
        };
    }
    /**
     * @return {?}
     */
    renderSvgSprite() {
        /** @type {?} */
        const symbols = Object.keys(this.icons)
            .map((/**
         * @param {?} iconName
         * @return {?}
         */
        iconName => {
            /** @type {?} */
            const svgContent = this.icons[iconName].split('svg')[1];
            return `<symbol id=${iconName}${svgContent}symbol>`;
        }))
            .join('');
        return svgSprite(symbols);
    }
    /**
     * @return {?}
     */
    load() {
        if (!document) {
            return;
        }
        /** @type {?} */
        const existing = document.getElementById('__ANTD_MOBILE_SVG_SPRITE_NODE__');
        /** @type {?} */
        const mountNode = document.body;
        if (!existing) {
            mountNode.insertAdjacentHTML('afterbegin', this.renderSvgSprite());
        }
    }
}
IconHandler.decorators = [
    { type: Injectable }
];
/** @nocollapse */
IconHandler.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IconComponent {
    /**
     * @param {?} _iconHandler
     */
    constructor(_iconHandler) {
        this._iconHandler = _iconHandler;
        this.clsMap = {};
        this._type = '';
        this._size = 'md';
        this._src = '';
        this.color = '';
        this._iconHandler.load();
    }
    /**
     * @return {?}
     */
    get type() {
        return this._type;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set type(value) {
        this._type = value;
        this.setClsMap();
    }
    /**
     * @return {?}
     */
    get src() {
        return this._src;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set src(value) {
        this._src = value;
        this.setClsMap();
    }
    /**
     * @return {?}
     */
    get size() {
        return this._size;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set size(value) {
        this._size = value;
        this.setClsMap();
    }
    /**
     * @return {?}
     */
    setClsMap() {
        this.clsMap = {
            [`am-icon-${this._type}`]: true,
            [`am-icon-${this._size}`]: true
        };
    }
}
IconComponent.decorators = [
    { type: Component, args: [{
                selector: 'Icon, nzm-icon',
                template: "<svg *ngIf=\"type\"\n     class=\"am-icon\"\n     [ngClass]=\"clsMap\"\n     [ngStyle]=\"{color: color}\"\n>\n  <use xmlns:xlink=\"https://www.w3.org/1999/xlink\" attr.xlink:href=\"#{{type}}\"></use>\n</svg>\n<img *ngIf=\"src\" src=\"{{src}}\" class=\"am-icon\" [ngClass]=\"clsMap\">\n<ng-content></ng-content>\n",
                encapsulation: ViewEncapsulation.None,
                providers: [IconHandler]
            }] }
];
/** @nocollapse */
IconComponent.ctorParameters = () => [
    { type: IconHandler }
];
IconComponent.propDecorators = {
    color: [{ type: Input }],
    type: [{ type: Input }],
    src: [{ type: Input }],
    size: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IconModule {
}
IconModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                exports: [IconComponent],
                declarations: [IconComponent]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class WingBlankComponent {
    constructor() {
        this.prefixCls = 'am-wingblank';
        this.size = 'lg';
        this.amWingBlank = true;
    }
    /**
     * @return {?}
     */
    get amWingBlnkSm() {
        return this.size === 'sm';
    }
    /**
     * @return {?}
     */
    get amWingBlnkMd() {
        return this.size === 'md';
    }
    /**
     * @return {?}
     */
    get amWingBlnkLg() {
        return this.size === 'lg';
    }
}
WingBlankComponent.decorators = [
    { type: Component, args: [{
                selector: 'WingBlank, nzm-wingblank',
                template: "<ng-content></ng-content>\n",
                encapsulation: ViewEncapsulation.None
            }] }
];
/** @nocollapse */
WingBlankComponent.ctorParameters = () => [];
WingBlankComponent.propDecorators = {
    size: [{ type: Input }],
    amWingBlank: [{ type: HostBinding, args: ['class.am-wingblank',] }],
    amWingBlnkSm: [{ type: HostBinding, args: ['class.am-wingblank-sm',] }],
    amWingBlnkMd: [{ type: HostBinding, args: ['class.am-wingblank-md',] }],
    amWingBlnkLg: [{ type: HostBinding, args: ['class.am-wingblank-lg',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class WingBlankModule {
}
WingBlankModule.decorators = [
    { type: NgModule, args: [{
                declarations: [WingBlankComponent],
                exports: [WingBlankComponent],
                imports: [CommonModule]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class WhiteSpaceComponent {
    constructor() {
        this.prefixCls = 'am-whitespace';
        this.size = 'md';
        this.amWhiteSpace = true;
    }
    /**
     * @return {?}
     */
    get amWhitespaceXs() {
        return this.size === 'xs';
    }
    /**
     * @return {?}
     */
    get amWhitespaceSm() {
        return this.size === 'sm';
    }
    /**
     * @return {?}
     */
    get amWhitespaceMd() {
        return this.size === 'md';
    }
    /**
     * @return {?}
     */
    get amWhitespaceLg() {
        return this.size === 'lg';
    }
    /**
     * @return {?}
     */
    get amWhitespaceXl() {
        return this.size === 'xl';
    }
}
WhiteSpaceComponent.decorators = [
    { type: Component, args: [{
                selector: 'WhiteSpace, nzm-whitespace',
                template: ``
            }] }
];
/** @nocollapse */
WhiteSpaceComponent.ctorParameters = () => [];
WhiteSpaceComponent.propDecorators = {
    size: [{ type: Input }],
    amWhiteSpace: [{ type: HostBinding, args: ['class.am-whitespace',] }],
    amWhitespaceXs: [{ type: HostBinding, args: ['class.am-whitespace-xs',] }],
    amWhitespaceSm: [{ type: HostBinding, args: ['class.am-whitespace-sm',] }],
    amWhitespaceMd: [{ type: HostBinding, args: ['class.am-whitespace-md',] }],
    amWhitespaceLg: [{ type: HostBinding, args: ['class.am-whitespace-lg',] }],
    amWhitespaceXl: [{ type: HostBinding, args: ['class.am-whitespace-xl',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class WhiteSpaceModule {
}
WhiteSpaceModule.decorators = [
    { type: NgModule, args: [{
                declarations: [WhiteSpaceComponent],
                exports: [WhiteSpaceComponent],
                imports: [CommonModule]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ListComponent {
    constructor() {
        this.defaultProps = {
            prefixCls: 'am-list'
        };
        this.renderHeaderType = '';
        this.renderFooterType = '';
        this._renderHeader = '';
        this._renderFooter = '';
        this._className = '';
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set className(value) {
        this._className = value;
    }
    /**
     * @return {?}
     */
    get renderHeader() {
        return this._renderHeader;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set renderHeader(value) {
        if (value instanceof TemplateRef) {
            this.renderHeaderType = 'templateRef';
        }
        else {
            this.renderHeaderType = typeof value;
        }
        console.log('this isi rend', this.renderHeaderType);
        this._renderHeader = value;
    }
    /**
     * @return {?}
     */
    get renderFooter() {
        return this._renderFooter;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set renderFooter(value) {
        if (value instanceof TemplateRef) {
            this.renderFooterType = 'templateRef';
        }
        else {
            this.renderFooterType = typeof value;
        }
        this._renderFooter = value;
    }
    /**
     * @return {?}
     */
    get hostClassName() {
        return 'am-list ' + this._className;
    }
}
ListComponent.decorators = [
    { type: Component, args: [{
                selector: 'List, nzm-list',
                template: "<div *ngIf=\"renderHeader && renderHeaderType === 'string'\"\n     class=\"{{defaultProps.prefixCls}}-header\"\n     [innerHTML]=\"renderHeader\">\n</div>\n<div *ngIf=\"renderHeader && renderHeaderType === 'function'\"\n     class=\"{{defaultProps.prefixCls}}-header\">{{renderHeader()}}\n</div>\n<ng-template *ngIf=\"renderHeader && renderHeaderType === 'templateRef'\" [ngTemplateOutlet]=\"renderHeader\">\n</ng-template>\n<div class=\"{{defaultProps.prefixCls}}-body\">\n  <ng-content></ng-content>\n</div>\n<div *ngIf=\"renderFooter && renderFooterType === 'string'\"\n     class=\"{{defaultProps.prefixCls}}-footer\"\n     [innerHTML]=\"renderFooter\">\n</div>\n<div *ngIf=\"renderFooter && renderFooterType === 'function'\"\n     class=\"{{defaultProps.prefixCls}}-footer\">{{renderFooter()}}\n</div>\n<ng-template *ngIf=\"renderFooter && renderFooterType === 'templateRef'\" [ngTemplateOutlet]=\"renderFooter\">\n</ng-template>\n",
                encapsulation: ViewEncapsulation.None
            }] }
];
/** @nocollapse */
ListComponent.ctorParameters = () => [];
ListComponent.propDecorators = {
    className: [{ type: Input }],
    renderHeader: [{ type: Input }],
    renderFooter: [{ type: Input }],
    hostClassName: [{ type: HostBinding, args: ['class',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ListItemComponent {
    constructor() {
        this.defaultProps = {
            prefixCls: 'am-list',
            align: 'middle',
            error: false,
            multipleLine: false,
            wrap: false,
            platform: 'ios',
            rippleStyle: {}
        };
        this.arrowCls = {};
        this.lineCls = {};
        this.wrapCls = '';
        this.rippleCls = {};
        this.rippleClicked = false;
        this._thumb_component = false;
        this._thumb_src = '';
        this._extra_component = false;
        this._extra_title = '';
        this._arrow = '';
        this._disabled = false;
        this._className = '';
        this._active = false;
        this.onClick = new EventEmitter();
    }
    /**
     * @return {?}
     */
    get extra() {
        return this._extra;
    }
    /**
     * @return {?}
     */
    get extra_component() {
        return this._extra_component;
    }
    /**
     * @return {?}
     */
    get extra_title() {
        return this._extra_title;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set extra(value) {
        if (value instanceof TemplateRef) {
            this._extra_component = true;
            this._extra = value;
        }
        else {
            this._extra_component = false;
            this._extra_title = (/** @type {?} */ (value));
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set className(value) {
        this._className = value;
        this.setClsMap();
    }
    /**
     * @return {?}
     */
    get arrow() {
        return this._arrow;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set arrow(value) {
        this._arrow = value;
        this.setClsMap();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set multipleLine(value) {
        this.defaultProps.multipleLine = value === '' ? true : value;
        this.setClsMap();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set error(value) {
        this.defaultProps.error = value === '' ? true : value;
        this.setClsMap();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set wrap(value) {
        this.defaultProps.wrap = value === '' ? true : value;
        this.setClsMap();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set align(value) {
        this.defaultProps.align = value;
        this.setClsMap();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set platform(value) {
        this.defaultProps.platform = value;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set disabled(value) {
        if (typeof value === 'boolean') {
            this._disabled = value;
        }
        else {
            if (value === 'true') {
                this._disabled = true;
            }
            else {
                this._disabled = false;
            }
        }
        this.setClsMap();
    }
    /**
     * @return {?}
     */
    get thumb() {
        return this._thumb;
    }
    /**
     * @return {?}
     */
    get thumb_component() {
        return this._thumb_component;
    }
    /**
     * @return {?}
     */
    get thumb_src() {
        return this._thumb_src;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set thumb(value) {
        if (value instanceof TemplateRef) {
            this._thumb_component = true;
            this._thumb = value;
        }
        else {
            this._thumb_component = false;
            this._thumb_src = (/** @type {?} */ (value));
        }
    }
    /**
     * @return {?}
     */
    get bingClassName() {
        return this.wrapCls;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    click(event) {
        this.onItemClick(event);
    }
    /**
     * @return {?}
     */
    start() {
        if (!this._disabled && this.onClick.observers.length > 0) {
            this._active = true;
            this.setClsMap();
        }
    }
    /**
     * @return {?}
     */
    move() {
        if (!this._disabled && this.onClick.observers.length > 0) {
            this._active = false;
            this.setClsMap();
        }
    }
    /**
     * @return {?}
     */
    end() {
        if (!this._disabled && this.onClick.observers.length > 0) {
            this._active = false;
            this.setClsMap();
        }
    }
    /**
     * @return {?}
     */
    mouse_start() {
        if (!this._disabled && this.onClick.observers.length > 0) {
            this._active = true;
            this.setClsMap();
        }
    }
    /**
     * @return {?}
     */
    mouse_end() {
        if (!this._disabled && this.onClick.observers.length > 0) {
            this._active = false;
            this.setClsMap();
        }
    }
    /**
     * @return {?}
     */
    setClsMap() {
        /** @type {?} */
        const classNameList = this._className.split(' ');
        /** @type {?} */
        let classNameObj = {};
        this.wrapCls = '';
        for (const value of classNameList) {
            if (value) {
                classNameObj = Object.assign({}, classNameObj, { [`${value}`]: true });
            }
        }
        /** @type {?} */
        const wrapClsObj = Object.assign({ [`${this.defaultProps.prefixCls}-item`]: true, [`${this.defaultProps.prefixCls}-item-disabled`]: this._disabled, [`${this.defaultProps.prefixCls}-item-active`]: this._active, [`${this.defaultProps.prefixCls}-item-error`]: this.defaultProps.error, [`${this.defaultProps.prefixCls}-item-top`]: this.defaultProps.align === 'top', [`${this.defaultProps.prefixCls}-item-middle`]: this.defaultProps.align === 'middle', [`${this.defaultProps.prefixCls}-item-bottom`]: this.defaultProps.align === 'bottom' }, classNameObj);
        for (const key in wrapClsObj) {
            if (wrapClsObj[key]) {
                this.wrapCls += ` ${key}`;
            }
        }
        this.rippleCls = {
            [`${this.defaultProps.prefixCls}-ripple`]: true,
            [`${this.defaultProps.prefixCls}-ripple-animate`]: this.rippleClicked
        };
        this.lineCls = {
            [`${this.defaultProps.prefixCls}-line`]: true,
            [`${this.defaultProps.prefixCls}-line-multiple`]: this.defaultProps.multipleLine,
            [`${this.defaultProps.prefixCls}-line-wrap`]: this.defaultProps.wrap
        };
        this.arrowCls = {
            [`${this.defaultProps.prefixCls}-arrow`]: true,
            [`${this.defaultProps.prefixCls}-arrow-horizontal`]: this._arrow === 'horizontal',
            [`${this.defaultProps.prefixCls}-arrow-vertical`]: this._arrow === 'down' || this._arrow === 'up',
            [`${this.defaultProps.prefixCls}-arrow-vertical-up`]: this._arrow === 'up'
        };
    }
    /**
     * @param {?} ev
     * @return {?}
     */
    onItemClick(ev) {
        /** @type {?} */
        const isAndroid = this.defaultProps.platform === 'android';
        if (isAndroid) {
            if (this.debounceTimeout) {
                clearTimeout(this.debounceTimeout);
                this.debounceTimeout = null;
            }
            /** @type {?} */
            const Item = ev.currentTarget;
            /** @type {?} */
            const RippleWidth = Math.max(Item.offsetHeight, Item.offsetWidth);
            /** @type {?} */
            const ClientRect = ev.currentTarget.getBoundingClientRect();
            /** @type {?} */
            const pointX = ev.clientX - ClientRect.left - Item.offsetWidth / 2;
            /** @type {?} */
            const pointY = ev.clientY - ClientRect.top - Item.offsetWidth / 2;
            /** @type {?} */
            const coverRippleStyle = {
                width: `${RippleWidth}px`,
                height: `${RippleWidth}px`,
                left: `${pointX}px`,
                top: `${pointY}px`
            };
            this.defaultProps.rippleStyle = coverRippleStyle;
            this.rippleClicked = true;
            this.setClsMap();
            this.debounceTimeout = setTimeout((/**
             * @return {?}
             */
            () => {
                this.rippleClicked = false;
                this.defaultProps.rippleStyle = { display: 'none' };
                this.setClsMap();
            }), 1000);
        }
        this.onClick.emit(ev);
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.defaultProps.rippleStyle = { display: 'none' };
        this.setClsMap();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.debounceTimeout) {
            clearTimeout(this.debounceTimeout);
            this.debounceTimeout = null;
        }
    }
}
ListItemComponent.decorators = [
    { type: Component, args: [{
                selector: 'ListItem, nzm-list-item',
                template: "<div *ngIf=\"thumb_src && !thumb_component\" class=\"{{defaultProps.prefixCls}}-thumb\">\n  <img src={{thumb_src}}/>\n</div>\n<div *ngIf=\"thumb && thumb_component\" class=\"{{defaultProps.prefixCls}}-thumb\">\n  <ng-template [ngTemplateOutlet]=\"thumb\"></ng-template>\n</div>\n<div [ngClass]=\"lineCls\">\n  <div class=\"{{defaultProps.prefixCls}}-content\">\n    <ng-content></ng-content>\n  </div>\n  <div *ngIf=\"extra_title && !extra_component\"\n       class=\"{{defaultProps.prefixCls}}-extra\"\n       [innerHTML]=\"extra_title\"\n  ></div>\n  <div *ngIf=\"extra && extra_component\" class=\"{{defaultProps.prefixCls}}-extra\">\n    <ng-template [ngTemplateOutlet]=\"extra\"></ng-template>\n  </div>\n  <div *ngIf=\"arrow\" [ngClass]=\"arrowCls\" aria-hidden=\"true\"></div>\n</div>\n<div [ngClass]=\"rippleCls\" [ngStyle]=\"defaultProps.rippleStyle\"></div>\n\n",
                encapsulation: ViewEncapsulation.None
            }] }
];
/** @nocollapse */
ListItemComponent.ctorParameters = () => [];
ListItemComponent.propDecorators = {
    extra: [{ type: Input }],
    className: [{ type: Input }],
    arrow: [{ type: Input }],
    multipleLine: [{ type: Input }],
    error: [{ type: Input }],
    wrap: [{ type: Input }],
    align: [{ type: Input }],
    platform: [{ type: Input }],
    disabled: [{ type: Input }],
    thumb: [{ type: Input }],
    onClick: [{ type: Output }],
    bingClassName: [{ type: HostBinding, args: ['class',] }],
    click: [{ type: HostListener, args: ['click', ['$event'],] }],
    start: [{ type: HostListener, args: ['touchstart',] }],
    move: [{ type: HostListener, args: ['touchmove',] }],
    end: [{ type: HostListener, args: ['touchend',] }],
    mouse_start: [{ type: HostListener, args: ['mousedown',] }],
    mouse_end: [{ type: HostListener, args: ['mouseup',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class BriefComponent {
    constructor() {
        this.defaultProps = {
            prefixCls: 'am-list'
        };
    }
}
BriefComponent.decorators = [
    { type: Component, args: [{
                selector: 'Brief, nzm-brief',
                template: "<div class=\"{{defaultProps.prefixCls}}-brief\">\n  <ng-content></ng-content>\n</div>\n",
                encapsulation: ViewEncapsulation.None
            }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ListModule {
}
ListModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, FormsModule],
                exports: [ListComponent, ListItemComponent, BriefComponent],
                declarations: [ListComponent, ListItemComponent, BriefComponent]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const NZ_BUTTON_DIRECTIVES = [ButtonComponent];
class ButtonModule {
}
ButtonModule.decorators = [
    { type: NgModule, args: [{
                declarations: NZ_BUTTON_DIRECTIVES,
                exports: NZ_BUTTON_DIRECTIVES,
                imports: [CommonModule, IconModule, WingBlankModule, WhiteSpaceModule, ListModule]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SwitchComponent {
    constructor() {
        this.prefixCls = 'am-switch';
        this.wrapCls = 'am-switch';
        this.checkboxCls = {
            'checkbox-disabled': false,
            'checkbox-active': false,
            'checkbox-inactive': true
        };
        this.colorStyle = {};
        this.switchChecked = false;
        this._color = '';
        this._disabled = false;
        this.onChanged = Function.prototype;
        this.onTouched = Function.prototype;
        this.onChange = new EventEmitter();
        this.onClick = new EventEmitter();
        this.dispaly = true;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set color(value) {
        this._color = value;
        this.colorStyle = { background: this._color };
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set platform(value) {
        this.wrapCls = value === 'android' ? `${this.prefixCls}-android` : this.prefixCls;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set checked(value) {
        this.switchChecked = value;
        this.checkboxCls = {
            'checkbox-disabled': this._disabled,
            'checkbox-active': this.switchChecked,
            'checkbox-inactive': !this.switchChecked
        };
        this.colorStyle = { background: value ? this._color : '' };
    }
    /**
     * @return {?}
     */
    get disabled() {
        return this._disabled;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set disabled(value) {
        this._disabled = value;
        this.checkboxCls = {
            'checkbox-disabled': value,
            'checkbox-active': this.switchChecked,
            'checkbox-inactive': !this.switchChecked
        };
    }
    /**
     * @param {?} checkedValue
     * @return {?}
     */
    changeSwitch(checkedValue) {
        this.onChanged(checkedValue);
        this.switchChecked = checkedValue;
        this.checkboxCls = {
            'checkbox-disabled': this._disabled,
            'checkbox-active': this.switchChecked,
            'checkbox-inactive': !this.switchChecked
        };
        this.colorStyle = { background: checkedValue ? this._color : '' };
        this.onChange.emit(checkedValue);
    }
    /**
     * @return {?}
     */
    click() {
        this.onClick.emit(this.switchChecked);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        this.switchChecked = value;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.onChanged = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
}
SwitchComponent.decorators = [
    { type: Component, args: [{
                selector: 'Switch, nzm-switch',
                template: "<label class=\"{{prefixCls}}\" [ngClass]=\"wrapCls\">\n  <input #switchValue\n         type=\"checkbox\"\n         name=\"name\"\n         class=\"{{prefixCls}}-checkbox\"\n         [checked]=\"switchChecked\"\n         [value]=\"switchChecked\"\n         [disabled]=\"disabled\"\n         (change)=\"changeSwitch(switchValue.checked)\"\n  />\n  <div class=\"checkbox\"\n       [ngClass]=\"checkboxCls\"\n       [ngStyle]=\"colorStyle\"\n       (click)=\"click()\"\n  ></div>\n</label>",
                encapsulation: ViewEncapsulation.None,
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => SwitchComponent)),
                        multi: true
                    }
                ]
            }] }
];
/** @nocollapse */
SwitchComponent.ctorParameters = () => [];
SwitchComponent.propDecorators = {
    color: [{ type: Input }],
    name: [{ type: Input }],
    platform: [{ type: Input }],
    checked: [{ type: Input }],
    disabled: [{ type: Input }],
    onChange: [{ type: Output }],
    onClick: [{ type: Output }],
    dispaly: [{ type: HostBinding, args: ['style.display',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SwitchModule {
}
SwitchModule.decorators = [
    { type: NgModule, args: [{
                exports: [SwitchComponent],
                declarations: [SwitchComponent],
                imports: [CommonModule, WingBlankModule]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SearchBarComponent {
    /**
     * @param {?} _elementRef
     * @param {?} _localeProvider
     */
    constructor(_elementRef, _localeProvider) {
        this._elementRef = _elementRef;
        this._localeProvider = _localeProvider;
        this.prefixCls = 'am-search';
        this.cancelCls = {
            [`${this.prefixCls}-cancel`]: true
        };
        this._defaultValue = '';
        this._value = '';
        this._placeholder = '';
        this._showCancelButton = false;
        this._disabled = false;
        this._focus = false;
        this._isSubmit = false;
        this._isCustomText = false;
        this._isClearClicking = false;
        this._blurFromOnClear = false;
        this.locale = {};
        this._unsubscribe$ = new Subject();
        this.onSubmit = new EventEmitter();
        this.onChange = new EventEmitter();
        this.onFocus = new EventEmitter();
        this.onBlur = new EventEmitter();
        this.onCancel = new EventEmitter();
        this.onClear = new EventEmitter();
        this.onChangeFn = (/**
         * @return {?}
         */
        () => { });
        this.onTouchFn = (/**
         * @return {?}
         */
        () => { });
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set defaultValue(value) {
        this._defaultValue = value;
        this._value = value;
        this.inputElementRef.nativeElement.value = this._value;
    }
    /**
     * @return {?}
     */
    get value() {
        return this._value;
    }
    /**
     * @param {?} v
     * @return {?}
     */
    set value(v) {
        this._value = v || '';
        this.inputElementRef.nativeElement.value = this._value;
        this.setClass();
    }
    /**
     * @return {?}
     */
    get placeholder() {
        return this._placeholder;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set placeholder(value) {
        this._placeholder = value;
    }
    /**
     * @return {?}
     */
    get showCancelButton() {
        return this._showCancelButton;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set showCancelButton(value) {
        this._showCancelButton = value;
        this.setClass();
    }
    /**
     * @return {?}
     */
    get cancelText() {
        return this._cancelText;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set cancelText(value) {
        if (value !== undefined) {
            this._cancelText = value;
            this._isCustomText = true;
        }
    }
    /**
     * @return {?}
     */
    get disabled() {
        return this._disabled;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set disabled(value) {
        this._disabled = value;
    }
    /**
     * @return {?}
     */
    get maxLength() {
        return this._maxLength;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set maxLength(value) {
        this._maxLength = value;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set setFocus(value) {
        if (value) {
            if (value.focusValue) {
                this._focus = true;
                this.inputElementRef.nativeElement.focus();
                this._blurFromOnClear = true;
                this.onSearchbarFocus();
            }
            else {
                this._blurFromOnClear = false;
                this.onSearchbarBlur();
            }
        }
    }
    /**
     * @return {?}
     */
    setClass() {
        this.wrapCls = {
            [`${this.prefixCls}`]: true,
            [`${this.prefixCls}-start`]: !!(this._focus || (this._value && this._value.length > 0)) && !this._disabled
        };
        this.cancelCls = {
            [`${this.prefixCls}-cancel`]: true,
            [`${this.prefixCls}-cancel-show`]: this._showCancelButton || this._focus || (this._value && this._value.length > 0),
            [`${this.prefixCls}-cancel-anim`]: this._focus
        };
        this.clearCls = {
            [`${this.prefixCls}-clear`]: this._value && this._value.length > 0,
            [`${this.prefixCls}-clear-show`]: this._value && this._value.length > 0 && !this._isSubmit,
            [`${this.prefixCls}-clear-active`]: this._isClearClicking
        };
    }
    /**
     * @return {?}
     */
    setStyle() {
        if (this._inputContainerRef.className.indexOf(`${this.prefixCls}-start`) > -1) {
            /** @type {?} */
            const realWidth = this._syntheticPhContainerRef.getBoundingClientRect().width;
            this._syntheticPhRef.style.width = Math.ceil(realWidth) + 'px';
            if (!this._showCancelButton) {
                this._rightBtnRef.style.marginRight = '0';
            }
        }
        else {
            this._syntheticPhRef.style.width = '100%';
            if (!this._showCancelButton) {
                this._rightBtnInitMarginLeft = window.getComputedStyle(this._rightBtnRef)['margin-left'];
                /** @type {?} */
                const btnMarginRight = this._rightBtnRef.offsetWidth + parseInt(this._rightBtnInitMarginLeft, 10);
                this._rightBtnRef.style.marginRight = '-' + btnMarginRight + 'px';
            }
        }
    }
    /**
     * @return {?}
     */
    onSearchbarBlur() {
        /** @type {?} */
        const self = this;
        setTimeout((/**
         * @return {?}
         */
        () => {
            if (!self._blurFromOnClear && self._value === '' && self._focus) {
                self._focus = false;
                self._value = '';
                self.onBlur.emit();
                self.setClass();
            }
            self._blurFromOnClear = false;
        }), 50);
    }
    /**
     * @return {?}
     */
    onSearchbarFocus() {
        this._focus = true;
        this._isSubmit = false;
        this.onFocus.emit();
        this.setClass();
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onSearchbarChange(e) {
        this._focus = true;
        this._value = e;
        this.onChange.emit(e);
        this.onChangeFn(e);
        this.setClass();
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onSearchSubmit(e) {
        e.preventDefault();
        this._value = e.target[0].value;
        this._isSubmit = true;
        this.onSubmit.emit(this._value);
        this.setClass();
        this._blurFromOnClear = true;
    }
    /**
     * @return {?}
     */
    onSearchbarCancel() {
        this._focus = false;
        this._value = '';
        this.onCancel.emit();
        this.setClass();
    }
    /**
     * @return {?}
     */
    onSearchbarClear() {
        this._blurFromOnClear = true;
        this._isClearClicking = true;
        this.onSearchbarChange('');
        this.inputElementRef.nativeElement.focus();
        this.onClear.emit(this._value);
        this.setClass();
        setTimeout((/**
         * @return {?}
         */
        () => {
            this._value = '';
            this._isClearClicking = false;
            this._blurFromOnClear = false;
            this.setClass();
        }), 100);
        this.onSearchbarFocus();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        this._value = value || '';
        this.inputElementRef.nativeElement.value = this._value;
        this.setClass();
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.onChangeFn = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.onTouchFn = fn;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.setClass();
        this._localeProvider.localeChange.pipe(takeUntil(this._unsubscribe$)).subscribe((/**
         * @param {?} _
         * @return {?}
         */
        _ => {
            this.locale = this._localeProvider.getLocaleSubObj('SearchBar');
            this._cancelText = this._isCustomText ? this._cancelText : this.locale.cancelText;
        }));
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this._syntheticPhContainerRef = this._elementRef.nativeElement.getElementsByClassName(`${this.prefixCls}-synthetic-ph-container`)[0];
        this._syntheticPhRef = this._elementRef.nativeElement.getElementsByClassName(`${this.prefixCls}-synthetic-ph`)[0];
        this._rightBtnRef = this._elementRef.nativeElement.getElementsByClassName('cancel')[0];
        this._inputContainerRef = this._elementRef.nativeElement.getElementsByClassName(`${this.prefixCls}`)[0];
    }
    /**
     * @return {?}
     */
    ngAfterViewChecked() {
        this.setStyle();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._unsubscribe$.next();
        this._unsubscribe$.complete();
    }
}
SearchBarComponent.decorators = [
    { type: Component, args: [{
                selector: 'SearchBar, nzm-search-bar',
                template: "<form name=\"myForm\"\n      class=\"{{prefixCls}}\"\n      [ngClass]=\"wrapCls\"\n      action=\"#\"\n      (submit)=\"onSearchSubmit($event)\"\n>\n  <div class=\"{{prefixCls}}-input\">\n    <div class=\"{{prefixCls}}-synthetic-ph\"\n         style=\"box-sizing:unset\"\n         [@cancelButtonState]=\"showCancelButton?'visible' : 'hidden'\"\n    >\n      <span class=\"{{prefixCls}}-synthetic-ph-container\">\n        <i class=\"{{prefixCls}}-synthetic-ph-icon\"></i>\n        <span class=\"{{prefixCls}}-synthetic-ph-placeholder\"\n              [ngStyle]=\"{'visibility' : (placeholder && !value) ? 'visible' : 'hidden'}\"\n        >\n          {{placeholder}}\n        </span>\n      </span>\n    </div>\n    <input #search\n           class=\"{{prefixCls}}-value\"\n           style=\"outline:none;\"\n           [name]=\"'search'\"\n           [type]=\"'search'\"\n           [disabled]=\"disabled\"\n           [maxlength]=\"maxLength\"\n           [placeholder]=\"placeholder\"\n           [ngModel]=\"value\"\n           (blur)=\"onSearchbarBlur()\"\n           (focus)=\"onSearchbarFocus()\"\n           (ngModelChange)=\"onSearchbarChange($event)\"\n    />\n    <a [ngClass]=\"clearCls\"\n       style=\"box-sizing: content-box;transition: 0s\"\n       (click)=\"onSearchbarClear()\"\n    ></a>\n  </div>\n  <div class=\"cancel\"\n       [ngClass]=\"cancelCls\"\n       (click)=\"onSearchbarCancel()\"\n  >\n    {{cancelText}}\n  </div>\n</form>",
                encapsulation: ViewEncapsulation.None,
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => SearchBarComponent)),
                        multi: true
                    }
                ],
                animations: [
                    trigger('cancelButtonState', [
                        state('visible', style({ width: '*' })),
                        state('hidden', style({ width: '100%' })),
                        transition('visible =>hidden', [animate(300, style({ width: '100%' }))]),
                        transition('hidden => visible', [animate(300, style({ width: '*' }))])
                    ])
                ]
            }] }
];
/** @nocollapse */
SearchBarComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: LocaleProviderService }
];
SearchBarComponent.propDecorators = {
    inputElementRef: [{ type: ViewChild, args: ['search',] }],
    defaultValue: [{ type: Input }],
    value: [{ type: Input }],
    placeholder: [{ type: Input }],
    showCancelButton: [{ type: Input }],
    cancelText: [{ type: Input }],
    disabled: [{ type: Input }],
    maxLength: [{ type: Input }],
    setFocus: [{ type: Input }],
    onSubmit: [{ type: Output }],
    onChange: [{ type: Output }],
    onFocus: [{ type: Output }],
    onBlur: [{ type: Output }],
    onCancel: [{ type: Output }],
    onClear: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class LocaleProviderPipe {
    /**
     * @param {?} _locale
     */
    constructor(_locale) {
        this._locale = _locale;
    }
    /**
     * @param {?} keyPath
     * @return {?}
     */
    transform(keyPath) {
        return this._locale.getLocaleValue(keyPath);
    }
}
LocaleProviderPipe.decorators = [
    { type: Pipe, args: [{
                name: 'localeProvider'
            },] }
];
/** @nocollapse */
LocaleProviderPipe.ctorParameters = () => [
    { type: LocaleProviderService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
const ɵ0 = zh_CN;
class LocaleProviderModule {
}
LocaleProviderModule.decorators = [
    { type: NgModule, args: [{
                imports: [],
                declarations: [LocaleProviderPipe],
                exports: [LocaleProviderPipe],
                providers: [{ provide: LOCAL_PROVIDER_TOKEN, useValue: ɵ0 }, LOCALE_PROVIDER_SERVICE_PROVIDER]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SearchBarModule {
}
SearchBarModule.decorators = [
    { type: NgModule, args: [{
                exports: [SearchBarComponent],
                declarations: [SearchBarComponent],
                imports: [CommonModule, FormsModule, LocaleProviderModule],
                providers: [LocaleProviderModule]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class StepperComponent {
    constructor() {
        this.prefixCls = 'am-stepper';
        this._max = Infinity;
        this._min = -Infinity;
        this._step = 1;
        this._disabled = false;
        this._readOnly = false;
        this._showNumber = false;
        this._upDisabled = false;
        this._downDisabled = false;
        this._isUpClick = false;
        this._isDownClick = false;
        this.onChange = new EventEmitter();
        this.clsStepper = true;
        this.clsStpDisabled = this._disabled;
        this.clsShowNum = this._showNumber;
        this.onChangeFn = (/**
         * @return {?}
         */
        () => { });
        this.onTouchFn = (/**
         * @return {?}
         */
        () => { });
    }
    /**
     * @return {?}
     */
    get max() {
        return this._max;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set max(value) {
        this._max = value;
    }
    /**
     * @return {?}
     */
    get min() {
        return this._min;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set min(value) {
        this._min = value;
    }
    /**
     * @return {?}
     */
    get value() {
        return this._value;
    }
    /**
     * @param {?} v
     * @return {?}
     */
    set value(v) {
        this._value = v;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set step(value) {
        this._step = value;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set defaultValue(value) {
        if (value) {
            this._defaultValue = value;
            this._value = value;
        }
    }
    /**
     * @return {?}
     */
    get disabled() {
        return this._disabled;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set disabled(value) {
        if (value) {
            this._downDisabled = value;
            this._upDisabled = value;
        }
        this._disabled = value;
        this.clsStpDisabled = value;
    }
    /**
     * @return {?}
     */
    get readOnly() {
        return this._readOnly;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set readOnly(value) {
        this._readOnly = value;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set showNumber(value) {
        this._showNumber = value;
        this.clsShowNum = value;
    }
    /**
     * @return {?}
     */
    onIncrease() {
        if (!this._upDisabled) {
            this._value = this.plus(this._value, this._step);
            this.onChange.emit(this._value);
            this.onChangeFn(this._value);
            if (this.plus(this._value, this._step) > this._max) {
                this._upDisabled = true;
            }
            if (this.minus(this._value, this._step) >= this._min) {
                this._downDisabled = false;
            }
            this._isUpClick = true;
            this.setCls();
            setTimeout((/**
             * @return {?}
             */
            () => {
                this._isUpClick = false;
                this.setCls();
            }), 100);
        }
    }
    /**
     * @return {?}
     */
    onDecrease() {
        if (!this._downDisabled) {
            this._value = this.minus(this._value, this._step);
            this.onChange.emit(this._value);
            this.onChangeFn(this._value);
            if (this.minus(this._value, this._step) < this._min) {
                this._downDisabled = true;
            }
            if (this.plus(this._value, this._step) <= this._max) {
                this._upDisabled = false;
            }
            this._isDownClick = true;
            this.setCls();
            setTimeout((/**
             * @return {?}
             */
            () => {
                this._isDownClick = false;
                this.setCls();
            }), 100);
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    inputChange(event) {
        /** @type {?} */
        const value = event.target.value;
        this._value = value ? parseInt(value, null) : 0;
        if (value < this._min) {
            this._value = this._min;
        }
        if (value > this._max) {
            this._value = this._max;
        }
        this.onChange.emit(this._value);
        this.onChangeFn(this._value);
    }
    /**
     * @return {?}
     */
    setCls() {
        this.upDisableCls = {
            [`${this.prefixCls}-handler-up-disabled`]: this._upDisabled,
            [`${this.prefixCls}-handler-active`]: this._isUpClick
        };
        this.downDisableCls = {
            [`${this.prefixCls}-handler-down-disabled`]: this._downDisabled,
            [`${this.prefixCls}-handler-active`]: this._isDownClick
        };
    }
    /**
     * @return {?}
     */
    ngOnChanges() {
        if (this._disabled) {
            this._downDisabled = true;
            this._upDisabled = true;
        }
        else {
            this._upDisabled = this.plus(this._value, this._step) > this._max ? true : false;
            this._downDisabled = this.minus(this._value, this._step) < this._min ? true : false;
        }
        this.setCls();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        this._value = value;
        this.ngOnChanges();
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.onChangeFn = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.onTouchFn = fn;
    }
    /**
     * @param {?} num1
     * @param {?} num2
     * @return {?}
     */
    plus(num1, num2) {
        if (num1 === undefined || num1 === null || num2 === undefined || num2 === null) {
            return;
        }
        /** @type {?} */
        const baseNum = Math.pow(10, Math.max(this.digitLength(num1), this.digitLength(num2)));
        return (this.times(num1, baseNum) + this.times(num2, baseNum)) / baseNum;
    }
    /**
     * @param {?} num1
     * @param {?} num2
     * @return {?}
     */
    minus(num1, num2) {
        if (num1 === undefined || num1 === null || num2 === undefined || num2 === null) {
            return;
        }
        /** @type {?} */
        const baseNum = Math.pow(10, Math.max(this.digitLength(num1), this.digitLength(num2)));
        return (this.times(num1, baseNum) - this.times(num2, baseNum)) / baseNum;
    }
    /**
     * @param {?} num
     * @return {?}
     */
    digitLength(num) {
        /** @type {?} */
        const eSplit = num.toString().split(/[eE]/);
        /** @type {?} */
        const len = (eSplit[0].split('.')[1] || '').length - +(eSplit[1] || 0);
        return len > 0 ? len : 0;
    }
    /**
     * @param {?} num1
     * @param {?} num2
     * @return {?}
     */
    times(num1, num2) {
        /** @type {?} */
        const num1Changed = this.floatToFixed(num1);
        /** @type {?} */
        const num2Changed = this.floatToFixed(num2);
        /** @type {?} */
        const baseNum = this.digitLength(num1) + this.digitLength(num2);
        /** @type {?} */
        const leftValue = num1Changed * num2Changed;
        return leftValue / Math.pow(10, baseNum);
    }
    /**
     * @param {?} num
     * @return {?}
     */
    floatToFixed(num) {
        if (num.toString().indexOf('e') === -1) {
            return Number(num.toString().replace('.', ''));
        }
        /** @type {?} */
        const dLen = this.digitLength(num);
        return dLen > 0 ? this.strip(num * Math.pow(10, dLen)) : num;
    }
    /**
     * @param {?} num
     * @param {?=} precision
     * @return {?}
     */
    strip(num, precision = 12) {
        return +parseFloat(num.toPrecision(precision));
    }
}
StepperComponent.decorators = [
    { type: Component, args: [{
                selector: 'Stepper, nzm-stepper',
                template: "<div class=\"{{prefixCls}}-handler-wrap\">\n    <span role=\"button\"\n          class=\"{{prefixCls}}-handler {{prefixCls}}-handler-up\"\n          style=\"line-height:28px;\"\n          [ngClass]=\"upDisableCls\"\n          (click)=\"onIncrease()\">\n          <Icon [type]=\"'plus'\"\n                [size]=\"'xxs'\">\n          </Icon>\n    </span>\n    <span role=\"button\"\n          class=\"{{prefixCls}}-handler {{prefixCls}}-handler-down\"\n          style=\"line-height:28px;\"\n          [ngClass]=\"downDisableCls\"\n          (click)=\"onDecrease()\">\n          <Icon [type]=\"'minus'\"\n                [size]=\"'xxs'\">\n          </Icon>\n    </span>\n</div>\n<div class=\"{{prefixCls}}-input-wrap\">\n    <input class=\"{{prefixCls}}-input\"\n           style=\"outline:none\"\n           [disabled]=\"disabled\"\n           [readonly]=\"readOnly\"\n           [autocomplete]=\"'off'\"\n           [max]=\"max\"\n           [min]=\"min\"\n           [(ngModel)]=\"value\"\n           (change)=\"inputChange($event)\">\n</div>",
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => StepperComponent)),
                        multi: true
                    }
                ]
            }] }
];
/** @nocollapse */
StepperComponent.ctorParameters = () => [];
StepperComponent.propDecorators = {
    max: [{ type: Input }],
    min: [{ type: Input }],
    value: [{ type: Input }],
    step: [{ type: Input }],
    defaultValue: [{ type: Input }],
    disabled: [{ type: Input }],
    readOnly: [{ type: Input }],
    showNumber: [{ type: Input }],
    onChange: [{ type: Output }],
    clsStepper: [{ type: HostBinding, args: ['class.am-stepper',] }],
    clsStpDisabled: [{ type: HostBinding, args: ['class.am-stepper-disabled',] }],
    clsShowNum: [{ type: HostBinding, args: ['class.showNumber',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class StepperModule {
}
StepperModule.decorators = [
    { type: NgModule, args: [{
                exports: [StepperComponent],
                declarations: [StepperComponent],
                imports: [CommonModule, FormsModule, IconModule]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class StepComponent {
    /**
     * @param {?} _el
     */
    constructor(_el) {
        this._el = _el;
        this.prefixCls = 'am-steps';
        this.stepItemCls = {};
        this.isIconString = true;
        this.clsStepItem = true;
    }
    /**
     * @return {?}
     */
    get status() {
        return this._status;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set status(value) {
        if (value) {
            this._status = value;
            this.setClass();
        }
    }
    /**
     * @return {?}
     */
    get title() {
        return this._title;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set title(value) {
        this._title = value;
    }
    /**
     * @return {?}
     */
    get description() {
        return this._description;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set description(value) {
        this._description = value;
    }
    /**
     * @return {?}
     */
    get icon() {
        return this._icon;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set icon(value) {
        if (value) {
            if (typeof value !== 'string') {
                this.isIconString = false;
            }
            this._icon = value;
            this.setClass();
        }
    }
    /**
     * @return {?}
     */
    setClass() {
        this.iconCls = {
            [`${this.prefixCls}-icon`]: true
        };
        this.stepItemCls = Object.assign(this.stepItemCls, {
            [`${this.prefixCls}-item-${this.status}`]: true,
            [`${this.prefixCls}-item-custom`]: this.icon
        });
    }
    /**
     * @return {?}
     */
    ngOnInit() { }
}
StepComponent.decorators = [
    { type: Component, args: [{
                selector: 'Step, nzm-step',
                template: "<div [ngClass]=\"stepItemCls\">\n  <div class=\"{{prefixCls}}-item-tail\">\n    {{tailContent}}\n  </div>\n  <div class=\"{{prefixCls}}-item-icon\">\n    <span *ngIf=\"!isIconString\" [ngClass]=\"iconCls\">\n      <ng-template [ngTemplateOutlet]=\"icon\"></ng-template>\n    </span>\n    <span *ngIf=\"isIconString && (status=== 'error' || status==='finish' || status==='wait' )\" [ngClass]=\"iconCls\">\n      <Icon [type]=\"icon\" [size]=\"iconSize\">\n      </Icon>\n    </span>\n    <span *ngIf=\"isIconString && !(status=== 'error' || status==='finish' || status==='wait')\" [ngClass]=\"iconCls\">{{stepNumber}}\n    </span>\n  </div>\n  <div class=\"{{prefixCls}}-item-content\">\n    <div class=\"{{prefixCls}}-item-title\">\n      {{title}}\n    </div>\n    <div *ngIf=\"description\" class=\"{{prefixCls}}-item-description\">{{description}}</div>\n  </div>\n</div>\n",
                encapsulation: ViewEncapsulation.None,
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => StepComponent)),
                        multi: true
                    }
                ]
            }] }
];
/** @nocollapse */
StepComponent.ctorParameters = () => [
    { type: ElementRef }
];
StepComponent.propDecorators = {
    status: [{ type: Input }],
    title: [{ type: Input }],
    description: [{ type: Input }],
    icon: [{ type: Input }],
    clsStepItem: [{ type: HostBinding, args: ['class.am-steps-item',] }]
};
/** @enum {string} */
const StepStatusEnum = {
    WAIT: 'wait',
    PROCESS: 'process',
    FINISH: 'finish',
    ERROR: 'error',
};
/** @enum {string} */
const StepDirectionEnum = {
    VERTICAL: 'vertical',
    HORIZONTAL: 'horizontal',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class StepsComponent {
    /**
     * @param {?} _elf
     * @param {?} _render
     */
    constructor(_elf, _render) {
        this._elf = _elf;
        this._render = _render;
        this.prefixCls = 'am-steps';
        this._current = 0;
        this._status = StepStatusEnum.PROCESS;
        this._direction = StepDirectionEnum.VERTICAL;
        this.clsSteps = true;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set current(value) {
        if (value >= 0) {
            this._current = value;
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set size(value) {
        this._size = value;
        this.setCls();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set status(value) {
        this._status = value;
        if (this.stepItems) {
            this.setStepStyle();
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set direction(value) {
        this._direction = value;
        this.setCls();
    }
    /**
     * @return {?}
     */
    setStepStyle() {
        /** @type {?} */
        const itemCount = this.stepItems.length;
        /** @type {?} */
        const itemArr = this.stepItems['_results'];
        for (let index = 0; index < itemCount; index++) {
            /** @type {?} */
            const step = itemArr[index];
            step.stepNumber = index + 1;
            if (index < itemCount - 1 && itemArr[index + 1].status === StepStatusEnum.ERROR) {
                step.stepItemCls = step.stepItemCls
                    ? Object.assign(step.stepItemCls, { 'error-tail': true })
                    : { 'error-tail': true };
            }
            /** @type {?} */
            let icon = step.icon;
            if (!step.status) {
                if (index === this._current) {
                    step.status = this._status;
                }
                else if (index < this._current) {
                    step.status = StepStatusEnum.FINISH;
                }
                else {
                    step.status = StepStatusEnum.WAIT;
                }
            }
            if (!icon) {
                if (index < this._current) {
                    icon = 'check-circle-o';
                }
                else if (index > this._current) {
                    icon = 'ellipsis';
                    step.stepItemCls = step.stepItemCls
                        ? Object.assign(step.stepItemCls, { 'ellipsis-item': true })
                        : { 'ellipsis-item': true };
                }
                if ((this._status === StepStatusEnum.ERROR && index === this._current) || step.status === StepStatusEnum.ERROR) {
                    icon = 'cross-circle-o';
                }
            }
            step.icon = icon;
            step.iconSize = this._size === 'small' ? (this._status === StepStatusEnum.WAIT ? 'xxs' : 'xs') : 'md';
            step.setClass();
        }
    }
    /**
     * @return {?}
     */
    setCls() {
        if (this._direction === StepDirectionEnum.HORIZONTAL) {
            this.clsStepsLabelVtl = true;
            this.clsStepsHztl = true;
            this.clsStepsVtl = false;
        }
        else if (this._direction === StepDirectionEnum.VERTICAL) {
            this.clsStepsVtl = true;
            this.clsStepsHztl = false;
        }
        if (this._size === 'small') {
            this.clsStepsSmall = true;
        }
        else {
            this.clsStepsSmall = false;
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.setCls();
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        setTimeout((/**
         * @return {?}
         */
        () => {
            this.setStepStyle();
        }), 0);
    }
}
StepsComponent.decorators = [
    { type: Component, args: [{
                selector: 'Steps,nzm-steps',
                template: "<ng-content></ng-content>"
            }] }
];
/** @nocollapse */
StepsComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
StepsComponent.propDecorators = {
    stepItems: [{ type: ContentChildren, args: [StepComponent,] }],
    current: [{ type: Input }],
    size: [{ type: Input }],
    status: [{ type: Input }],
    direction: [{ type: Input }],
    clsSteps: [{ type: HostBinding, args: ['class.am-steps',] }],
    clsStepsSmall: [{ type: HostBinding, args: ['class.am-steps-small',] }],
    clsStepsLabelVtl: [{ type: HostBinding, args: ['class.am-steps-label-vertical',] }],
    clsStepsVtl: [{ type: HostBinding, args: ['class.am-steps-vertical',] }],
    clsStepsHztl: [{ type: HostBinding, args: ['class.am-steps-horizontal',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class StepsModule {
}
StepsModule.decorators = [
    { type: NgModule, args: [{
                exports: [StepsComponent, StepComponent],
                declarations: [StepsComponent, StepComponent],
                imports: [CommonModule, FormsModule, IconModule]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CarouselSlideComponent {
    constructor() {
        this.container = true;
        this.height = 'auto';
        this.overflow = 'hidden';
    }
}
CarouselSlideComponent.decorators = [
    { type: Component, args: [{
                selector: 'CarouselSlide, nzm-carousel-slide',
                template: "<ng-content></ng-content>\n",
                encapsulation: ViewEncapsulation.None
            }] }
];
CarouselSlideComponent.propDecorators = {
    container: [{ type: HostBinding, args: ['class.carousel-container',] }],
    width: [{ type: HostBinding, args: ['style.width.px',] }],
    height: [{ type: HostBinding, args: ['style.height',] }],
    left: [{ type: HostBinding, args: ['style.left.px',] }],
    top: [{ type: HostBinding, args: ['style.top.px',] }],
    margin: [{ type: HostBinding, args: ['style.margin',] }],
    overflow: [{ type: HostBinding, args: ['style.overflow',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} event
 * @return {?}
 */
function getEventTarget(event) {
    if (event.type === 'mousedown' || event.type === 'mousemove' || event.type === 'mouseup' || event.type === 'mouseleave') {
        return event;
    }
    else {
        if (event && event.changedTouches && event.changedTouches[0]) {
            return event.changedTouches[0];
        }
        return null;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CarouselComponent {
    /**
     * @param {?} _ele
     */
    constructor(_ele) {
        this._ele = _ele;
        this.style = {
            height: 'auto',
            width: '100%',
            transform: 'translate3d(0px, 0px, 0px)',
            margin: ''
        };
        this._nodeArr = [];
        this._lastIndex = 0;
        this._isMouseDown = false;
        this._rationWidth = 0;
        this._currentSlideWidth = 0;
        this._currentSlideHeight = 0;
        this._transition = '';
        this._spaceWidth = 0;
        this._dragging = true;
        this._currentSelectedIndex = 0;
        this._selectedIndex = 0;
        this.speed = 500;
        this.dots = true;
        this.vertical = false;
        this.autoplay = false;
        this.autoplayInterval = 3000;
        this.infinite = false;
        this.dotStyle = {};
        this.dotActiveStyle = {};
        this.frameOverflow = 'hidden';
        this.cellSpacing = 0;
        this.slideWidth = 1;
        this.swipeSpeed = 12;
        this.dragging = true;
        this.afterChange = new EventEmitter();
        this.beforeChange = new EventEmitter();
        this.carouselWrapper = true;
        this.carouselwrap = true;
    }
    /**
     * @return {?}
     */
    get selectedIndex() {
        return this._selectedIndex;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set selectedIndex(value) {
        this._selectedIndex = Math.abs(value);
        if (this._nodeArr.length > 0) {
            this.carousel(1);
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    panstart(event) {
        event.stopPropagation();
        if (!this._dragging) {
            return;
        }
        this.stopTimer();
        this._isMouseDown = true;
        this.touchObject = {
            startX: getEventTarget(event).pageX,
            startY: getEventTarget(event).pageY,
            direction: this.touchObject.direction
        };
    }
    /**
     * @param {?} event
     * @return {?}
     */
    panmove(event) {
        event.stopPropagation();
        if (!this._dragging || !this._isMouseDown) {
            return;
        }
        const { direction } = this.swipeDirection(this.touchObject.startX, getEventTarget(event).pageX, this.touchObject.startY, getEventTarget(event).pageY);
        /** @type {?} */
        const length = this.vertical
            ? Math.abs(getEventTarget(event).pageY - this.touchObject.startY)
            : Math.abs(getEventTarget(event).pageX - this.touchObject.startX);
        /** @type {?} */
        const offset = -this.touchObject.direction * length - this._currentSelectedIndex * this._rationWidth;
        this.touchObject = {
            startX: this.touchObject.startX,
            startY: this.touchObject.startY,
            endX: getEventTarget(event).pageX,
            endY: getEventTarget(event).pageY,
            length,
            direction,
            offset
        };
        if (direction !== 0) {
            this.setSlideStyles(this._currentSelectedIndex, this.touchObject.direction);
        }
        this.getListStyles(offset);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    panend(event) {
        event.stopPropagation();
        if (!this._dragging || !this._isMouseDown || !this.touchObject.length || this.touchObject.length === undefined) {
            this._isMouseDown = false;
            return;
        }
        this._isMouseDown = false;
        if (this.touchObject.length > this.swipeSpeed) {
            this.carousel(this.touchObject.direction);
        }
        else {
            this.getListStyles(this.touchObject.direction * this.touchObject.length + this.touchObject.offset);
            this.style['transition'] = this._transition;
        }
        setTimeout((/**
         * @return {?}
         */
        () => {
            this.startTimer();
        }), this.speed);
    }
    /**
     * @return {?}
     */
    cancel() {
        setTimeout((/**
         * @return {?}
         */
        () => {
            this.startTimer();
        }), this.speed);
    }
    /**
     * @return {?}
     */
    resize() {
        if (this._resizeTimer) {
            clearTimeout(this._resizeTimer);
        }
        this._resizeTimer = setTimeout((/**
         * @return {?}
         */
        () => {
            this.ngAfterViewInit();
            clearTimeout(this._resizeTimer);
        }), 200);
    }
    /**
     * @return {?}
     */
    initCarouselSize() {
        /** @type {?} */
        const nativeElement = this._ele.nativeElement;
        this.slideHeight = nativeElement.querySelector('carouselslide').clientHeight;
        this._currentSlideHeight = this.slideHeight * this.slideWidth;
        this._currentSlideWidth = nativeElement.clientWidth;
        this._rationWidth = this.vertical ? this._currentSlideHeight : this._currentSlideWidth * this.slideWidth;
        this._spaceWidth = ((this.vertical ? this.slideHeight : this._currentSlideWidth) - this._rationWidth) / 2;
    }
    /**
     * @param {?} items
     * @return {?}
     */
    carouselInit(items) {
        this.infinite = this.infinite || true;
        this._nodeArr = items['_results'];
        /** @type {?} */
        const shouldDragging = this._nodeArr.length > 1;
        this._dragging = (this.dragging && shouldDragging) ? true : false;
        if (this._nodeArr.length > 1) {
            this._lastIndex = this._nodeArr.length - 1;
            setTimeout((/**
             * @return {?}
             */
            () => {
                this._nodeArr.forEach((/**
                 * @param {?} v
                 * @param {?} index
                 * @return {?}
                 */
                (v, index) => {
                    v.width = this.vertical ? 'auto' : this._rationWidth - this.cellSpacing;
                    v.left = this.vertical ? 0 : index === this._lastIndex ? -this._rationWidth : index * this._rationWidth;
                    v.top = this.vertical ? (index === this._lastIndex ? -this._rationWidth : index * this._rationWidth) : 0;
                    v.margin = this.vertical ? `${this.cellSpacing / 2}px auto` : `auto ${this.cellSpacing / 2}px`;
                }));
                this.startTimer();
            }), 0);
        }
        else if (this._nodeArr.length === 1) {
            setTimeout((/**
             * @return {?}
             */
            () => {
                this._nodeArr.forEach((/**
                 * @param {?} v
                 * @return {?}
                 */
                (v) => {
                    v.width = this.vertical ? 'auto' : this._rationWidth - this.cellSpacing;
                    v.left = 0;
                    v.top = 0;
                    v.margin = `auto ${this.cellSpacing / 2}px`;
                }));
            }), 0);
        }
    }
    /**
     * @return {?}
     */
    startTimer() {
        if (!this.autoplay) {
            return;
        }
        this.stopTimer();
        this._timer = this.autoplayInterval
            ? setInterval((/**
             * @return {?}
             */
            () => {
                if (document.getElementsByTagName('carousel').length === 0) {
                    return;
                }
                this.carousel(1);
            }), this.autoplayInterval)
            : 0;
    }
    /**
     * @return {?}
     */
    stopTimer() {
        clearInterval(this._timer);
    }
    /**
     * @param {?} moveDirection
     * @return {?}
     */
    carousel(moveDirection) {
        if (this.vertical) {
            if (moveDirection === 1) {
                this.moveUp();
            }
            else if (moveDirection === -1) {
                this.moveDown();
            }
        }
        else {
            if (moveDirection === 1) {
                this.moveLeft();
            }
            else if (moveDirection === -1) {
                this.moveRight();
            }
        }
        this.style['transition'] = this._transition;
    }
    /**
     * @return {?}
     */
    moveUp() {
        this.gotoCarousel(this.getAfterNode(false));
    }
    /**
     * @return {?}
     */
    moveDown() {
        this.gotoCarousel(this.getAfterNode(true));
    }
    /**
     * @return {?}
     */
    moveLeft() {
        this.gotoCarousel(this.getAfterNode(false));
    }
    /**
     * @return {?}
     */
    moveRight() {
        this.gotoCarousel(this.getAfterNode(true));
    }
    /**
     * @param {?} pre
     * @return {?}
     */
    getAfterNode(pre) {
        /** @type {?} */
        let nextIndex;
        if (pre) {
            if (this._currentSelectedIndex <= 0) {
                this.getListStyles(this._rationWidth);
                setTimeout((/**
                 * @return {?}
                 */
                () => {
                    this._nodeArr.forEach((/**
                     * @param {?} v
                     * @param {?} tempIndex
                     * @return {?}
                     */
                    (v, tempIndex) => {
                        if (tempIndex === 0) {
                            v.left = this.vertical ? 0 : this._nodeArr.length * this._rationWidth;
                            v.top = this.vertical ? this._nodeArr.length * this._rationWidth : 0;
                        }
                        else {
                            v.left = this.vertical ? 0 : tempIndex * this._rationWidth;
                            v.top = this.vertical ? tempIndex * this._rationWidth : 0;
                        }
                    }));
                    this.getListStyles(-this._rationWidth * (this.items.length - 1));
                }), this.speed);
                nextIndex = !this.infinite ? null : this._lastIndex;
                this.beforeChange.emit({ from: this._currentSelectedIndex, to: nextIndex });
                return nextIndex;
            }
            nextIndex = this._currentSelectedIndex - 1;
            this.getListStyles(nextIndex * this._rationWidth * this.touchObject.direction);
            this._nodeArr.forEach((/**
             * @param {?} v
             * @param {?} tempIndex
             * @return {?}
             */
            (v, tempIndex) => {
                if (0 === tempIndex && nextIndex === this._nodeArr.length - 2) {
                    v.left = 0;
                    v.top = 0;
                }
            }));
            this.beforeChange.emit({ from: this._currentSelectedIndex, to: nextIndex });
            return nextIndex;
        }
        else {
            if (this._currentSelectedIndex >= this._lastIndex) {
                this.setSlideStyles(this._currentSelectedIndex, 1);
                this.getListStyles(-(this._lastIndex + 1) * this._rationWidth);
                nextIndex = !this.infinite ? null : 0;
                this.beforeChange.emit({ from: this._currentSelectedIndex, to: nextIndex });
                return nextIndex;
            }
            nextIndex = this._currentSelectedIndex + 1;
            this.setSlideStyles(this._currentSelectedIndex, 1);
            this.getListStyles(-nextIndex * this._rationWidth);
            this.beforeChange.emit({ from: this._currentSelectedIndex, to: nextIndex });
            return nextIndex;
        }
    }
    /**
     * @return {?}
     */
    caculateDirectionLeftCurrentIndex() {
        /** @type {?} */
        const previousIndex = this._currentSelectedIndex;
        this._currentSelectedIndex = (previousIndex + 1) % this.items.length;
    }
    /**
     * @return {?}
     */
    caculateDirectionRightCurrentIndex() {
        if (this._currentSelectedIndex === 0) {
            this._currentSelectedIndex = this.items.length;
        }
        /** @type {?} */
        const previousIndex = this._currentSelectedIndex;
        this._currentSelectedIndex = (previousIndex - 1) % this.items.length;
    }
    /**
     * @param {?} afterIndex
     * @return {?}
     */
    gotoCarousel(afterIndex) {
        if (afterIndex === null) {
            return;
        }
        this.getCurrentIndex();
        if (afterIndex === 0) {
            setTimeout((/**
             * @return {?}
             */
            () => {
                this._nodeArr.forEach((/**
                 * @param {?} v
                 * @param {?} index
                 * @return {?}
                 */
                (v, index) => {
                    if (index === this._nodeArr.length - 1) {
                        v.left = this.vertical ? 0 : -this._rationWidth;
                        v.top = this.vertical ? -this._rationWidth : 0;
                    }
                    else {
                        v.left = this.vertical ? 0 : index * this._rationWidth;
                        v.top = this.vertical ? index * this._rationWidth : 0;
                    }
                }));
                this.startTimer();
                this.getListStyles(0);
            }), this.speed);
        }
        this._currentSelectedIndex = afterIndex;
        this.afterChange.emit(this._currentSelectedIndex);
    }
    /**
     * @return {?}
     */
    getCurrentIndex() {
        if (this.touchObject.direction === 1) {
            this.caculateDirectionLeftCurrentIndex();
        }
        else {
            this.caculateDirectionRightCurrentIndex();
        }
    }
    /**
     * @param {?} index
     * @param {?} direction
     * @param {?=} xDist
     * @return {?}
     */
    setSlideStyles(index, direction, xDist = 0) {
        if (direction === 1) {
            this._nodeArr.forEach((/**
             * @param {?} v
             * @param {?} tempIndex
             * @return {?}
             */
            (v, tempIndex) => {
                if (index < this._nodeArr.length && index - 1 === tempIndex) {
                    if (xDist === 0 || xDist > this._spaceWidth) {
                        v.left = this.vertical ? 0 : (this._nodeArr.length + tempIndex) * this._rationWidth;
                        v.top = this.vertical ? (this._nodeArr.length + tempIndex) * this._rationWidth : 0;
                    }
                }
                else if (this._nodeArr.length - 1 === tempIndex && index !== 2) {
                    if (xDist === 0 || xDist > this._spaceWidth) {
                        v.left = this.vertical ? 0 : (this._nodeArr.length - 1) * this._rationWidth;
                        v.top = this.vertical ? (this._nodeArr.length - 1) * this._rationWidth : 0;
                    }
                }
                else if (index === this._nodeArr.length - 1 && tempIndex === 1 && this.autoplay) {
                    v.left = this.vertical ? 0 : (this._nodeArr.length + tempIndex) * this._rationWidth;
                    v.top = this.vertical ? tempIndex * this._rationWidth : 0;
                }
                else if (index === this._nodeArr.length - 1 && tempIndex === 0 && !this.autoplay) {
                    v.left = this.vertical ? 0 : (this._nodeArr.length + tempIndex) * this._rationWidth;
                    v.top = this.vertical ? tempIndex * this._rationWidth : 0;
                }
            }));
        }
        else if (direction === -1) {
            this._nodeArr.forEach((/**
             * @param {?} v
             * @param {?} tempIndex
             * @return {?}
             */
            (v, tempIndex) => {
                if (index === 0 && this._nodeArr.length - 1 === tempIndex) {
                    v.left = this.vertical ? 0 : direction * this._rationWidth;
                    v.top = this.vertical ? direction * this._rationWidth : 0;
                }
                else if (index === this._nodeArr.length - 2 && index + 1 === tempIndex) {
                    v.left = this.vertical ? 0 : direction * this._rationWidth;
                    v.top = this.vertical ? direction * this._rationWidth : 0;
                }
                else if (index === 1 && 0 === tempIndex) {
                    v.left = this.vertical ? 0 : direction * this._rationWidth * tempIndex;
                    v.top = this.vertical ? direction * this._rationWidth : 0;
                }
                else if (index > 1) {
                    v.left = this.vertical ? 0 : tempIndex * this._rationWidth;
                    v.top = this.vertical ? tempIndex * this._rationWidth : 0;
                }
            }));
        }
    }
    /**
     * @param {?=} offset
     * @return {?}
     */
    getListStyles(offset = 0) {
        /** @type {?} */
        const positionOffset = offset +
            (this.vertical
                ? (this.slideHeight - this._currentSlideHeight) / 2
                : (this._currentSlideWidth - this._rationWidth) / 2) -
            this.cellSpacing;
        this.style = {
            height: this._currentSlideHeight + 'px',
            width: this.vertical ? this._currentSlideWidth + 'px' : this.items.length * this._rationWidth + 'px',
            transform: this.vertical
                ? `translate3d(0px, ${positionOffset}px, 0px)`
                : `translate3d(${positionOffset}px, 0px, 0px)`,
            margin: this.vertical ? `${(this.cellSpacing / 2) * -1}px 0px` : `0px ${(this.cellSpacing / 2) * -1}px`
        };
    }
    /**
     * @param {?} x1
     * @param {?} x2
     * @param {?} y1
     * @param {?} y2
     * @return {?}
     */
    swipeDirection(x1, x2, y1, y2) {
        /** @type {?} */
        const xDist = x1 - x2;
        /** @type {?} */
        const yDist = y1 - y2;
        /** @type {?} */
        const r = Math.atan2(yDist, xDist);
        /** @type {?} */
        let swipeAngle = Math.round((r * 180) / Math.PI);
        if (swipeAngle < 0) {
            swipeAngle = 360 - Math.abs(swipeAngle);
        }
        if (swipeAngle <= 45 && swipeAngle >= 0) {
            return {
                direction: 1,
                xDist: xDist
            };
        }
        if (swipeAngle <= 360 && swipeAngle >= 315) {
            return {
                direction: 1,
                xDist: xDist
            };
        }
        if (swipeAngle >= 135 && swipeAngle <= 225) {
            return {
                direction: -1,
                xDist: xDist
            };
        }
        if (this.vertical === true) {
            if (swipeAngle >= 35 + 33 && swipeAngle <= 135) {
                return {
                    direction: 1,
                    xDist: xDist
                };
            }
            else {
                return {
                    direction: -1,
                    xDist: xDist
                };
            }
        }
        return {
            direction: 0,
            xDist: xDist
        };
    }
    /**
     * @return {?}
     */
    get page() {
        return this.dots ? this._currentSelectedIndex : 0;
    }
    /**
     * @return {?}
     */
    get pageCount() {
        return this.dots ? this.items.length : 0;
    }
    /**
     * @return {?}
     */
    get dotindicatorStatus() {
        return this.dots ? (this.items.length > 1) : this.dots;
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.touchObject = { direction: 1 };
        this._transition = `transform ${this.speed / 1000}s`;
        this.items.changes.subscribe((/**
         * @param {?} items
         * @return {?}
         */
        items => {
            this.carouselInit(items);
        }));
        this.initCarouselSize();
        this.selectedIndex = this.items.length - 1 < this.selectedIndex ? 0 : this.selectedIndex;
        /** @type {?} */
        const index = this.items.length > 1 ? ((this.items.length - 1) === this.selectedIndex ? -1 : this.selectedIndex) : 0;
        setTimeout((/**
         * @return {?}
         */
        () => {
            this._currentSelectedIndex = this.selectedIndex;
        }), 0);
        this.getListStyles(-index * this._rationWidth);
        this.carouselInit(this.items);
        /** @type {?} */
        const nativeElement = this._ele.nativeElement;
        /** @type {?} */
        const targetNode = nativeElement.querySelector('carouselslide');
        /** @type {?} */
        const config = { attributes: true, childList: true, subtree: true };
        /** @type {?} */
        const callback = (/**
         * @param {?} mutationsList
         * @return {?}
         */
        (mutationsList) => {
            for (const mutation of mutationsList) {
                if (mutation.type == 'attributes') {
                    if (this.slideHeight !== nativeElement.querySelector('carouselslide').clientHeight) {
                        this.initCarouselSize();
                        this.getListStyles(-index * this._rationWidth);
                        this.carouselInit(this.items);
                    }
                }
            }
        });
        this._observer = new MutationObserver(callback);
        this._observer.observe(targetNode, config);
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._observer.disconnect();
        this._observer = null;
        this.stopTimer();
    }
}
CarouselComponent.decorators = [
    { type: Component, args: [{
                selector: 'Carousel, nzm-carousel',
                encapsulation: ViewEncapsulation.None,
                template: "<div class=\"slider-frame\" [ngStyle]=\"{overflow: frameOverflow}\">\n  <ul class=\"slider-list\" [ngStyle]=\"style\">\n    <ng-content></ng-content>\n  </ul>\n</div>\n<DotIndicator *ngIf=\"dotindicatorStatus\"\n              class=\"am-carousel-wrap-dot\"\n              [page]=\"page\"\n              [dotStyle]=\"dotStyle\"\n              [pageCount]=\"pageCount\"\n              [dotActiveStyle]=\"dotActiveStyle\"\n></DotIndicator>\n"
            }] }
];
/** @nocollapse */
CarouselComponent.ctorParameters = () => [
    { type: ElementRef }
];
CarouselComponent.propDecorators = {
    items: [{ type: ContentChildren, args: [CarouselSlideComponent,] }],
    speed: [{ type: Input }],
    dots: [{ type: Input }],
    vertical: [{ type: Input }],
    autoplay: [{ type: Input }],
    autoplayInterval: [{ type: Input }],
    infinite: [{ type: Input }],
    dotStyle: [{ type: Input }],
    dotActiveStyle: [{ type: Input }],
    frameOverflow: [{ type: Input }],
    cellSpacing: [{ type: Input }],
    slideWidth: [{ type: Input }],
    swipeSpeed: [{ type: Input }],
    dragging: [{ type: Input }],
    selectedIndex: [{ type: Input }],
    afterChange: [{ type: Output }],
    beforeChange: [{ type: Output }],
    carouselWrapper: [{ type: HostBinding, args: ['class.am-carousel',] }],
    carouselwrap: [{ type: HostBinding, args: ['class.carousel',] }],
    panstart: [{ type: HostListener, args: ['mousedown', ['$event'],] }, { type: HostListener, args: ['touchstart', ['$event'],] }],
    panmove: [{ type: HostListener, args: ['mousemove', ['$event'],] }, { type: HostListener, args: ['touchmove', ['$event'],] }],
    panend: [{ type: HostListener, args: ['mouseleave', ['$event'],] }, { type: HostListener, args: ['mouseup', ['$event'],] }, { type: HostListener, args: ['touchend', ['$event'],] }],
    cancel: [{ type: HostListener, args: ['touchcancel',] }],
    resize: [{ type: HostListener, args: ['window:resize',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DotIndicatorComponent {
    constructor() {
        this.items = [];
        this._page = 0;
        this._pageCount = 0;
        this.dotStyle = {};
        this.dotActiveStyle = {};
        this.dotColor = 'white';
        this.dotIndicator = true;
    }
    /**
     * @param {?} p
     * @return {?}
     */
    set page(p) {
        this._page = p;
        this.updateSelected();
    }
    /**
     * @param {?} p
     * @return {?}
     */
    set pageCount(p) {
        this._pageCount = p || 0;
        this.updateItems();
    }
    /**
     * @private
     * @return {?}
     */
    updateItems() {
        this.items = new Array(this._pageCount);
        for (let i = 0; i < this._pageCount; i++) {
            this.items[i] = { active: i == this._page };
        }
    }
    /**
     * @private
     * @return {?}
     */
    updateSelected() {
        if (this.items.length != this._pageCount) {
            return this.updateItems();
        }
        if (this.items.length == 0) {
            return;
        }
        for (let i = 0; i < this._pageCount; i++) {
            this.items[i].active = false;
        }
        this.items[this._page].active = true;
    }
}
DotIndicatorComponent.decorators = [
    { type: Component, args: [{
                selector: 'DotIndicator, nzm-dot-indicator',
                template: "<div class=\"am-carousel-wrap\">\n  <div *ngFor=\"let item of items\"\n       class=\"am-carousel-wrap-dot\"\n       [class.am-carousel-wrap-dot-active]=\"item.active\"\n  >\n    <span [ngStyle]=\"item.active ? dotActiveStyle : dotStyle\"></span>\n  </div>\n</div>",
                encapsulation: ViewEncapsulation.None
            }] }
];
DotIndicatorComponent.propDecorators = {
    page: [{ type: Input }],
    pageCount: [{ type: Input }],
    dotStyle: [{ type: Input }],
    dotActiveStyle: [{ type: Input }],
    dotColor: [{ type: Input }],
    dotIndicator: [{ type: HostBinding, args: ['class.dot-indicator',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CarouselModule {
}
CarouselModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                declarations: [CarouselComponent, CarouselSlideComponent, DotIndicatorComponent],
                exports: [CarouselComponent, CarouselSlideComponent, DotIndicatorComponent]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CheckboxComponent {
    constructor() {
        this.prefixCls = 'am-checkbox';
        this.classMap = {
            [this.prefixCls]: true,
            [`${this.prefixCls}-checked`]: false,
            [`${this.prefixCls}-disabled`]: false
        };
        this._checked = false;
        this._disabled = false;
        this.onChange = new EventEmitter();
        this.checkBoxWrapper = true;
    }
    /**
     * @return {?}
     */
    get checked() {
        return this._checked;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set checked(value) {
        if (!this._disabled) {
            this._checked = value;
            this.updateClassMap();
        }
    }
    /**
     * @return {?}
     */
    get disabled() {
        return this._disabled;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set disabled(value) {
        this._disabled = value;
        this.updateClassMap();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onClick(event) {
        event.preventDefault();
        if (!this._disabled) {
            this.updateValue(!this.checked);
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    updateValue(value) {
        this.checked = value;
        this.onChange.emit({
            name: this.name,
            value: this.value,
            checked: value
        });
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.updateClassMap();
    }
    /**
     * @private
     * @return {?}
     */
    updateClassMap() {
        this.classMap = {
            [this.prefixCls]: true,
            [`${this.prefixCls}-checked`]: this.checked,
            [`${this.prefixCls}-disabled`]: this.disabled
        };
    }
}
CheckboxComponent.decorators = [
    { type: Component, args: [{
                selector: '[Checkbox], [nzm-checkbox]',
                template: "<span [ngClass]=\"classMap\">\n  <input type=\"checkbox\"\n         class=\"{{prefixCls}}-input\"\n         [attr.name]=\"name\"\n         [attr.value]=\"value\"\n         [checked]=\"checked\"\n         [disabled]=\"disabled\"\n  >\n  <span class=\"{{prefixCls}}-inner\"></span>\n</span>\n<ng-content></ng-content>\n",
                preserveWhitespaces: false,
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush
            }] }
];
/** @nocollapse */
CheckboxComponent.ctorParameters = () => [];
CheckboxComponent.propDecorators = {
    name: [{ type: Input }],
    value: [{ type: Input }],
    checked: [{ type: Input }],
    disabled: [{ type: Input }],
    onChange: [{ type: Output }],
    checkBoxWrapper: [{ type: HostBinding, args: ['class.am-checkbox-wrapper',] }],
    onClick: [{ type: HostListener, args: ['click', ['$event'],] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AgreeItemComponent {
    /**
     * @param {?} cdr
     */
    constructor(cdr) {
        this.cdr = cdr;
        this.prefixCls = 'am-checkbox';
        this.checked = false;
        this._disabled = false;
        this.onChange = new EventEmitter();
        this.checkboxAgree = true;
    }
    /**
     * @return {?}
     */
    get disabled() {
        return this._disabled;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set disabled(value) {
        this._disabled = value;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    change(event) {
        this.checked = event.checked;
        this._ngModelOnChange(event.checked);
        this.onChange.emit(event);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        this.checked = value;
        this.cdr.markForCheck();
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this._ngModelOnChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this._ngModelOnTouched = fn;
    }
}
AgreeItemComponent.decorators = [
    { type: Component, args: [{
                selector: 'AgreeItem, nzm-agree-item',
                template: "<label Checkbox\n       class=\"{{prefixCls}}-agree-label\"\n       [name]=\"name\"\n       [value]=\"value\"\n       [checked]=\"checked\"\n       [disabled]=\"disabled\"\n       (onChange)=\"change($event)\"\n>\n  <ng-content></ng-content>\n</label>",
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush,
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => AgreeItemComponent)),
                        multi: true
                    }
                ]
            }] }
];
/** @nocollapse */
AgreeItemComponent.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
AgreeItemComponent.propDecorators = {
    name: [{ type: Input }],
    value: [{ type: Input }],
    disabled: [{ type: Input }],
    onChange: [{ type: Output }],
    checkboxAgree: [{ type: HostBinding, args: ['class.am-checkbox-agree',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CheckboxItemComponent {
    /**
     * @param {?} cdr
     */
    constructor(cdr) {
        this.cdr = cdr;
        this.prefixCls = 'am-checkbox';
        this.checked = false;
        this._disabled = false;
        this.wrap = false;
        this.error = false;
        this.multipleLine = false;
        this.platform = 'ios';
        this.align = 'middle';
        this.onChange = new EventEmitter();
    }
    /**
     * @return {?}
     */
    get disabled() {
        return this._disabled;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set disabled(value) {
        this._disabled = value;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onCheckboxClick(event) { }
    /**
     * @param {?} event
     * @return {?}
     */
    change(event) {
        this.checked = event.checked;
        this._ngModelOnChange(event.checked);
        this.onChange.emit(event);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        this.checked = value;
        this.cdr.markForCheck();
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this._ngModelOnChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this._ngModelOnTouched = fn;
    }
}
CheckboxItemComponent.decorators = [
    { type: Component, args: [{
                selector: 'CheckboxItem, nzm-checkbox-item',
                template: "<ListItem [className]=\"'am-checkbox-item ' + (disabled ? 'am-checkbox-item-disabled' : '')\"\n          [wrap]=\"wrap\"\n          [align]=\"align\"\n          [arrow]=\"arrow\"\n          [error]=\"error\"\n          [extra]=\"extra\"\n          [thumb]=\"checkbox\"\n          [disabled]=\"disabled\"\n          [platform]=\"platform\"\n          [multipleLine]=\"multipleLine\"\n          (onClick)=\"onCheckboxClick($event)\"\n>\n  <ng-content></ng-content>\n</ListItem>\n<ng-template #checkbox>\n  <label Checkbox\n         [name]=\"name\"\n         [value]=\"value\"\n         [checked]=\"checked\"\n         [disabled]=\"disabled\"\n         (onChange)=\"change($event)\"\n  >\n  </label>\n</ng-template>\n",
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush,
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => CheckboxItemComponent)),
                        multi: true
                    }
                ]
            }] }
];
/** @nocollapse */
CheckboxItemComponent.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
CheckboxItemComponent.propDecorators = {
    name: [{ type: Input }],
    value: [{ type: Input }],
    arrow: [{ type: Input }],
    extra: [{ type: Input }],
    wrap: [{ type: Input }],
    error: [{ type: Input }],
    multipleLine: [{ type: Input }],
    platform: [{ type: Input }],
    align: [{ type: Input }],
    disabled: [{ type: Input }],
    onChange: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CheckboxModule {
}
CheckboxModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, FormsModule, ListModule],
                declarations: [CheckboxComponent, CheckboxItemComponent, AgreeItemComponent],
                exports: [CheckboxComponent, CheckboxItemComponent, AgreeItemComponent]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class RadioComponent {
    constructor() {
        this.prefixCls = 'am-radio';
        this.classMap = {
            [this.prefixCls]: true,
            [`${this.prefixCls}-checked`]: this.checked,
            [`${this.prefixCls}-disabled`]: this.disabled
        };
        this._checked = false;
        this._disabled = false;
        this.onChange = new EventEmitter();
        this.radioWrapper = true;
    }
    /**
     * @return {?}
     */
    get checked() {
        return this._checked;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set checked(value) {
        this._checked = value;
        this.updateClassMap();
    }
    /**
     * @return {?}
     */
    get disabled() {
        return this._disabled;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set disabled(value) {
        this._disabled = value;
        this.updateClassMap();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onClick(event) {
        event.preventDefault();
        if (!this._disabled && !this._checked) {
            this.updateValue(true);
        }
    }
    /**
     * @param {?} checkValue
     * @return {?}
     */
    updateValue(checkValue) {
        this.checked = checkValue;
        this.onChange.emit({
            name: this.name,
            value: this.value
        });
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.updateClassMap();
    }
    /**
     * @private
     * @return {?}
     */
    updateClassMap() {
        this.classMap = {
            [this.prefixCls]: true,
            [`${this.prefixCls}-checked`]: this.checked,
            [`${this.prefixCls}-disabled`]: this.disabled
        };
    }
}
RadioComponent.decorators = [
    { type: Component, args: [{
                selector: '[Radio], [nzm-radio]',
                template: "<span [ngClass]=\"classMap\">\n  <input type=\"radio\"\n         class=\"{{prefixCls}}-input\"\n         [attr.name]=\"name\"\n         [attr.value]=\"value\"\n         [checked]=\"checked\"\n         [disabled]=\"disabled\"\n  >\n  <span class=\"{{prefixCls}}-inner\"></span>\n</span>\n<ng-content></ng-content>\n",
                preserveWhitespaces: false,
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush
            }] }
];
/** @nocollapse */
RadioComponent.ctorParameters = () => [];
RadioComponent.propDecorators = {
    name: [{ type: Input }],
    value: [{ type: Input }],
    checked: [{ type: Input }],
    disabled: [{ type: Input }],
    onChange: [{ type: Output }],
    radioWrapper: [{ type: HostBinding, args: ['class.am-radio-wrapper',] }],
    onClick: [{ type: HostListener, args: ['click', ['$event'],] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class RadioItemComponent {
    /**
     * @param {?} cdr
     */
    constructor(cdr) {
        this.cdr = cdr;
        this.select$ = new Subject();
        this.prefixCls = 'am-radio';
        this._checked = false;
        this._disabled = false;
        this.wrap = false;
        this.error = false;
        this.multipleLine = false;
        this.platform = 'ios';
        this.align = 'middle';
    }
    /**
     * @return {?}
     */
    get checked() {
        return this._checked;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set checked(value) {
        this._checked = value;
        this.cdr.markForCheck();
    }
    /**
     * @return {?}
     */
    get disabled() {
        return this._disabled;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set disabled(value) {
        this._disabled = value;
        this.cdr.markForCheck();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onRadioItemClick(event) { }
    /**
     * @param {?} event
     * @return {?}
     */
    change(event) {
        if (!this.disabled && !this.checked) {
            this.select$.next(this);
        }
    }
    /**
     * @return {?}
     */
    markForCheck() {
        this.cdr.markForCheck();
    }
}
RadioItemComponent.decorators = [
    { type: Component, args: [{
                selector: 'RadioItem, nzm-radio-item',
                template: "<ListItem [className]=\"'am-radio-item ' + (disabled ? 'am-radio-item-disabled' : '')\"\n          [wrap]=\"wrap\"\n          [align]=\"align\"\n          [arrow]=\"arrow\"\n          [error]=\"error\"\n          [extra]=\"radio\"\n          [thumb]=\"thumb\"\n          [disabled]=\"disabled\"\n          [platform]=\"platform\"\n          [multipleLine]=\"multipleLine\"\n          [disabled]=\"disabled\"\n          [wrap]=\"wrap\"\n          (onClick)=\"onRadioItemClick($event)\"\n>\n  <ng-content></ng-content>\n</ListItem>\n<ng-template #radio>\n  <label Radio\n         [name]=\"name\"\n         [value]=\"value\"\n         [checked]=\"checked\"\n         [disabled]=\"disabled\"\n         (onChange)=\"change($event)\"\n  ></label>\n</ng-template>\n",
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush
            }] }
];
/** @nocollapse */
RadioItemComponent.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
RadioItemComponent.propDecorators = {
    name: [{ type: Input }],
    value: [{ type: Input }],
    arrow: [{ type: Input }],
    thumb: [{ type: Input }],
    wrap: [{ type: Input }],
    error: [{ type: Input }],
    multipleLine: [{ type: Input }],
    platform: [{ type: Input }],
    align: [{ type: Input }],
    disabled: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const RADIO_ITEM_GROUP_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef((/**
     * @return {?}
     */
    () => RadioItemGroupComponent)),
    multi: true
};
class RadioItemGroupComponent {
    /**
     * @param {?} cdr
     */
    constructor(cdr) {
        this.cdr = cdr;
        this.destroy$ = new Subject();
        this.onChange = new EventEmitter();
    }
    /**
     * @return {?}
     */
    updateChildrenStatus() {
        if (this.radioItems && typeof (this.selectedValue) !== 'undefined' && null !== this.selectedValue) {
            Promise.resolve().then((/**
             * @return {?}
             */
            () => {
                this.radioItems.forEach((/**
                 * @param {?} radioItem
                 * @return {?}
                 */
                radioItem => {
                    radioItem.checked = radioItem.value === this.selectedValue;
                    radioItem.markForCheck();
                }));
            }));
        }
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.radioItems.changes
            .pipe(startWith(null), takeUntil(this.destroy$))
            .subscribe((/**
         * @return {?}
         */
        () => {
            this.updateChildrenStatus();
            if (this.selectSubscription) {
                this.selectSubscription.unsubscribe();
            }
            this.selectSubscription = merge(...this.radioItems.map((/**
             * @param {?} radioItem
             * @return {?}
             */
            radioItem => radioItem.select$)))
                .pipe(takeUntil(this.destroy$))
                .subscribe((/**
             * @param {?} radioItem
             * @return {?}
             */
            radioItem => {
                if (typeof (this.selectedValue) !== 'undefined' && null !== this.selectedValue) {
                    this.selectedValue = radioItem.value;
                    this._ngModelOnChange(radioItem.value);
                    this.updateChildrenStatus();
                    if (this.onChange) {
                        this.onChange.emit({ name: radioItem.name, value: radioItem.value });
                    }
                }
            }));
        }));
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.destroy$.next();
        this.destroy$.complete();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        if (typeof (value) !== 'undefined' && null !== value) {
            this.selectedValue = value;
            this.updateChildrenStatus();
            this.cdr.markForCheck();
        }
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this._ngModelOnChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this._ngModelOnTouched = fn;
    }
}
RadioItemGroupComponent.decorators = [
    { type: Component, args: [{
                selector: 'RadioItemGroup, nzm-radio-item-group',
                template: "<ng-content></ng-content>\n",
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush,
                providers: [RADIO_ITEM_GROUP_VALUE_ACCESSOR]
            }] }
];
/** @nocollapse */
RadioItemGroupComponent.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
RadioItemGroupComponent.propDecorators = {
    radioItems: [{ type: ContentChildren, args: [forwardRef((/**
                 * @return {?}
                 */
                () => RadioItemComponent)),] }],
    onChange: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class RadioModule {
}
RadioModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, FormsModule, ListModule],
                declarations: [RadioComponent, RadioItemComponent, RadioItemGroupComponent],
                exports: [RadioComponent, RadioItemComponent, RadioItemGroupComponent]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ProgressComponent {
    constructor() {
        this.prefixCls = 'am-progress';
        this._percent = 0;
        this._exceedance = false;
        this.unfilled = true;
        this.position = 'fixed';
        this.barStyle = {};
        this.max = 100;
        this.amProgress = true;
        this.outer = true;
    }
    /**
     * @return {?}
     */
    get percent() {
        return this._percent;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set percent(value) {
        this._percent = value;
        if (value > 100) {
            this._exceedance = true;
        }
        else {
            this._exceedance = false;
        }
    }
    /**
     * @return {?}
     */
    get value() {
        return this.percent;
    }
    /**
     * @return {?}
     */
    get fixOuter() {
        return 'fixed' === this.position;
    }
    /**
     * @return {?}
     */
    get hideOuter() {
        return !this.unfilled && !this._exceedance;
    }
    /**
     * @return {?}
     */
    get exceedance() {
        return this._exceedance;
    }
}
ProgressComponent.decorators = [
    { type: Component, args: [{
                selector: 'Progress, nzm-progress',
                template: "<div class=\"{{prefixCls}}-bar\" [ngStyle]=\"barStyle\" [style.width.%]=\"(percent <= 100) ? percent : (10000 / percent)\"></div>",
                encapsulation: ViewEncapsulation.None
            }] }
];
/** @nocollapse */
ProgressComponent.ctorParameters = () => [];
ProgressComponent.propDecorators = {
    unfilled: [{ type: Input }],
    position: [{ type: Input }],
    barStyle: [{ type: Input }],
    percent: [{ type: Input }],
    max: [{ type: HostBinding, args: ['attr.max',] }],
    value: [{ type: HostBinding, args: ['attr.value',] }],
    amProgress: [{ type: HostBinding, args: ['class.am-progress',] }],
    outer: [{ type: HostBinding, args: ['class.am-progress-outer',] }],
    fixOuter: [{ type: HostBinding, args: ['class.am-progress-fixed-outer',] }],
    hideOuter: [{ type: HostBinding, args: ['class.am-progress-hide-outer',] }],
    exceedance: [{ type: HostBinding, args: ['class.am-progress-exceedance',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ProgressModule {
}
ProgressModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                declarations: [ProgressComponent],
                exports: [ProgressComponent]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AccordionService {
    constructor() {
        this.accordion = false;
    }
    /**
     * @param {?} component
     * @return {?}
     */
    getComponent(component) {
        this.accordion = component.accordion;
        this.component = component;
    }
}
AccordionService.decorators = [
    { type: Injectable }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// tslint:disable-next-line:no-any
/**
 * @param {?} value
 * @return {?}
 */
function isTemplateRef(value) {
    return value instanceof TemplateRef;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AccordionGroupComponent {
    /**
     * @param {?} _accordionService
     * @param {?} _cdr
     */
    constructor(_accordionService, _cdr) {
        this._accordionService = _accordionService;
        this._cdr = _cdr;
        this.isShowChild = true;
        this.isOpened = false;
        this.disabled = false;
        this.onOpen = new EventEmitter();
        this.onClose = new EventEmitter();
        this.onChange = new EventEmitter();
        this.isTemplateRef = isTemplateRef;
        this.amItem = true;
        this.isActive = this.isOpened;
        this.addon = true;
    }
    /**
     * @return {?}
     */
    checkAndToggle() {
        this.toggle();
    }
    /**
     * @return {?}
     */
    get slide() {
        return this.isOpened ? 'down' : 'up';
    }
    /**
     * @return {?}
     */
    toggle() {
        if (this.disabled) {
            return;
        }
        this.isShowChild = true;
        /** @type {?} */
        const isOpenedBeforeWeChange = this.isOpened;
        if (this._accordionService.accordion) {
            this._accordionService.component.closeAll();
        }
        this.isOpened = !isOpenedBeforeWeChange;
        if (this.isOpened) {
            this.onOpen.emit();
        }
        else {
            this.onClose.emit();
        }
        this.onChange.emit(this.isOpened);
    }
    /**
     * @return {?}
     */
    openOnInitialization() {
        setTimeout((/**
         * @return {?}
         */
        () => {
            this.isOpened = true;
            this._cdr.detectChanges();
        }), 0);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    slideAnimationDoen(event) {
        if (event.fromState === 'down' && event.toState === 'up') {
            this.isShowChild = false;
        }
    }
}
AccordionGroupComponent.decorators = [
    { type: Component, args: [{
                selector: 'AccordionPanel',
                template: "<div role=\"tab\"\n     class=\"am-accordion-header\"\n     data-scale=\"true\"\n     [attr.aria-expanded]=\"isOpened\"\n     (click)=\"checkAndToggle()\"\n>\n  <i class=\"arrow\"></i>\n  <div *ngIf=\"!isTemplateRef(header)\" [innerHTML]=\"header | safeHTML\"></div>\n  <ng-template *ngIf=\"isTemplateRef(header)\" [ngTemplateOutlet]=\"header\"></ng-template>\n</div>\n<div role=\"tabpanel\"\n     class=\"am-accordion-content\"\n     [ngClass]=\"{'am-accordion-content-active':isOpened}\"\n     [@slide]=\"slide\"\n     (@slide.done)=\"slideAnimationDoen($event)\"\n>\n  <div *ngIf=\"isShowChild\" class=\"am-accordion-content-box\">\n    <ng-content></ng-content>\n  </div>\n</div>\n",
                encapsulation: ViewEncapsulation.None,
                animations: [
                    trigger('slide', [
                        state('up', style({ height: 0 })),
                        state('down', style({ height: '*' })),
                        transition('down => up', [animate(200, style({ height: 0 }))]),
                        transition('up => down', [
                            animate(200, style({
                                height: '*'
                            }))
                        ])
                    ])
                ]
            }] }
];
/** @nocollapse */
AccordionGroupComponent.ctorParameters = () => [
    { type: AccordionService },
    { type: ChangeDetectorRef }
];
AccordionGroupComponent.propDecorators = {
    key: [{ type: Input }],
    header: [{ type: Input }],
    isOpened: [{ type: Input }],
    disabled: [{ type: Input }],
    onOpen: [{ type: Output }],
    onClose: [{ type: Output }],
    onChange: [{ type: Output }],
    amItem: [{ type: HostBinding, args: ['class.am-accordion-item',] }],
    isActive: [{ type: HostBinding, args: ['class.am-accordion-item-active',] }],
    addon: [{ type: HostBinding, args: ['class.addon',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AccordionComponent {
    /**
     * @param {?} _accordionService
     */
    constructor(_accordionService) {
        this._accordionService = _accordionService;
        this.isFirstChange = true;
        this.expandAll = false;
        this.openAnimation = {};
        this.accordion = false;
        this.onChange = new EventEmitter();
        this.amAccordion = true;
        this._accordionService.getComponent(this);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    click(event) {
        /** @type {?} */
        let result = [];
        this.groups.toArray().forEach((/**
         * @param {?} group
         * @return {?}
         */
        group => {
            if (group.isOpened) {
                if (this.accordion) {
                    result = group.key;
                }
                else {
                    result.push(group.key);
                }
            }
        }));
        this.onChange.emit(result);
    }
    /**
     * @return {?}
     */
    closeAll() {
        this.groups.toArray().forEach((/**
         * @param {?} group
         * @return {?}
         */
        group => {
            group.isOpened = false;
        }));
    }
    /**
     * @return {?}
     */
    init() {
        if (this.expandAll && this.groups && this.groups.length > 0) {
            this._oldGroups = this.groups.toArray();
            this._oldGroups.forEach((/**
             * @param {?} group
             * @param {?} index
             * @return {?}
             */
            (group, index) => {
                group.openOnInitialization();
            }));
            this._subscription = this.groups.changes.subscribe((/**
             * @param {?} change
             * @return {?}
             */
            change => {
                /** @type {?} */
                const newGroups = this.groups.toArray().filter((/**
                 * @param {?} group
                 * @return {?}
                 */
                group => {
                    return this._oldGroups.indexOf(group) === -1;
                }));
                newGroups.forEach((/**
                 * @param {?} group
                 * @return {?}
                 */
                group => {
                    group.openOnInitialization();
                }));
                this._oldGroups = this.groups.toArray();
            }));
        }
        /** @type {?} */
        let currentActiveKey = [];
        if (this.activeKey !== undefined && this.activeKey.length > 0 && !this.accordion && this.groups && this.groups.length > 0) {
            currentActiveKey = this.toArray(this.activeKey);
            this.groups.forEach((/**
             * @param {?} group
             * @param {?} index
             * @return {?}
             */
            (group, index) => {
                currentActiveKey.forEach((/**
                 * @param {?} key
                 * @return {?}
                 */
                key => {
                    if (index === parseInt(key, 0)) {
                        setTimeout((/**
                         * @return {?}
                         */
                        () => {
                            group.isOpened = true;
                            group.openOnInitialization();
                        }), 0);
                    }
                }));
            }));
        }
        else if (this.defaultActiveKey !== undefined && !this.expandAll && !this.accordion && this.groups && this.groups.length > 0) {
            this.groups.forEach((/**
             * @param {?} group
             * @param {?} index
             * @return {?}
             */
            (group, index) => {
                if (index === parseInt(this.defaultActiveKey, 0)) {
                    setTimeout((/**
                     * @return {?}
                     */
                    () => {
                        group.isOpened = true;
                        group.openOnInitialization();
                    }), 0);
                }
            }));
        }
    }
    /**
     * @param {?} activeKey
     * @return {?}
     */
    toArray(activeKey) {
        /** @type {?} */
        let currentActiveKey = activeKey;
        if (!Array.isArray(currentActiveKey)) {
            currentActiveKey = currentActiveKey !== undefined && currentActiveKey !== '' ? [currentActiveKey] : [];
        }
        return currentActiveKey;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes.accordion) {
            this._accordionService.getComponent(this);
        }
        if (changes.expandAll || changes.accordion) {
            this.init();
        }
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        if (this.groups && this.groups.length > 0) {
            this.init();
        }
        else {
            this.groupsSubscription = this.groups.changes.subscribe((/**
             * @param {?} group
             * @return {?}
             */
            group => {
                if (this.isFirstChange) {
                    this.init();
                }
                this.isFirstChange = false;
            }));
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this._subscription) {
            this._subscription.unsubscribe();
        }
        if (this.groupsSubscription) {
            this.groupsSubscription.unsubscribe();
        }
    }
}
AccordionComponent.decorators = [
    { type: Component, args: [{
                selector: 'Accordion, nzm-accordion',
                template: "<ng-content></ng-content>",
                providers: [AccordionService]
            }] }
];
/** @nocollapse */
AccordionComponent.ctorParameters = () => [
    { type: AccordionService }
];
AccordionComponent.propDecorators = {
    groups: [{ type: ContentChildren, args: [forwardRef((/**
                 * @return {?}
                 */
                () => AccordionGroupComponent)),] }],
    expandAll: [{ type: Input }],
    activeKey: [{ type: Input }],
    defaultActiveKey: [{ type: Input }],
    openAnimation: [{ type: Input }],
    accordion: [{ type: Input }],
    onChange: [{ type: Output }],
    amAccordion: [{ type: HostBinding, args: ['class.am-accordion',] }],
    click: [{ type: HostListener, args: ['click', ['$event'],] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SafeHTMLPipe {
    /**
     * @param {?} _sanitized
     */
    constructor(_sanitized) {
        this._sanitized = _sanitized;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    transform(value) {
        return this._sanitized.bypassSecurityTrustHtml(value);
    }
}
SafeHTMLPipe.decorators = [
    { type: Pipe, args: [{ name: 'safeHTML' },] }
];
/** @nocollapse */
SafeHTMLPipe.ctorParameters = () => [
    { type: DomSanitizer }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgZorroAntdMobilePipesModule {
}
NgZorroAntdMobilePipesModule.decorators = [
    { type: NgModule, args: [{
                imports: [],
                declarations: [
                    SafeHTMLPipe
                ],
                exports: [SafeHTMLPipe]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AccordionModule {
}
AccordionModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, WhiteSpaceModule, NgZorroAntdMobilePipesModule],
                declarations: [AccordionComponent, AccordionGroupComponent],
                exports: [AccordionComponent, AccordionGroupComponent]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} rule
 * @param {?} className
 * @return {?}
 */
function insertKeyFrame(rule, className) {
    /** @type {?} */
    const style = document.createElement('style');
    style.setAttribute('class', className);
    style.innerHTML = rule;
    document.body.appendChild(style);
}
/**
 * @param {?} className
 * @return {?}
 */
function deleteKeyFrame(className) {
    /** @type {?} */
    const styleDom = document.getElementsByClassName(className);
    while (styleDom.length > 0) {
        styleDom[0].remove();
    }
}
/**
 * @return {?}
 */
function getWidthHeight() {
    /** @type {?} */
    const w = window;
    /** @type {?} */
    const d = document;
    /** @type {?} */
    const e = d.documentElement;
    /** @type {?} */
    const g = d.getElementsByTagName('body')[0];
    return {
        width: w.innerWidth || e.clientWidth || g.clientWidth,
        height: w.innerHeight || e.clientHeight || g.clientHeight
    };
}
/**
 * @param {?} text
 * @param {?} font
 * @return {?}
 */
function getTextWidth(text, font) {
    /** @type {?} */
    const _dom = document.createElement('div');
    _dom.innerHTML = text;
    _dom.style.position = 'absolute';
    _dom.style.left = '-9999';
    _dom.style.whiteSpace = 'nowrap';
    _dom.style.fontSize = font;
    document.body.appendChild(_dom);
    /** @type {?} */
    const _w = _dom.clientWidth + 10;
    document.body.removeChild(_dom);
    return _w;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NoticeBarComponent {
    /**
     * @param {?} _iconHandler
     */
    constructor(_iconHandler) {
        this._iconHandler = _iconHandler;
        this.visiable = false;
        this.marqueeScroll = 'scrolling';
        this.style = {};
        this._option = {
            mode: '',
            icon: '',
            action: '',
            content: '',
            fontSize: '14px',
            scrolling: true,
            marqueeProps: { loop: true, leading: 500, trailing: 8000, fps: 200, style: {} }
        };
        this.onClick = new EventEmitter();
        this._iconHandler.load();
    }
    /**
     * @return {?}
     */
    get option() {
        return this._option;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set option(value) {
        Object.assign(this._option, value);
        this.dataProcess();
        if (this._option.scrolling) {
            this.marqueeScroll = 'scrolling';
        }
        else {
            this.marqueeScroll = 'scrolling-stop';
        }
    }
    /**
     * @return {?}
     */
    click() {
        this.onClick.emit(this._option.mode);
        if (this._option.mode === 'closable') {
            this.visiable = false;
        }
    }
    /**
     * @return {?}
     */
    dataProcess() {
        this.visiable = true;
        this.style = {
            width: '200%'
        };
        this._width = getTextWidth(this._option.content, this._option.fontSize);
        if (getWidthHeight().width < this._width) {
            /** @type {?} */
            const count = this._option.marqueeProps.loop ? 'infinite' : 1;
            /** @type {?} */
            let animationName = `noticebarmarquee_${this._width}`;
            this.style = {
                width: this._width * 2 + 'px',
                'animation-name': animationName,
                'animation-delay': `${this._option.marqueeProps.leading}ms`,
                'animation-duration': `${(1 / this._option.marqueeProps.fps) * this._width / getWidthHeight().width * 1000}s`,
                'animation-iteration-count': `${count}`
            };
            this.marqueeScroll = 'scrolling';
            this.insetKeyframe(animationName);
        }
        else {
            this.marqueeScroll = 'scrolling-stop';
        }
    }
    /**
     * @param {?} animationName
     * @return {?}
     */
    insetKeyframe(animationName) {
        insertKeyFrame(`@keyframes ${animationName} {
      0% { left: 0px; }
      100% { left: -${this._width}px }
    }`, 'notice_bar_animation_cls');
        insertKeyFrame(`@-webkit-keyframes ${animationName} {
      0% { left: 0px; }
      100% { left: -${this._width}px }
    }`, 'notice_bar_animation_cls');
        insertKeyFrame(`@-moz-keyframes ${animationName} {
      0% { left: 0px; }
      100% { left: -${this._width}px }
    }`, 'notice_bar_animation_cls');
        insertKeyFrame(`@-o-keyframes ${animationName} {
      0% { left: 0px; }
      100% { left: -${this._width}px }
    }`, 'notice_bar_animation_cls');
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        document.addEventListener('touchstart', (/**
         * @return {?}
         */
        () => {
            this.marqueeScroll = 'scrolling-stop';
        }));
        document.addEventListener('touchend', (/**
         * @return {?}
         */
        () => {
            this.marqueeScroll = 'scrolling';
        }));
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        deleteKeyFrame('notice_bar_animation_cls');
    }
}
NoticeBarComponent.decorators = [
    { type: Component, args: [{
                selector: 'NoticeBar, nzm-notice-bar',
                template: "<div role=\"alert\" *ngIf=\"visiable\" class=\"am-notice-bar\" (click)=\"click()\">\n  <div *ngIf=\"option.icon !== null\" class=\"am-notice-bar-icon\">\n    <ng-template [ngTemplateOutlet]=\"option.icon || voice\"></ng-template>\n  </div>\n  <div class=\"am-notice-bar-content\">\n    <div class=\"marquee\">\n      <div [ngClass]=\"marqueeScroll\" [ngStyle]=\"style\">\n        <span>{{option.content}}</span>\n        <span>{{option.content}}</span>\n      </div>\n    </div>\n  </div>\n  <div role=\"button\" *ngIf=\"option.mode && option.action !== null\" class=\"am-notice-bar-operation\">\n    <ng-template *ngIf=\"option.mode === 'closable'\" [ngTemplateOutlet]=\"option.action || cross\"></ng-template>\n    <ng-template *ngIf=\"option.mode === 'link'\" [ngTemplateOutlet]=\"option.action || right\"></ng-template>\n  </div>\n</div>\n\n<ng-template #voice>\n  <Icon [type]=\"'voice'\" [size]=\"'xxs'\"></Icon>\n</ng-template>\n<ng-template #cross>\n  <Icon [type]=\"'cross'\" [size]=\"'md'\"></Icon>\n</ng-template>\n<ng-template #right>\n  <Icon [type]=\"'right'\" [size]=\"'md'\"></Icon>\n</ng-template>",
                providers: [IconHandler]
            }] }
];
/** @nocollapse */
NoticeBarComponent.ctorParameters = () => [
    { type: IconHandler }
];
NoticeBarComponent.propDecorators = {
    option: [{ type: Input }],
    onClick: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NoticeBarModule {
}
NoticeBarModule.decorators = [
    { type: NgModule, args: [{
                imports: [IconModule, CommonModule, FormsModule],
                declarations: [NoticeBarComponent],
                exports: [NoticeBarComponent],
                providers: [],
                entryComponents: []
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ToastComponent {
    /**
     * @param {?} _zone
     */
    constructor(_zone) {
        this._zone = _zone;
        this.prefixCls = 'am-toast';
        this.isContentString = true;
        this.transitionName = 'am-fade-enter am-fade-enter-active';
        this._iconType = '';
        this._content = '';
        this.mask = true;
        this.position = 'middle';
    }
    /**
     * @return {?}
     */
    get content() {
        return this._content;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set content(value) {
        if (value instanceof TemplateRef) {
            this.isContentString = false;
        }
        else {
            this.isContentString = true;
        }
        this._zone.run((/**
         * @return {?}
         */
        () => {
            this._content = value;
        }));
    }
    /**
     * @return {?}
     */
    get iconType() {
        return this._iconType;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set iconType(value) {
        this._zone.run((/**
         * @return {?}
         */
        () => {
            this._iconType = value;
        }));
    }
}
ToastComponent.decorators = [
    { type: Component, args: [{
                selector: 'Toast',
                encapsulation: ViewEncapsulation.None,
                template: "<div class=\"{{prefixCls}}-notice {{prefixCls}}-notice-closable {{transitionName}}\">\n  <div class=\"{{prefixCls}}-notice-content\">\n    <div role=\"alert\"\n         *ngIf=\"iconType\"\n         class=\"{{prefixCls}}-text {{prefixCls}}-text-icon\"\n         aria-live=\"assertive\"\n    >\n      <Icon [type]=\"iconType\" [size]=\"'lg'\"></Icon>\n      <div *ngIf=\"isContentString\" class=\"{{prefixCls}}-text-info\">{{content}}</div>\n    </div>\n    <div *ngIf=\"!iconType\" class=\"{{prefixCls}}-text\" role=\"alert\" aria-live=\"assertive\">\n      <div *ngIf=\"isContentString\" class=\"{{prefixCls}}-text-info\">{{content}}</div>\n      <ng-template *ngIf=\"!isContentString\" [ngTemplateOutlet]=\"content\"></ng-template>\n    </div>\n  </div>\n  <a class=\"{{prefixCls}}-notice-close\">\n    <span class=\"{{prefixCls}}-notice-close-x\"></span>\n  </a>\n</div>\n",
                host: {
                    '[class.am-toast]': 'true',
                    '[class.am-toast-mask]': 'mask',
                    '[class.am-toast-mask-top]': `mask && position === 'top'`,
                    '[class.am-toast-mask-middle]': `mask && position === 'middle'`,
                    '[class.am-toast-mask-bottom]': `mask && position === 'bottom'`,
                    '[class.am-toast-nomask]': '!mask',
                    '[class.am-toast-nomask-top]': `!mask && position === 'top'`,
                    '[class.am-toast-nomask-middle]': `!mask && position === 'middle'`,
                    '[class.am-toast-nomask-bottom]': `!mask && position === 'bottom'`,
                }
            }] }
];
/** @nocollapse */
ToastComponent.ctorParameters = () => [
    { type: NgZone }
];
ToastComponent.propDecorators = {
    mask: [{ type: Input }],
    content: [{ type: Input }],
    iconType: [{ type: Input }],
    position: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ToastOptions {
}
ToastOptions.decorators = [
    { type: Injectable }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ToastService {
    /**
     * @param {?} _appRef
     * @param {?} _compiler
     * @param {?} _cfr
     * @param {?} _zone
     */
    constructor(_appRef, _compiler, _cfr, _zone) {
        this._appRef = _appRef;
        this._compiler = _compiler;
        this._cfr = _cfr;
        this._zone = _zone;
        ToastService._zone = this._zone;
        ToastService._appRef = this._appRef;
        ToastService._toastCompFactory = this._cfr.resolveComponentFactory(ToastComponent);
    }
    /**
     * @param {?} config
     * @param {?} options
     * @return {?}
     */
    static _initConfig(config, options) {
        /** @type {?} */
        const props = {};
        /** @type {?} */
        const optionalParams = ['content', 'iconType', 'mask', 'position'];
        config = Object.assign(options, config);
        optionalParams.forEach((/**
         * @param {?} key
         * @return {?}
         */
        key => {
            if (config[key] !== undefined) {
                props[key] = config[key];
            }
        }));
        /** @type {?} */
        const iconType = {
            info: '',
            success: 'success',
            fail: 'fail',
            offline: 'dislike',
            loading: 'loading'
        }[options.iconType];
        props['iconType'] = iconType;
        props['mask'] = options.mask;
        props['position'] = options.position;
        return props;
    }
    /**
     * @param {?} config
     * @param {?} type
     * @param {?=} timeInterval
     * @param {?=} onClose
     * @param {?=} mask
     * @param {?=} position
     * @return {?}
     */
    static notice(config, type, timeInterval = 2000, onClose, mask = true, position = 'middle') {
        // 如果已经存在，在没有遮罩层的情况下，会响应别的toast，需要清除原来的
        if (ToastService.compRef) {
            ToastService.hide();
        }
        /** @type {?} */
        const options = new ToastOptions();
        options.iconType = type;
        options.mask = mask;
        options.position = position;
        /** @type {?} */
        const props = ToastService._initConfig(config, options);
        document.body.insertBefore(document.createElement(ToastService._toastCompFactory.selector), document.body.firstChild);
        /** @type {?} */
        let instance;
        /** @type {?} */
        let subject;
        ToastService.compRef = ToastService._appRef.bootstrap(ToastService._toastCompFactory);
        instance = ToastService.compRef.instance;
        subject = instance.subject;
        if (timeInterval) {
            ToastService.timeout = setTimeout((/**
             * @return {?}
             */
            () => {
                if (onClose) {
                    onClose();
                }
                ToastService.hide();
            }), timeInterval);
        }
        Object.assign(instance, props);
        return subject;
    }
    /**
     * Open info dialog
     * @param {?=} content
     * @param {?=} timeInterval
     * @param {?=} onClose
     * @param {?=} mask
     * @param {?=} position
     * @return {?}
     */
    static info(content, timeInterval, onClose, mask, position) {
        /** @type {?} */
        const config = Object.assign({
            iconType: 'info',
            content: content
        });
        return ToastService.notice(config, 'info', timeInterval, onClose, mask, position);
    }
    /**
     * Open success dialog
     * @param {?=} content
     * @param {?=} timeInterval
     * @param {?=} onClose
     * @param {?=} mask
     * @param {?=} position
     * @return {?}
     */
    static success(content, timeInterval, onClose, mask, position) {
        /** @type {?} */
        const config = Object.assign({
            iconType: 'success',
            content: content
        });
        return ToastService.notice(config, 'success', timeInterval, onClose, mask, position);
    }
    /**
     * @param {?=} content
     * @param {?=} timeInterval
     * @param {?=} mask
     * @param {?=} position
     * @return {?}
     */
    static show(content, timeInterval, mask, position) {
        /** @type {?} */
        const config = Object.assign({
            iconType: 'info',
            content: content
        });
        return ToastService.notice(config, 'info', timeInterval, (/**
         * @return {?}
         */
        () => { }), mask, position);
    }
    /**
     * @param {?=} content
     * @param {?=} timeInterval
     * @param {?=} onClose
     * @param {?=} mask
     * @param {?=} position
     * @return {?}
     */
    static fail(content, timeInterval, onClose, mask, position) {
        /** @type {?} */
        const config = Object.assign({
            iconType: 'fail',
            content: content
        });
        return ToastService.notice(config, 'fail', timeInterval, onClose, mask, position);
    }
    /**
     * @param {?=} content
     * @param {?=} timeInterval
     * @param {?=} onClose
     * @param {?=} mask
     * @param {?=} position
     * @return {?}
     */
    static offline(content, timeInterval, onClose, mask, position) {
        /** @type {?} */
        const config = Object.assign({
            iconType: 'offline',
            content: content
        });
        return ToastService.notice(config, 'offline', timeInterval, onClose, mask, position);
    }
    /**
     * @param {?=} content
     * @param {?=} timeInterval
     * @param {?=} onClose
     * @param {?=} mask
     * @param {?=} position
     * @return {?}
     */
    static loading(content, timeInterval, onClose, mask, position) {
        /** @type {?} */
        const config = Object.assign({
            iconType: 'loading',
            content: content
        });
        return ToastService.notice(config, 'loading', timeInterval, onClose, mask, position);
    }
    /**
     * @return {?}
     */
    static hide() {
        if (ToastService.timeout) {
            clearTimeout(ToastService.timeout);
        }
        if (ToastService.compRef) {
            ToastService._zone.run((/**
             * @return {?}
             */
            () => {
                ToastService.compRef.destroy();
            }));
            ToastService.compRef = null;
        }
    }
}
ToastService.timeout = null;
ToastService._zone = null;
ToastService.compRef = null;
ToastService._toastCompFactory = null;
ToastService._appRef = null;
ToastService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] },
    { type: Injectable }
];
/** @nocollapse */
ToastService.ctorParameters = () => [
    { type: ApplicationRef },
    { type: Compiler },
    { type: ComponentFactoryResolver },
    { type: NgZone }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ToastModule {
}
ToastModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, IconModule, WingBlankModule],
                exports: [ToastComponent],
                declarations: [ToastComponent],
                entryComponents: [ToastComponent],
                providers: [ToastService]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ModalBaseOptions {
    constructor() {
        this.visible = false;
        this.focus = true;
        this.prefixCls = 'am-modal';
        this.animated = true;
        this.closable = false;
        this.maskClosable = true;
        this.transparent = false;
        this.popup = false;
        this.animationType = 'slide-down';
        this.footer = [];
        this.platform = 'ios';
        this.defaultValue = [];
        this.placeholders = [];
        this.transitionName = 'am-zoom';
        this.maskTransitionName = 'am-fade';
    }
}
class ModalOptions extends ModalBaseOptions {
    constructor() {
        super(...arguments);
        this.transitionName = 'am-fade';
        this.maskTransitionName = 'am-fade';
    }
}
ModalOptions.decorators = [
    { type: Injectable }
];
class AlertOptions extends ModalBaseOptions {
}
AlertOptions.decorators = [
    { type: Injectable }
];
class Action {
}
Action.decorators = [
    { type: Injectable }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ModalComponent {
    /**
     * @param {?} option
     */
    constructor(option) {
        this.option = option;
        this.autoFocus = { focus: true, date: new Date() };
        this.transitionName = '';
        this.maskTransitionName = '';
        this.wrapCls = {};
        this.cls = {};
        this.btnGroupClass = {};
        this.data = {
            text: '',
            password: ''
        };
        this.onClose = new EventEmitter();
    }
    /**
     * @return {?}
     */
    get title() {
        return this.option.title;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set title(value) {
        this.option.title = value;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set closable(value) {
        this.option.closable = value;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set maskClosable(value) {
        this.option.maskClosable = value;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set popup(value) {
        this.option.popup = value;
        this.setClassMap();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set animationType(value) {
        this.option.animationType = value;
        this.setClassMap();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set transparent(value) {
        this.option.transparent = value;
        this.setClassMap();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set footer(value) {
        this.option.footer = value;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set platform(value) {
        this.option.platform = value;
        this.setClassMap();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set className(value) {
        this.option.className = value;
        this.setClassMap();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set wrapClassName(value) {
        this.option.wrapClassName = value;
        this.setClassMap();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set actions(value) {
        this.option.footer = value;
        this.setClassMap();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set defaultValue(value) {
        this.option.defaultValue = value !== undefined ? value : ['', ''];
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set type(value) {
        this.option.type = value;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set placeholders(value) {
        this.option.placeholders = value;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set operation(value) {
        this.option.operation = value;
        this.setClassMap();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    panend(event) {
        if (this.option.closable || this.option.maskClosable || this.option.popup) {
            if ((event && event.target && event.target.getAttribute('role') === 'dialog') ||
                event.target.getAttribute('role') === 'close') {
                if (this.option.close) {
                    this.option.close();
                }
                else {
                    this.onClose.emit();
                    this.leaveAnimation();
                }
            }
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    isTemplateRef(value) {
        return value instanceof TemplateRef;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    isNoTitle(value) {
        return value === '' || value === null || value === undefined;
    }
    /**
     * @param {?} visible
     * @return {?}
     */
    setTransitionName(visible) {
        if (!visible) {
            this.leaveAnimation();
        }
        else {
            if (this.option.animated) {
                if (this.option.transparent) {
                    if (this.setActiveName(this.option.transitionName)) {
                        this.transitionName = this.setActiveName(this.option.transitionName);
                        this.maskTransitionName = this.setActiveName(this.option.maskTransitionName);
                    }
                    else {
                        this.transitionName = this.maskTransitionName = this.setActiveName('am-fade');
                    }
                }
                else {
                    if (this.setActiveName(this.option.transitionName)) {
                        this.transitionName = this.setActiveName(this.option.transitionName);
                        this.maskTransitionName = this.setActiveName(this.option.maskTransitionName);
                    }
                    else {
                        this.transitionName = this.maskTransitionName = this.setActiveName('am-slide-up');
                    }
                }
                if (this.option.popup) {
                    this.transitionName =
                        this.option.animationType === 'slide-up'
                            ? this.setActiveName('am-slide-up')
                            : this.setActiveName('am-slide-down');
                    this.maskTransitionName = this.setActiveName('am-fade');
                }
            }
            this.setClassMap();
        }
    }
    /**
     * @param {?} name
     * @return {?}
     */
    setActiveName(name) {
        return name.length > 0 ? `${name}-enter ${name}-enter-active` : null;
    }
    /**
     * @param {?} name
     * @return {?}
     */
    setLeaveActiveName(name) {
        return name.length > 0 ? `${name}-leave ${name}-leave-active` : null;
    }
    /**
     * @return {?}
     */
    setClassMap() {
        this.wrapCls = {
            [this.option.wrapClassName]: true,
            [`${this.option.prefixCls}-wrap-popup`]: this.option.popup
        };
        this.cls = {
            [this.option.className]: true,
            [`${this.option.prefixCls}-transparent`]: this.option.transparent,
            [`${this.option.prefixCls}-popup`]: this.option.popup,
            [`${this.option.prefixCls}-popup-${this.option.animationType}`]: this.option.popup && this.option.animationType,
            [`${this.option.prefixCls}-android`]: this.option.platform === 'android'
        };
        this.btnGroupClass = {
            [`${this.option.prefixCls}-button-group-${this.option.footer.length === 2 && !this.option.operation ? 'h' : 'v'}`]: true,
            [`${this.option.prefixCls}-button-group-${this.option.operation ? 'operation' : 'normal'}`]: true
        };
    }
    /**
     * @param {?} type
     * @param {?} value
     * @return {?}
     */
    inputChange(type, value) {
        this.data[type] = value;
    }
    /**
     * @return {?}
     */
    leaveAnimation() {
        if (this.option.animated) {
            if (this.option.transparent) {
                if (this.setLeaveActiveName(this.option.transitionName)) {
                    this.transitionName = this.setLeaveActiveName(this.option.transitionName);
                    this.maskTransitionName = this.setLeaveActiveName(this.option.maskTransitionName);
                }
                else {
                    this.transitionName = this.maskTransitionName = this.setLeaveActiveName('am-fade');
                }
            }
            else {
                if (this.setLeaveActiveName(this.option.transitionName)) {
                    this.transitionName = this.setLeaveActiveName(this.option.transitionName);
                    this.maskTransitionName = this.setLeaveActiveName(this.option.maskTransitionName);
                }
                else {
                    this.transitionName = this.maskTransitionName = this.setLeaveActiveName('am-slide-up');
                }
            }
            if (this.option.popup) {
                this.transitionName =
                    this.option.animationType === 'slide-up'
                        ? this.setLeaveActiveName('am-slide-up')
                        : this.setLeaveActiveName('am-slide-down');
                this.maskTransitionName = this.setLeaveActiveName('am-fade');
            }
        }
        setTimeout((/**
         * @return {?}
         */
        () => {
            this.option.visible = false;
            this.onChanged(this.option.visible);
        }), 200);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        if (value) {
            this.option.visible = value;
        }
        this.setTransitionName(value);
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.onChanged = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
}
ModalComponent.decorators = [
    { type: Component, args: [{
                selector: 'Modal',
                template: "<div *ngIf=\"option.visible\">\n  <div class=\"{{option.prefixCls}}-mask {{maskTransitionName}}\"></div>\n  <div role=\"dialog\"\n       class=\"{{option.prefixCls}}-wrap {{transitionName}}\"\n       [ngClass]=\"wrapCls\"\n  >\n    <div role=\"document\"\n         class=\"{{option.prefixCls}}\"\n         [ngClass]=\"cls\"\n    >\n      <div class=\"{{option.prefixCls}}-content\">\n        <div  *ngIf=\"option.closable\" style=\"width: 100%; height: 21px;\">\n          <div role=\"close\"\n               class=\"{{option.prefixCls}}-close\"\n        >\n            <span role=\"close\" class=\"{{option.prefixCls}}-close-x\"></span>\n          </div>\n        </div>\n        <div *ngIf=\"!isNoTitle(option.title)\" class=\"{{option.prefixCls}}-header\">\n          <div *ngIf=\"!isTemplateRef(option.title)\" class=\"{{option.prefixCls}}-title\">{{option.title}}</div>\n          <ng-template *ngIf=\"isTemplateRef(option.title)\" [ngTemplateOutlet]=\"option.title\"></ng-template>\n        </div>\n        <div class=\"{{option.prefixCls}}-body\">\n          <ng-content></ng-content>\n          <div *ngIf=\"!isTemplateRef(option.message)\" class=\"{{option.prefixCls}}-alert-content\">{{option.message}}</div>\n          <ng-template *ngIf=\"isTemplateRef(option.message)\" [ngTemplateOutlet]=\"option.message\"></ng-template>\n          <ng-template *ngIf=\"option.type === 'default'\" [ngTemplateOutlet]=\"promptDefault\"></ng-template>\n          <ng-template *ngIf=\"option.type === 'secure-text'\" [ngTemplateOutlet]=\"promptSecure\"></ng-template>\n          <ng-template *ngIf=\"option.type === 'login-password'\" [ngTemplateOutlet]=\"promptPassword\"></ng-template>\n        </div>\n        <div class=\"{{option.prefixCls}}-footer\">\n          <div [ngClass]=\"btnGroupClass\" role=\"group\">\n            <div Button\n                 role=\"button\"\n                 *ngFor=\"let button of option.footer\"\n                 [className]=\"'am-modal-button'\"\n                 [ngStyle]=\"button.style\"\n                 (onClick)=\"button.onPress()\"\n            >\n              {{button.text}}\n            </div>\n          </div>\n        </div>\n      </div>\n    </div>\n  </div>\n</div>\n\n<ng-template #promptPassword>\n  <div class=\"{{option.prefixCls}}-input-container\">\n    <div class=\"{{option.prefixCls}}-input\">\n        <input\n          #inputElement\n          autofocus\n          [type]=\"'text'\"\n          [placeholder]=\"option.placeholders[0] || ''\"\n          [(ngModel)]=\"option.defaultValue[0]\"\n          (ngModelChange)=\"inputChange('text', $event)\"\n        >\n    </div>\n    <div className=\"{{option.prefixCls}}-input\">\n        <input\n          #inputElement\n          [type]=\"'password'\"\n          [placeholder]=\"option.placeholders[1] || ''\"\n          [(ngModel)]=\"option.defaultValue[1]\"\n          (ngModelChange)=\"inputChange('password', $event)\"\n        >\n    </div>\n  </div>\n</ng-template>\n<ng-template #promptSecure>\n  <div className=\"{{option.prefixCls}}-input-container\">\n    <div className=\"{{option.prefixCls}}-input\">\n        <input\n          #inputElement\n          autofocus\n          [type]=\"'password'\"\n          [placeholder]=\"option.placeholders[0] || ''\"\n          [(ngModel)]=\"option.defaultValue[0]\"\n          (ngModelChange)=\"inputChange('password', $event)\"\n        >\n    </div>\n  </div>\n</ng-template>\n<ng-template #promptDefault>\n  <div className=\"{{option.prefixCls}}-input-container\">\n    <div className=\"{{option.prefixCls}}-input\">\n      <input\n        #inputElement\n        autofocus\n        [type]=\"'text'\"\n        [placeholder]=\"option.placeholders[0] || ''\"\n        [(ngModel)]=\"option.defaultValue[0]\"\n        (ngModelChange)=\"inputChange('text', $event)\"\n      >\n    </div>\n  </div>\n</ng-template>",
                encapsulation: ViewEncapsulation.None,
                providers: [
                    ModalOptions,
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => ModalComponent)),
                        multi: true
                    }
                ]
            }] }
];
/** @nocollapse */
ModalComponent.ctorParameters = () => [
    { type: ModalOptions }
];
ModalComponent.propDecorators = {
    title: [{ type: Input }],
    closable: [{ type: Input }],
    maskClosable: [{ type: Input }],
    popup: [{ type: Input }],
    animationType: [{ type: Input }],
    transparent: [{ type: Input }],
    footer: [{ type: Input }],
    platform: [{ type: Input }],
    className: [{ type: Input }],
    wrapClassName: [{ type: Input }],
    actions: [{ type: Input }],
    defaultValue: [{ type: Input }],
    type: [{ type: Input }],
    placeholders: [{ type: Input }],
    operation: [{ type: Input }],
    onClose: [{ type: Output }],
    panend: [{ type: HostListener, args: ['mouseup', ['$event'],] }, { type: HostListener, args: ['touchend', ['$event'],] }]
};
class ModalServiceComponent extends ModalComponent {
    /**
     * @param {?} option
     */
    constructor(option) {
        super(option);
        this.option = option;
        this.setTransitionName(this.option.visible);
    }
}
ModalServiceComponent.decorators = [
    { type: Component, args: [{
                selector: 'ModalService',
                template: "<div *ngIf=\"option.visible\">\n  <div class=\"{{option.prefixCls}}-mask {{maskTransitionName}}\"></div>\n  <div role=\"dialog\"\n       class=\"{{option.prefixCls}}-wrap {{transitionName}}\"\n       [ngClass]=\"wrapCls\"\n  >\n    <div role=\"document\"\n         class=\"{{option.prefixCls}}\"\n         [ngClass]=\"cls\"\n    >\n      <div class=\"{{option.prefixCls}}-content\">\n        <div  *ngIf=\"option.closable\" style=\"width: 100%; height: 21px;\">\n          <div role=\"close\"\n               class=\"{{option.prefixCls}}-close\"\n        >\n            <span role=\"close\" class=\"{{option.prefixCls}}-close-x\"></span>\n          </div>\n        </div>\n        <div *ngIf=\"!isNoTitle(option.title)\" class=\"{{option.prefixCls}}-header\">\n          <div *ngIf=\"!isTemplateRef(option.title)\" class=\"{{option.prefixCls}}-title\">{{option.title}}</div>\n          <ng-template *ngIf=\"isTemplateRef(option.title)\" [ngTemplateOutlet]=\"option.title\"></ng-template>\n        </div>\n        <div class=\"{{option.prefixCls}}-body\">\n          <ng-content></ng-content>\n          <div *ngIf=\"!isTemplateRef(option.message)\" class=\"{{option.prefixCls}}-alert-content\">{{option.message}}</div>\n          <ng-template *ngIf=\"isTemplateRef(option.message)\" [ngTemplateOutlet]=\"option.message\"></ng-template>\n          <ng-template *ngIf=\"option.type === 'default'\" [ngTemplateOutlet]=\"promptDefault\"></ng-template>\n          <ng-template *ngIf=\"option.type === 'secure-text'\" [ngTemplateOutlet]=\"promptSecure\"></ng-template>\n          <ng-template *ngIf=\"option.type === 'login-password'\" [ngTemplateOutlet]=\"promptPassword\"></ng-template>\n        </div>\n        <div class=\"{{option.prefixCls}}-footer\">\n          <div [ngClass]=\"btnGroupClass\" role=\"group\">\n            <div Button\n                 role=\"button\"\n                 *ngFor=\"let button of option.footer\"\n                 [className]=\"'am-modal-button'\"\n                 [ngStyle]=\"button.style\"\n                 (onClick)=\"button.onPress()\"\n            >\n              {{button.text}}\n            </div>\n          </div>\n        </div>\n      </div>\n    </div>\n  </div>\n</div>\n\n<ng-template #promptPassword>\n  <div class=\"{{option.prefixCls}}-input-container\">\n    <div class=\"{{option.prefixCls}}-input\">\n        <input\n          #inputElement\n          autofocus\n          [type]=\"'text'\"\n          [placeholder]=\"option.placeholders[0] || ''\"\n          [(ngModel)]=\"option.defaultValue[0]\"\n          (ngModelChange)=\"inputChange('text', $event)\"\n        >\n    </div>\n    <div className=\"{{option.prefixCls}}-input\">\n        <input\n          #inputElement\n          [type]=\"'password'\"\n          [placeholder]=\"option.placeholders[1] || ''\"\n          [(ngModel)]=\"option.defaultValue[1]\"\n          (ngModelChange)=\"inputChange('password', $event)\"\n        >\n    </div>\n  </div>\n</ng-template>\n<ng-template #promptSecure>\n  <div className=\"{{option.prefixCls}}-input-container\">\n    <div className=\"{{option.prefixCls}}-input\">\n        <input\n          #inputElement\n          autofocus\n          [type]=\"'password'\"\n          [placeholder]=\"option.placeholders[0] || ''\"\n          [(ngModel)]=\"option.defaultValue[0]\"\n          (ngModelChange)=\"inputChange('password', $event)\"\n        >\n    </div>\n  </div>\n</ng-template>\n<ng-template #promptDefault>\n  <div className=\"{{option.prefixCls}}-input-container\">\n    <div className=\"{{option.prefixCls}}-input\">\n      <input\n        #inputElement\n        autofocus\n        [type]=\"'text'\"\n        [placeholder]=\"option.placeholders[0] || ''\"\n        [(ngModel)]=\"option.defaultValue[0]\"\n        (ngModelChange)=\"inputChange('text', $event)\"\n      >\n    </div>\n  </div>\n</ng-template>",
                encapsulation: ViewEncapsulation.None
            }] }
];
/** @nocollapse */
ModalServiceComponent.ctorParameters = () => [
    { type: ModalOptions }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PopupService {
    /**
     * @param {?} _overlay
     */
    constructor(_overlay) {
        this._overlay = _overlay;
        PopupService.overlay = this._overlay;
    }
    /**
     * @param {?} componentName
     * @param {?} component
     * @param {?=} childInjector
     * @param {?=} hasBackdrop
     * @param {?=} positionStrategy
     * @return {?}
     */
    static showPopup(componentName, component, childInjector, hasBackdrop, positionStrategy = PopupService.overlay.position().global().centerVertically().centerHorizontally()) {
        /** @type {?} */
        let overlayConfig = new OverlayConfig();
        overlayConfig.hasBackdrop = hasBackdrop;
        overlayConfig.positionStrategy = positionStrategy;
        PopupService.overlayRef = PopupService.overlay.create(overlayConfig);
        PopupService.overlayRef.backdropClick().subscribe((/**
         * @return {?}
         */
        () => {
            PopupService.hidePopup();
        }));
        PopupService.currentServiceName = componentName;
        /** @type {?} */
        const comRef = PopupService.overlayRef.attach(new ComponentPortal(component, undefined, childInjector));
        PopupService.serviceArray.push({ key: componentName, value: PopupService.overlayRef });
        return comRef;
    }
    /**
     * @param {?=} componentName
     * @return {?}
     */
    static hidePopup(componentName) {
        if (PopupService.serviceArray && PopupService.currentServiceName) {
            if (componentName) {
                PopupService.serviceArray.forEach((/**
                 * @param {?} element
                 * @param {?} index
                 * @return {?}
                 */
                (element, index) => {
                    if (element.key === componentName) {
                        PopupService.serviceArray[index].value.dispose();
                        PopupService.serviceArray.splice(index, 1);
                    }
                }));
            }
            else {
                PopupService.serviceArray.forEach((/**
                 * @param {?} element
                 * @param {?} index
                 * @return {?}
                 */
                (element, index) => {
                    PopupService.serviceArray[index].value.dispose();
                }));
                PopupService.serviceArray = [];
            }
        }
    }
}
PopupService.overlay = null;
PopupService.overlayRef = null;
PopupService.currentServiceName = null;
PopupService.serviceArray = [];
PopupService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] },
    { type: Injectable }
];
/** @nocollapse */
PopupService.ctorParameters = () => [
    { type: Overlay }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ModalService extends PopupService {
    /**
     * @param {?} config
     * @param {?} options
     * @return {?}
     */
    static _initConfig(config, options) {
        /** @type {?} */
        const props = new ModalBaseOptions();
        /** @type {?} */
        const optionalParams = [
            'visible',
            'focus',
            'prefixCls',
            'animated',
            'closable',
            'maskClosable',
            'onClose',
            'transparent',
            'popup',
            'animationType',
            'title',
            'footer',
            'platform',
            'className',
            'wrapClassName',
            'message',
            'actions',
            'callbackOrActions',
            'type',
            'defaultValue',
            'placeholders',
            'operation',
            'transitionName',
            'maskTransitionName',
            'close'
        ];
        config = Object.assign(options, config, {
            close: (/**
             * @return {?}
             */
            () => {
                if (config.maskClosable || config.closable) {
                    ModalService.closeWithAnimation();
                }
            })
        });
        optionalParams.forEach((/**
         * @param {?} key
         * @return {?}
         */
        key => {
            if (config[key] !== undefined) {
                props[key] = config[key];
            }
        }));
        return props;
    }
    /**
     * @param {?} props
     * @return {?}
     */
    static _open(props) {
        /** @type {?} */
        const childInjector = Injector.create([
            {
                provide: ModalOptions,
                useValue: props
            }
        ]);
        setTimeout((/**
         * @return {?}
         */
        () => {
            ModalService.modalRef = ModalService.showPopup('ModalServiceComponent', ModalServiceComponent, childInjector);
        }), 0);
    }
    /**
     * @return {?}
     */
    static closeWithAnimation() {
        /** @type {?} */
        const options = new ModalBaseOptions();
        ModalService.modalRef.instance.transitionName = `${options.transitionName}-leave ${options.transitionName}-leave-active`;
        ModalService.modalRef.instance.maskTransitionName = `${options.maskTransitionName}-leave ${options.maskTransitionName}-leave-active`;
        setTimeout((/**
         * @return {?}
         */
        () => {
            ModalService.close();
        }), 200);
    }
    /**
     * @param {?=} title
     * @param {?=} message
     * @param {?=} actions
     * @param {?=} platform
     * @return {?}
     */
    static alert(title, message, actions, platform) {
        /** @type {?} */
        const options = new AlertOptions();
        options.visible = true;
        options.transparent = true;
        options.closable = false;
        options.maskClosable = false;
        options.platform = 'ios';
        /** @type {?} */
        const footer = getFooter(actions);
        /** @type {?} */
        const config = Object.assign({
            title: title,
            message: message,
            footer: footer,
            actions: footer,
            platform: platform ? platform : 'ios'
        });
        /** @type {?} */
        const props = ModalService._initConfig(config, options);
        return ModalService._open(props);
    }
    /**
     * @param {?=} title
     * @param {?=} message
     * @param {?=} callbackOrActions
     * @param {?=} type
     * @param {?=} defaultValue
     * @param {?=} placeholders
     * @param {?=} platform
     * @return {?}
     */
    static prompt(title, message, callbackOrActions, type, defaultValue, placeholders, platform) {
        /** @type {?} */
        const options = new ModalOptions();
        options.visible = true;
        options.transparent = true;
        options.closable = false;
        options.maskClosable = false;
        options.className = 'am-modal-alert-content';
        options.defaultValue = defaultValue || ['', ''];
        options.placeholders = placeholders;
        (options.type = type ? type : 'default'), (options.platform = platform ? platform : 'ios');
        /**
         * @param {?} self
         * @param {?} func
         * @return {?}
         */
        function getArgs(self, func) {
            /** @type {?} */
            const text = ModalService.modalRef.instance.data.text || options.defaultValue[0];
            /** @type {?} */
            const password = ModalService.modalRef.instance.data.password || options.defaultValue[1];
            if (type === 'login-password') {
                return func(text, password);
            }
            else if (type === 'secure-text') {
                return func(password);
            }
            return func(text);
        }
        /** @type {?} */
        let actions;
        if (typeof callbackOrActions === 'function') {
            actions = [
                { text: 'Cancel' },
                {
                    text: 'OK',
                    onPress: (/**
                     * @return {?}
                     */
                    () => {
                        getArgs(this, callbackOrActions);
                    })
                }
            ];
        }
        else {
            actions = callbackOrActions.map((/**
             * @param {?} item
             * @return {?}
             */
            item => {
                return {
                    text: item.text,
                    onPress: (/**
                     * @return {?}
                     */
                    () => {
                        if (item.onPress) {
                            return getArgs(this, item.onPress);
                        }
                    })
                };
            }));
        }
        /** @type {?} */
        const footer = getFooter(actions);
        /** @type {?} */
        const config = Object.assign({
            title: title,
            message: message,
            type: type ? type : 'default',
            footer: footer,
            actions: footer,
            platform: platform ? platform : 'ios'
        });
        /** @type {?} */
        const props = ModalService._initConfig(config, options);
        return ModalService._open(props);
    }
    /**
     * @param {?=} actions
     * @param {?=} platform
     * @return {?}
     */
    static operation(actions, platform) {
        /** @type {?} */
        const options = new ModalOptions();
        options.visible = true;
        options.transparent = true;
        options.closable = false;
        options.maskClosable = false;
        options.operation = true;
        options.className = 'am-modal-operation';
        /** @type {?} */
        const footer = getFooter(actions);
        /** @type {?} */
        const config = Object.assign({
            footer: footer,
            actions: footer,
            platform: platform ? platform : 'ios'
        });
        /** @type {?} */
        const props = ModalService._initConfig(config, options);
        return ModalService._open(props);
    }
    /**
     * @return {?}
     */
    static close() {
        ModalService.hidePopup('ModalServiceComponent');
    }
}
ModalService.modalRef = null;
ModalService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] },
    { type: Injectable }
];
/**
 * @param {?} actions
 * @return {?}
 */
function getFooter(actions) {
    /** @type {?} */
    let action = actions ? actions : [{ text: 'OK', onPress: (/**
             * @return {?}
             */
            () => { }) }];
    return action.map((/**
     * @param {?} button
     * @return {?}
     */
    (button) => {
        /** @type {?} */
        const orginPress = button.onPress || (/**
         * @return {?}
         */
        function () { });
        button.onPress = (/**
         * @return {?}
         */
        () => {
            /** @type {?} */
            const res = orginPress();
            if (res && res.then) {
                res.then((/**
                 * @return {?}
                 */
                () => {
                    ModalService.closeWithAnimation();
                }));
            }
            else {
                ModalService.closeWithAnimation();
            }
        });
        return button;
    }));
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ModalModule {
}
ModalModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    ListModule,
                    WingBlankModule,
                    WhiteSpaceModule,
                    ButtonModule,
                    InputItemModule,
                    FormsModule,
                    ReactiveFormsModule,
                    OverlayModule
                ],
                exports: [ModalComponent, ModalServiceComponent],
                declarations: [ModalComponent, ModalServiceComponent],
                entryComponents: [ModalServiceComponent],
                providers: [AlertOptions, ModalService, PopupService]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PopoverOptions {
    constructor() {
        this.showArrow = false;
        this.mask = false;
        this.placement = 'bottom';
        this.appendToBody = false;
        this.className = '';
        this.autoClose = true;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PopoverComponentOptions extends PopoverOptions {
}
PopoverComponentOptions.decorators = [
    { type: Injectable }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PopoverComponent {
    /**
     * @param {?} options
     */
    constructor(options) {
        this.options = options;
        this.defaultProps = {
            prefixCls: 'am-popover'
        };
        this.maskCls = {};
        this.popoverCls = {};
    }
    /**
     * @return {?}
     */
    setClassMap() {
        this.maskCls = {
            [`${this.defaultProps.prefixCls}-mask`]: this.options.mask,
            [`${this.defaultProps.prefixCls}-mask-hidden`]: !this.options.mask
        };
        this.popoverCls = {
            [`${this.defaultProps.prefixCls}`]: true,
            [`${this.defaultProps.prefixCls}-placement-${this.options.placement}`]: true,
            [`${this.defaultProps.prefixCls}-${this.options.className}`]: true
        };
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.setClassMap();
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.options.onAfterViewInit();
    }
}
PopoverComponent.decorators = [
    { type: Component, args: [{
                selector: 'Popover',
                template: "<ng-content></ng-content>\n<div [ngClass]=\"maskCls\" (click)=\"options.hidePopover()\"></div>\n<div [ngClass]=\"popoverCls\" style=\"color: currentcolor;\">\n  <div class=\"{{defaultProps.prefixCls}}-content\">\n    <div *ngIf=\"options.showArrow\" class=\"{{defaultProps.prefixCls}}-arrow\"></div>\n    <div class=\"{{defaultProps.prefixCls}}-inner\">\n      <div class=\"{{defaultProps.prefixCls}}-inner-wrapper\">\n        <ng-template [ngTemplateOutlet]=\"options.overlay\" [ngTemplateOutletContext]=\"{options: options}\">\n        </ng-template>\n      </div>\n    </div>\n  </div>\n</div>",
                encapsulation: ViewEncapsulation.None
            }] }
];
/** @nocollapse */
PopoverComponent.ctorParameters = () => [
    { type: PopoverComponentOptions }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} element
 * @return {?}
 */
function getAllStyles(element) { return window.getComputedStyle(element); }
/**
 * @param {?} element
 * @param {?} prop
 * @return {?}
 */
function getStyle(element, prop) { return getAllStyles(element)[prop]; }
/**
 * @param {?} element
 * @return {?}
 */
function isStaticPositioned(element) {
    return (getStyle(element, 'position') || 'static') === 'static';
}
/**
 * @param {?} element
 * @return {?}
 */
function getOffsetParent(element) {
    /** @type {?} */
    let offsetParentEl = element.offsetParent || document.documentElement;
    while (offsetParentEl && offsetParentEl !== document.documentElement && isStaticPositioned(offsetParentEl)) {
        offsetParentEl = offsetParentEl.offsetParent;
    }
    return offsetParentEl || document.documentElement;
}
/**
 * @param {?} element
 * @param {?} round
 * @return {?}
 */
function getOffset(element, round) {
    if (round === void 0) {
        round = true;
    }
    /** @type {?} */
    let elBcr = element.getBoundingClientRect();
    /** @type {?} */
    let viewportOffset = {
        top: window.pageYOffset - document.documentElement.clientTop,
        left: window.pageXOffset - document.documentElement.clientLeft
    };
    /** @type {?} */
    let elOffset = {
        height: elBcr.height || element.offsetHeight,
        width: elBcr.width || element.offsetWidth,
        top: elBcr.top + viewportOffset.top,
        bottom: elBcr.bottom + viewportOffset.top,
        left: elBcr.left + viewportOffset.left,
        right: elBcr.right + viewportOffset.left
    };
    if (round) {
        elOffset.height = Math.round(elOffset.height);
        elOffset.width = Math.round(elOffset.width);
        elOffset.top = Math.round(elOffset.top);
        elOffset.bottom = Math.round(elOffset.bottom);
        elOffset.left = Math.round(elOffset.left);
        elOffset.right = Math.round(elOffset.right);
    }
    return elOffset;
}
/**
 * @param {?} element
 * @param {?} round
 * @return {?}
 */
function getPosition(element, round) {
    if (round === void 0) {
        round = true;
    }
    /** @type {?} */
    let elPosition;
    /** @type {?} */
    let parentOffset = { width: 0, height: 0, top: 0, bottom: 0, left: 0, right: 0 };
    if (getStyle(element, 'position') === 'fixed') {
        elPosition = element.getBoundingClientRect();
    }
    else {
        /** @type {?} */
        let offsetParentEl = getOffsetParent(element);
        elPosition = getOffset(element, false);
        if (offsetParentEl !== document.documentElement) {
            parentOffset = getOffset(offsetParentEl, false);
        }
        parentOffset.top += offsetParentEl.clientTop;
        parentOffset.left += offsetParentEl.clientLeft;
    }
    elPosition.top -= parentOffset.top;
    elPosition.bottom -= parentOffset.top;
    elPosition.left -= parentOffset.left;
    elPosition.right -= parentOffset.left;
    if (round) {
        elPosition.top = Math.round(elPosition.top);
        elPosition.bottom = Math.round(elPosition.bottom);
        elPosition.left = Math.round(elPosition.left);
        elPosition.right = Math.round(elPosition.right);
    }
    return elPosition;
}
/**
 * @param {?} hostElement
 * @param {?} targetElement
 * @param {?} placement
 * @param {?} appendToBody
 * @return {?}
 */
function getPositionElements(hostElement, targetElement, placement, appendToBody) {
    /** @type {?} */
    let hostElPosition = appendToBody ? getOffset(hostElement, false) : getPosition(hostElement, false);
    /** @type {?} */
    let targetElStyles = getAllStyles(targetElement);
    /** @type {?} */
    let targetElBCR = targetElement.getBoundingClientRect();
    /** @type {?} */
    let placementPrimary = placement.split('-')[0] || 'top';
    /** @type {?} */
    let placementSecondary = placement.split('-')[1] || 'center';
    /** @type {?} */
    let targetElPosition = {
        'height': targetElBCR.height || targetElement.offsetHeight,
        'width': targetElBCR.width || targetElement.offsetWidth,
        'top': 0,
        'bottom': targetElBCR.height || targetElement.offsetHeight,
        'left': 0,
        'right': targetElBCR.width || targetElement.offsetWidth
    };
    switch (placementPrimary) {
        case 'top':
            targetElPosition.top =
                hostElPosition.top - (targetElement.offsetHeight + parseFloat(targetElStyles.marginBottom));
            break;
        case 'bottom':
            targetElPosition.top = hostElPosition.top + hostElPosition.height;
            break;
        case 'left':
            targetElPosition.left =
                hostElPosition.left - (targetElement.offsetWidth + parseFloat(targetElStyles.marginRight));
            break;
        case 'right':
            targetElPosition.left = hostElPosition.left + hostElPosition.width;
            break;
    }
    switch (placementSecondary) {
        case 'top':
            targetElPosition.top = hostElPosition.top;
            break;
        case 'bottom':
            targetElPosition.top = hostElPosition.top + hostElPosition.height - targetElement.offsetHeight;
            break;
        case 'left':
            targetElPosition.left = hostElPosition.left;
            break;
        case 'right':
            targetElPosition.left = hostElPosition.left + hostElPosition.width - targetElement.offsetWidth;
            break;
        case 'center':
            if (placementPrimary === 'top' || placementPrimary === 'bottom') {
                targetElPosition.left = hostElPosition.left + hostElPosition.width / 2 - targetElement.offsetWidth / 2;
            }
            else {
                targetElPosition.top = hostElPosition.top + hostElPosition.height / 2 - targetElement.offsetHeight / 2;
            }
            break;
    }
    targetElPosition.top = Math.round(targetElPosition.top);
    targetElPosition.bottom = Math.round(targetElPosition.bottom);
    targetElPosition.left = Math.round(targetElPosition.left);
    targetElPosition.right = Math.round(targetElPosition.right);
    return targetElPosition;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PopoverDirective {
    /**
     * @param {?} _viewContainerRef
     * @param {?} _elm
     * @param {?} _defaultOptions
     * @param {?} _cfr
     * @param {?} _renderer
     */
    constructor(_viewContainerRef, _elm, _defaultOptions, _cfr, _renderer) {
        this._viewContainerRef = _viewContainerRef;
        this._elm = _elm;
        this._defaultOptions = _defaultOptions;
        this._cfr = _cfr;
        this._renderer = _renderer;
        this._eventListeners = [];
        this.onVisibleChange = new EventEmitter(true);
        this.onSelect = new EventEmitter();
    }
    /**
     * @return {?}
     */
    togglePopover() {
        if (!this.popover) {
            this.showPopover();
        }
        else {
            this.hidePopover();
        }
    }
    /**
     * @param {?} placement
     * @return {?}
     */
    positionMap(placement) {
        switch (placement) {
            case 'topLeft':
                return 'top-left';
            case 'topRight':
                return 'top-right';
            case 'bottomLeft':
                return 'bottom-left';
            case 'bottomRight':
                return 'bottom-right';
            case 'leftTop':
                return 'left-top';
            case 'leftBottom':
                return 'left-bottom';
            case 'rightTop':
                return 'right-top';
            case 'rightBottom':
                return 'right-bottom';
            case 'fullScreen':
            case 'landScape':
                return 'bottom';
            default:
                return placement;
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() { }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes.visible && changes.visible.currentValue) {
            setTimeout((/**
             * @return {?}
             */
            () => {
                this.showPopover();
            }), 0);
        }
        else {
            setTimeout((/**
             * @return {?}
             */
            () => {
                this.hidePopover();
            }), 0);
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.hidePopover();
    }
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    onDocumentClick(event) {
        if (this.popover &&
            !this._elm.nativeElement.contains(event.target) &&
            !this.popover.location.nativeElement.contains(event.target)) {
            this.hidePopover();
        }
    }
    /**
     * @private
     * @return {?}
     */
    showPopover() {
        if (!this.popover) {
            setTimeout((/**
             * @return {?}
             */
            () => {
                this._eventListeners = [
                    this._renderer.listen('document', 'click', (/**
                     * @param {?} event
                     * @return {?}
                     */
                    (event) => this.onDocumentClick(event))),
                    this._renderer.listen('document', 'touchend', (/**
                     * @param {?} event
                     * @return {?}
                     */
                    (event) => this.onDocumentClick(event))),
                    this._renderer.listen('window', 'resize', (/**
                     * @return {?}
                     */
                    () => this.positionPopover()))
                ];
            }));
            /** @type {?} */
            const options = new PopoverComponentOptions();
            options.placement = this.placement;
            Object.assign(options, this._defaultOptions, {
                hidePopover: (/**
                 * @param {?} event
                 * @return {?}
                 */
                (event) => {
                    this.hidePopover();
                }),
                onAfterViewInit: (/**
                 * @return {?}
                 */
                () => {
                    this.positionPopover();
                    /** @type {?} */
                    const children = document.getElementsByClassName('am-popover-inner-wrapper')[0].children;
                    if (children.length > 0) {
                        // 首先我们检查它是否包含子节点
                        for (let i = 0; i < children.length; i++) {
                            children[i].id = `${i}`;
                            children[i].addEventListener('click', (/**
                             * @return {?}
                             */
                            () => {
                                if (this.onSelect) {
                                    this.onSelect.emit(children[i]);
                                    if (options.autoClose) {
                                        this.hidePopover();
                                    }
                                }
                            }), false);
                        }
                    }
                })
            });
            /** @type {?} */
            const optionalParams = [
                'mask',
                'showArrow',
                'placement',
                'appendToBody',
                'overlay',
                'className',
                'autoClose'
            ];
            optionalParams.forEach((/**
             * @param {?} param
             * @return {?}
             */
            param => {
                if (typeof this[param] !== 'undefined') {
                    ((/** @type {?} */ (options)))[param] = this[param];
                }
            }));
            /** @type {?} */
            const componentFactory = this._cfr.resolveComponentFactory(PopoverComponent);
            /** @type {?} */
            const childInjector = Injector.create([
                {
                    provide: PopoverComponentOptions,
                    useValue: options
                }
            ], this._viewContainerRef.parentInjector);
            this.popover = this._viewContainerRef.createComponent(componentFactory, this._viewContainerRef.length, childInjector);
            if (options.appendToBody) {
                document.body.appendChild(this.popover.location.nativeElement);
            }
            this.onVisibleChange.emit(true);
        }
    }
    /**
     * @private
     * @return {?}
     */
    positionPopover() {
        if (this.popover) {
            /** @type {?} */
            const popoverElement = this.popover.location.nativeElement.children[1];
            /** @type {?} */
            const popoverPosition = getPositionElements(this._elm.nativeElement, popoverElement, this.positionMap(this.placement) || this._defaultOptions.placement, this.appendToBody || this._defaultOptions.appendToBody);
            if (this.placement === 'landScape') {
                this._renderer.setStyle(popoverElement, 'top', `${popoverPosition.top}px`);
                this._renderer.setStyle(popoverElement, 'left', `0px`);
                this._renderer.setStyle(popoverElement, 'width', `${window.innerWidth}px`);
                this._renderer.setStyle(popoverElement, 'max-height', `${window.innerHeight - popoverPosition.height}px`);
            }
            else if (this.placement === 'fullScreen') {
                this._renderer.setStyle(popoverElement, 'top', `${0}px`);
                this._renderer.setStyle(popoverElement, 'left', `0px`);
                this._renderer.setStyle(popoverElement, 'width', `${window.innerWidth}px`);
                this._renderer.setStyle(popoverElement, 'max-height', `${window.innerHeight - popoverPosition.height}px`);
            }
            else {
                this._renderer.setStyle(popoverElement, 'top', `${popoverPosition.top}px`);
                this._renderer.setStyle(popoverElement, 'left', `${popoverPosition.left}px`);
            }
        }
    }
    /**
     * @private
     * @return {?}
     */
    hidePopover() {
        if (this.popover) {
            this.popover.destroy();
            delete this.popover;
            this.onVisibleChange.emit(false);
            this._eventListeners.forEach((/**
             * @param {?} fn
             * @return {?}
             */
            fn => fn()));
            this._eventListeners = [];
        }
    }
}
PopoverDirective.decorators = [
    { type: Directive, args: [{
                selector: '[Popover], [nzm-popover]',
                providers: [PopoverOptions]
            },] }
];
/** @nocollapse */
PopoverDirective.ctorParameters = () => [
    { type: ViewContainerRef },
    { type: ElementRef },
    { type: PopoverOptions },
    { type: ComponentFactoryResolver },
    { type: Renderer2 }
];
PopoverDirective.propDecorators = {
    mask: [{ type: Input }],
    showArrow: [{ type: Input }],
    visible: [{ type: Input }],
    placement: [{ type: Input }],
    overlay: [{ type: Input }],
    onVisibleChange: [{ type: Output }],
    onSelect: [{ type: Output }],
    appendToBody: [{ type: Input }],
    className: [{ type: Input }],
    autoClose: [{ type: Input }],
    togglePopover: [{ type: HostListener, args: ['click',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @param {?} userOptions
 * @return {?}
 */
function PopoverOptionsFactory(userOptions) {
    /** @type {?} */
    const options = new PopoverOptions();
    Object.assign(options, userOptions);
    return options;
}
class PopoverModule {
}
PopoverModule.decorators = [
    { type: NgModule, args: [{
                declarations: [PopoverDirective, PopoverComponent],
                imports: [CommonModule],
                exports: [PopoverDirective, PopoverComponent],
                entryComponents: [PopoverComponent],
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NavBarComponent {
    constructor() {
        this.defaultProps = {
            prefixCls: 'am-navbar',
            mode: 'dark',
            onLeftClick: (/**
             * @return {?}
             */
            () => { })
        };
        this.navbarCls = {};
        this.isIconString = true;
        this.isLeftContentString = true;
        this.isRightContentString = true;
        this.onLeftClick = new EventEmitter();
        this.amNavbar = true;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set mode(value) {
        this.defaultProps.mode = value;
        this.amNavbarLight = this.defaultProps.mode === 'light';
        this.amNavbardark = this.defaultProps.mode === 'dark';
    }
    /**
     * @return {?}
     */
    get icon() {
        return this._icon;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set icon(value) {
        if (value instanceof TemplateRef) {
            this.isIconString = false;
        }
        else {
            this.isIconString = true;
        }
        this._icon = value;
    }
    /**
     * @return {?}
     */
    get leftContent() {
        return this._leftContent;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set leftContent(value) {
        if (value instanceof TemplateRef) {
            this.isLeftContentString = false;
        }
        else {
            this.isLeftContentString = true;
        }
        this._leftContent = value;
    }
    /**
     * @return {?}
     */
    get rightContent() {
        return this._rightContent;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set rightContent(value) {
        if (value instanceof TemplateRef) {
            this.isRightContentString = false;
        }
        else {
            this.isRightContentString = true;
        }
        this._rightContent = value;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    click(event) {
        this.onLeftClick.emit(event);
    }
}
NavBarComponent.decorators = [
    { type: Component, args: [{
                selector: 'Navbar, nzm-nav-bar',
                template: "<div role=\"button\" class=\"{{defaultProps.prefixCls}}-left\" (click)=\"click($event)\">\n  <ng-template *ngIf=\"!isLeftContentString\" [ngTemplateOutlet]=\"leftContent\"></ng-template>\n  <span *ngIf=\"icon\" class=\"{{defaultProps.prefixCls}}-left-icon\" aria-hidden=\"true\">\n    <Icon *ngIf=\"isIconString\" [type]=\"icon\"></Icon>\n    <ng-template *ngIf=\"!isIconString\" [ngTemplateOutlet]=\"icon\"></ng-template>\n  </span>\n  {{isLeftContentString ? leftContent: null}}\n</div>\n<div class=\"{{defaultProps.prefixCls}}-title\">\n  <ng-content></ng-content>\n</div>\n<div class=\"{{defaultProps.prefixCls}}-right\">\n  {{isRightContentString ? rightContent: null}}\n  <ng-template *ngIf=\"!isRightContentString\" [ngTemplateOutlet]=\"rightContent\"></ng-template>\n</div>"
            }] }
];
/** @nocollapse */
NavBarComponent.ctorParameters = () => [];
NavBarComponent.propDecorators = {
    mode: [{ type: Input }],
    icon: [{ type: Input }],
    leftContent: [{ type: Input }],
    rightContent: [{ type: Input }],
    onLeftClick: [{ type: Output }],
    amNavbar: [{ type: HostBinding, args: ['class.am-navbar',] }],
    amNavbarLight: [{ type: HostBinding, args: ['class.am-navbar-light',] }],
    amNavbardark: [{ type: HostBinding, args: ['class.am-navbar-dark',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NavBarModule {
}
NavBarModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, IconModule],
                exports: [NavBarComponent],
                declarations: [NavBarComponent]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// 同步自 'rmc-calendar/lib/locale/en_US';
var Calendar = {
    title: 'Calendar',
    today: 'Today',
    month: 'Month',
    year: 'Year',
    am: 'AM',
    pm: 'PM',
    dateTimeFormat: 'MM/dd/yyyy w hh:mm',
    dateFormat: 'yyyy/MM/dd w',
    noChoose: 'No Choose',
    week: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fir', 'Sat'],
    clear: 'Clear',
    selectTime: 'Select Time',
    selectStartTime: 'Select Start Time',
    selectEndTime: 'Select End Time',
    start: 'Start',
    end: 'End',
    begin: 'Start',
    over: 'End',
    begin_over: 'S/E',
    confirm: 'Confirm',
    monthTitle: 'yyyy/MM',
    loadPrevMonth: 'Load Prev Month',
    yesterday: 'Yesterday',
    lastWeek: 'Last Week',
    lastMonth: 'Last Month'
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const mergeDateTime = (/**
 * @param {?=} date
 * @param {?=} time
 * @return {?}
 */
(date, time) => {
    date = date || new Date();
    if (!time)
        return date;
    return new Date(date.getFullYear(), date.getMonth(), date.getDate(), time.getHours(), time.getMinutes(), time.getSeconds());
});
/** @type {?} */
const formatDate = (/**
 * @param {?} date
 * @param {?} format
 * @param {?=} locale
 * @return {?}
 */
(date, format, locale) => {
    /** @type {?} */
    const week = locale && locale.week;
    /** @type {?} */
    let o = {
        'M+': date.getMonth() + 1,
        'd+': date.getDate(),
        'h+': date.getHours(),
        'm+': date.getMinutes(),
        's+': date.getSeconds(),
        'q+': Math.floor((date.getMonth() + 3) / 3),
        'w+': week && week[date.getDay()],
        S: date.getMilliseconds()
    };
    if (/(y+)/.test(format))
        format = format.replace(RegExp.$1, (date.getFullYear() + '').substr(4 - RegExp.$1.length));
    for (let k in o) {
        if (new RegExp('(' + k + ')').test(format)) {
            format = format.replace(RegExp.$1, RegExp.$1.length == 1 ? o[k] : ('00' + o[k]).substr(('' + o[k]).length));
        }
    }
    return format;
});
/** @type {?} */
const isSameDate = (/**
 * @param {?} day_one
 * @param {?} day_two
 * @return {?}
 */
(day_one, day_two) => {
    if (!day_one || !day_two) {
        console.error('isSameDate function need two params');
        return 'need two params';
    }
    /** @type {?} */
    const compareDate = day_one.getDate() === day_two.getDate();
    /** @type {?} */
    const compareMonth = day_one.getMonth() === day_two.getMonth();
    /** @type {?} */
    const compareYear = day_one.getFullYear() === day_two.getFullYear();
    return compareDate && compareMonth && compareYear;
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var DateModels;
(function (DateModels) {
    let SelectType;
    (function (SelectType) {
        SelectType[SelectType["None"] = 0] = "None";
        SelectType[SelectType["Single"] = 1] = "Single";
        SelectType[SelectType["All"] = 2] = "All";
        SelectType[SelectType["Only"] = 3] = "Only";
        SelectType[SelectType["Start"] = 4] = "Start";
        SelectType[SelectType["Middle"] = 5] = "Middle";
        SelectType[SelectType["End"] = 6] = "End";
    })(SelectType = DateModels.SelectType || (DateModels.SelectType = {}));
    /**
     * @record
     */
    function Locale() { }
    DateModels.Locale = Locale;
    /**
     * @record
     */
    function CellData() { }
    DateModels.CellData = CellData;
    /**
     * @record
     */
    function ExtraData() { }
    DateModels.ExtraData = ExtraData;
    /**
     * @record
     */
    function MonthData() { }
    DateModels.MonthData = MonthData;
})(DateModels || (DateModels = {}));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CalendarDatePickerBaseComponent {
    constructor() {
        this.props = (/** @type {?} */ ({
            prefixCls: 'rmc-calendar',
            infinite: false,
            infiniteOpt: false,
            defaultDate: new Date(),
            initalMonths: 6,
            locale: zhCN
        }));
        this.state = {
            months: []
        };
        this.visibleMonth = [];
        this.getDateWithoutTime = (/**
         * @param {?=} date
         * @return {?}
         */
        (date) => {
            if (!date)
                return 0;
            return +new Date(date.getFullYear(), date.getMonth(), date.getDate());
        });
        this.genWeekData = (/**
         * @param {?} firstDate
         * @return {?}
         */
        (firstDate) => {
            /** @type {?} */
            const minDateTime = this.getDateWithoutTime(this.props.minDate);
            /** @type {?} */
            const maxDateTime = this.getDateWithoutTime(this.props.maxDate) || Number.POSITIVE_INFINITY;
            /** @type {?} */
            const weeks = [];
            /** @type {?} */
            const nextMonth = this.getMonthDate(firstDate, 1).firstDate;
            /** @type {?} */
            let currentDay = firstDate;
            /** @type {?} */
            let currentWeek = [];
            weeks.push(currentWeek);
            /** @type {?} */
            let startWeekday = currentDay.getDay();
            if (startWeekday > 0) {
                for (let i = 0; i < startWeekday; i++) {
                    currentWeek.push((/** @type {?} */ ({})));
                }
            }
            while (currentDay < nextMonth) {
                if (currentWeek.length === 7) {
                    currentWeek = [];
                    weeks.push(currentWeek);
                }
                /** @type {?} */
                const dayOfMonth = currentDay.getDate();
                /** @type {?} */
                const tick = +currentDay;
                currentWeek.push({
                    tick,
                    dayOfMonth,
                    selected: DateModels.SelectType.None,
                    isFirstOfMonth: dayOfMonth === 1,
                    isLastOfMonth: false,
                    outOfDate: tick < minDateTime || tick > maxDateTime
                });
                currentDay = new Date(currentDay.getTime() + 3600 * 24 * 1000);
            }
            currentWeek[currentWeek.length - 1].isLastOfMonth = true;
            return weeks;
        });
        this.selectDateRange = (/**
         * @param {?} startDate
         * @param {?=} endDate
         * @param {?=} clear
         * @return {?}
         */
        (startDate, endDate, clear = false) => {
            const { getDateExtra, type, onSelectHasDisableDate } = this.props;
            if (type === 'one') {
                endDate = undefined;
            }
            /** @type {?} */
            const time1 = this.getDateWithoutTime(startDate);
            /** @type {?} */
            const time2 = this.getDateWithoutTime(endDate);
            /** @type {?} */
            const startDateTick = !time2 || time1 < time2 ? time1 : time2;
            /** @type {?} */
            const endDateTick = time2 && time1 > time2 ? time1 : time2;
            /** @type {?} */
            const startMonthDate = this.getMonthDate(new Date(startDateTick)).firstDate;
            /** @type {?} */
            const endMonthDate = endDateTick ? new Date(endDateTick) : this.getMonthDate(new Date(startDateTick)).lastDate;
            /** @type {?} */
            let unuseable = [];
            /** @type {?} */
            let needUpdate = false;
            this.state.months
                .filter((/**
             * @param {?} m
             * @return {?}
             */
            m => {
                return m.firstDate >= startMonthDate && m.firstDate <= endMonthDate;
            }))
                .forEach((/**
             * @param {?} m
             * @return {?}
             */
            m => {
                m.weeks.forEach((/**
                 * @param {?} w
                 * @return {?}
                 */
                w => w
                    .filter((/**
                 * @param {?} d
                 * @return {?}
                 */
                d => {
                    if (!endDateTick) {
                        return d.tick && this.inDate(startDateTick, d.tick);
                    }
                    else {
                        return d.tick && d.tick >= startDateTick && d.tick <= endDateTick;
                    }
                }))
                    .forEach((/**
                 * @param {?} d
                 * @return {?}
                 */
                d => {
                    /** @type {?} */
                    const oldValue = d.selected;
                    if (clear) {
                        d.selected = DateModels.SelectType.None;
                    }
                    else {
                        /** @type {?} */
                        const info = (getDateExtra && getDateExtra(new Date(d.tick))) || {};
                        if (d.outOfDate || info.disable) {
                            unuseable.push(d.tick);
                        }
                        if (this.inDate(startDateTick, d.tick)) {
                            if (type === 'one') {
                                d.selected = DateModels.SelectType.Single;
                            }
                            else if (!endDateTick) {
                                d.selected = DateModels.SelectType.Only;
                            }
                            else if (startDateTick !== endDateTick) {
                                d.selected = DateModels.SelectType.Start;
                            }
                            else {
                                d.selected = DateModels.SelectType.All;
                            }
                        }
                        else if (this.inDate(endDateTick, d.tick)) {
                            d.selected = DateModels.SelectType.End;
                        }
                        else {
                            d.selected = DateModels.SelectType.Middle;
                        }
                    }
                    needUpdate = needUpdate || d.selected !== oldValue;
                }))));
                if (needUpdate && m.componentRef) {
                    m.componentRef.updateWeeks();
                }
            }));
            if (unuseable.length > 0) {
                if (onSelectHasDisableDate) {
                    onSelectHasDisableDate(unuseable.map((/**
                     * @param {?} tick
                     * @return {?}
                     */
                    tick => new Date(tick))));
                }
                else {
                    console.warn('Unusable date. You can handle by onSelectHasDisableDate.', unuseable);
                }
            }
        });
        this.computeVisible = (/**
         * @param {?} clientHeight
         * @param {?} scrollTop
         * @return {?}
         */
        (clientHeight, scrollTop) => {
            /** @type {?} */
            let needUpdate = false;
            /** @type {?} */
            const MAX_VIEW_PORT = clientHeight * 2;
            /** @type {?} */
            const MIN_VIEW_PORT = clientHeight;
            // 大缓冲区外过滤规则
            /** @type {?} */
            const filterFunc = (/**
             * @param {?} vm
             * @return {?}
             */
            (vm) => vm.y &&
                vm.height &&
                (vm.y + vm.height > scrollTop - MAX_VIEW_PORT && vm.y < scrollTop + clientHeight + MAX_VIEW_PORT));
            if (this.props.infiniteOpt && this.visibleMonth.length > 12) {
                this.visibleMonth = this.visibleMonth.filter(filterFunc).sort((/**
                 * @param {?} a
                 * @param {?} b
                 * @return {?}
                 */
                (a, b) => +a.firstDate - +b.firstDate));
            }
            // 当小缓冲区不满时填充
            if (this.visibleMonth.length > 0) {
                /** @type {?} */
                const last = this.visibleMonth[this.visibleMonth.length - 1];
                if (last.y !== undefined && last.height && last.y + last.height < scrollTop + clientHeight + MIN_VIEW_PORT) {
                    /** @type {?} */
                    const lastIndex = this.state.months.indexOf(last);
                    for (let i = 1; i <= 2; i++) {
                        /** @type {?} */
                        const index = lastIndex + i;
                        if (index < this.state.months.length && this.visibleMonth.indexOf(this.state.months[index]) < 0) {
                            this.visibleMonth.push(this.state.months[index]);
                        }
                        else {
                            this.canLoadNext() && this.genMonthData(undefined, 1);
                        }
                    }
                    needUpdate = true;
                }
                /** @type {?} */
                const first = this.visibleMonth[0];
                if (first.y !== undefined && first.height && first.y > scrollTop - MIN_VIEW_PORT) {
                    /** @type {?} */
                    const firstIndex = this.state.months.indexOf(first);
                    for (let i = 1; i <= 2; i++) {
                        /** @type {?} */
                        const index = firstIndex - i;
                        if (index >= 0 && this.visibleMonth.indexOf(this.state.months[index]) < 0) {
                            this.visibleMonth.unshift(this.state.months[index]);
                            needUpdate = true;
                        }
                    }
                }
            }
            else if (this.state.months.length > 0) {
                this.visibleMonth = this.state.months.filter(filterFunc);
                needUpdate = true;
            }
            return needUpdate;
        });
        this.createOnScroll = (/**
         * @return {?}
         */
        () => {
            // let timer: any;
            /** @type {?} */
            let clientHeight = 0;
            /** @type {?} */
            let scrollTop = 0;
            return (/**
             * @param {?} data
             * @return {?}
             */
            (data) => {
                const { client, top } = data;
                clientHeight = client;
                scrollTop = top;
                this.computeVisible(clientHeight, scrollTop);
                // 以上方法目前无问题，如果后续有性能问题，改用如下方法，但以下方法会导致刷新稍微延迟现象
                // if (timer) {
                //   return;
                // }
                //
                // timer = setTimeout(() => {
                //   timer = undefined;
                //
                //   if (this.computeVisible(clientHeight, scrollTop)) {
                //     console.log('update dom');
                //   }
                // }, 50);
            });
        });
        this.baseOnCellClick = (/**
         * @param {?} day
         * @return {?}
         */
        (day) => {
            if (!day.tick)
                return;
            this.props.onCellClick && this.props.onCellClick(new Date(day.tick));
        });
    }
    /**
     * @return {?}
     */
    init() {
        const { initalMonths = 6, defaultDate } = this.props;
        for (let i = 0; i < initalMonths; i++) {
            this.canLoadNext() && this.genMonthData(defaultDate, i);
        }
        this.visibleMonth = [...this.state.months];
    }
    /**
     * @param {?} oldValue
     * @param {?} newValue
     * @return {?}
     */
    receiveProps(oldValue, newValue) {
        if (oldValue && newValue) {
            if (oldValue.startDate !== newValue.startDate || oldValue.endDate !== newValue.endDate) {
                if (oldValue.startDate) {
                    this.selectDateRange(oldValue.startDate, oldValue.endDate, true);
                }
                if (newValue.startDate) {
                    this.selectDateRange(newValue.startDate, newValue.endDate);
                }
            }
        }
    }
    /**
     * @param {?=} date
     * @param {?=} addMonth
     * @return {?}
     */
    getMonthDate(date = new Date(), addMonth = 0) {
        /** @type {?} */
        const y = date.getFullYear();
        /** @type {?} */
        const m = date.getMonth();
        return {
            firstDate: new Date(y, m + addMonth, 1),
            lastDate: new Date(y, m + 1 + addMonth, 0)
        };
    }
    /**
     * @return {?}
     */
    canLoadPrev() {
        const { minDate } = this.props;
        return (!minDate ||
            this.state.months.length <= 0 ||
            +this.getMonthDate(minDate).firstDate < +this.state.months[0].firstDate);
    }
    /**
     * @return {?}
     */
    canLoadNext() {
        const { maxDate } = this.props;
        return (!maxDate ||
            this.state.months.length <= 0 ||
            +this.getMonthDate(maxDate).firstDate > +this.state.months[this.state.months.length - 1].firstDate);
    }
    /**
     * @param {?=} date
     * @param {?=} addMonth
     * @return {?}
     */
    genMonthData(date, addMonth = 0) {
        if (!date) {
            date = addMonth >= 0 ? this.state.months[this.state.months.length - 1].firstDate : this.state.months[0].firstDate;
        }
        if (!date) {
            date = new Date();
        }
        const { locale } = this.props;
        const { firstDate, lastDate } = this.getMonthDate(date, addMonth);
        /** @type {?} */
        const weeks = this.genWeekData(firstDate);
        /** @type {?} */
        const title = formatDate(firstDate, locale ? locale.monthTitle : 'yyyy/MM', this.props.locale);
        /** @type {?} */
        const data = (/** @type {?} */ ({
            title,
            firstDate,
            lastDate,
            weeks
        }));
        data.component = this.genMonthComponent(data);
        if (addMonth >= 0) {
            this.state.months.push(data);
        }
        else {
            this.state.months.unshift(data);
        }
        const { startDate, endDate } = this.props;
        if (startDate) {
            this.selectDateRange(startDate, endDate);
        }
        return data;
    }
    /**
     * @param {?} date
     * @param {?} tick
     * @return {?}
     */
    inDate(date, tick) {
        return date <= tick && tick < date + 24 * 3600000;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CalendarDatePickerComponent extends CalendarDatePickerBaseComponent {
    constructor() {
        super();
        this.transform = '';
        this._initDelta = 0;
        this._lastY = 0;
        this._delta = this._initDelta;
        this.amCalendar = true;
        this.datePicker = true;
        this.genMonthComponent = (/**
         * @param {?=} data
         * @return {?}
         */
        (data) => {
            if (!data)
                return;
            return {
                monthData: data,
                locale: this.props.locale,
                rowSize: this.props.rowSize,
                onCellClick: this.baseOnCellClick,
                getDateExtra: this.props.getDateExtra,
                ref: (/**
                 * @param {?} dom
                 * @return {?}
                 */
                dom => {
                    data.componentRef = dom || data.componentRef || undefined;
                    data.updateLayout = (/**
                     * @return {?}
                     */
                    () => {
                        this.computeHeight(data, dom);
                    });
                    data.updateLayout();
                })
            };
        });
        this.computeHeight = (/**
         * @param {?} data
         * @param {?} singleMonth
         * @return {?}
         */
        (data, singleMonth) => {
            if (singleMonth && singleMonth.wrapperDivDOM) {
                if (!data.height && !singleMonth.wrapperDivDOM.clientHeight) {
                    setTimeout((/**
                     * @return {?}
                     */
                    () => this.computeHeight(data, singleMonth)), 500);
                    return;
                }
                data.height = singleMonth.wrapperDivDOM.clientHeight || data.height || 0;
                data.y = singleMonth.wrapperDivDOM.offsetTop || data.y || 0;
            }
        });
        this.setLayout = (/**
         * @param {?} dom
         * @return {?}
         */
        (dom) => {
            if (dom) {
                const { onLayout } = this.props;
                onLayout && onLayout(dom.clientHeight);
                /** @type {?} */
                const scrollHandler = this.createOnScroll();
                dom.onscroll = (/**
                 * @param {?} evt
                 * @return {?}
                 */
                evt => {
                    scrollHandler({
                        client: dom.clientHeight,
                        full: ((/** @type {?} */ (evt.currentTarget))).clientHeight,
                        top: ((/** @type {?} */ (evt.currentTarget))).scrollTop
                    });
                });
            }
        });
        this.setPanel = (/**
         * @param {?} dom
         * @return {?}
         */
        (dom) => {
            this._panel = dom;
        });
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set onCellClick(value) {
        this.props.onCellClick = value;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set endDate(value) {
        /** @type {?} */
        const oldProps = Object.assign({}, this.props);
        this.props.endDate = value;
        this.receiveProps(oldProps, this.props);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set startDate(value) {
        /** @type {?} */
        const oldProps = Object.assign({}, this.props);
        this.props.startDate = value;
        this.receiveProps(oldProps, this.props);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set propsData(value) {
        this.props = Object.assign({}, this.props, value);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set onSelectHasDisableDate(value) {
        this.props.onSelectHasDisableDate = value;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set onLayout(value) {
        this.props.onLayout = value;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onTouchStart(event) {
        this._lastY = event.touches[0].screenY || event.touches[0].pageY;
        this._delta = this._initDelta;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onTouchMove(event) {
        /** @type {?} */
        const ele = event.currentTarget;
        /** @type {?} */
        const isReachTop = ele.scrollTop === 0;
        if (isReachTop) {
            this._delta = (event.touches[0].screenY || event.touches[0].pageY) - this._lastY;
            if (this._delta > 0) {
                event.preventDefault();
                if (this._delta > 80) {
                    this._delta = 80;
                }
            }
            else {
                this._delta = 0;
            }
            this.setTransform(this._panel.style, `translate3d(0,${this._delta}px,0)`);
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onTouchEnd(event) {
        this.onFinish();
    }
    /**
     * @return {?}
     */
    onFinish() {
        if (this._delta > 40 && this.canLoadPrev()) {
            this.genMonthData(this.state.months[0].firstDate, -1);
            this.visibleMonth = this.state.months.slice(0, this.props.initalMonths);
            this.state.months.forEach((/**
             * @param {?} m
             * @return {?}
             */
            m => {
                m.updateLayout && m.updateLayout();
            }));
        }
        this.setTransform(this._panel.style, `translate3d(0,0,0)`);
        this.setTransition(this._panel.style, '.3s');
        setTimeout((/**
         * @return {?}
         */
        () => {
            this._panel && this.setTransition(this._panel.style, '');
        }), 300);
    }
    /**
     * @param {?} nodeStyle
     * @param {?} value
     * @return {?}
     */
    setTransform(nodeStyle, value) {
        this.transform = value;
        nodeStyle.transform = value;
        nodeStyle.webkitTransform = value;
    }
    /**
     * @param {?} nodeStyle
     * @param {?} value
     * @return {?}
     */
    setTransition(nodeStyle, value) {
        nodeStyle.transition = value;
        nodeStyle.webkitTransition = value;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.init();
        this.setLayout(this.layoutDom.nativeElement);
        this.setPanel(this.panelDom.nativeElement);
    }
}
CalendarDatePickerComponent.decorators = [
    { type: Component, args: [{
                selector: 'CalendarDatePicker, nzm-calendar-date-picker',
                template: "<CalendarWeekPanel [locale]=\"props.locale\"></CalendarWeekPanel>\n<div #layout\n     class=\"wrapper\"\n     style=\"overflow-x:hidden;overflow-y:visible;-webkit-overflow-scrolling:touch;\"\n     (touchstart)=\"onTouchStart($event)\"\n     (touchmove)=\"onTouchMove($event)\"\n     (touchend)=\"onTouchEnd($event)\"\n>\n  <div #panel [ngStyle]=\"{transform: transform}\">\n    <div *ngIf=\"canLoadPrev()\" class=\"load-tip\">{{props.locale.loadPrevMonth}}</div>\n    <div class=\"months\">\n      <CalendarSingleMonth *ngFor=\"let item of visibleMonth;let i = index;\"\n                   style=\"display: block;\"\n                   [data]=\"item.component\"\n      ></CalendarSingleMonth>\n    </div>\n  </div>\n</div>\n",
                encapsulation: ViewEncapsulation.None
            }] }
];
/** @nocollapse */
CalendarDatePickerComponent.ctorParameters = () => [];
CalendarDatePickerComponent.propDecorators = {
    layoutDom: [{ type: ViewChild, args: ['layout',] }],
    panelDom: [{ type: ViewChild, args: ['panel',] }],
    onCellClick: [{ type: Input }],
    endDate: [{ type: Input }],
    startDate: [{ type: Input }],
    propsData: [{ type: Input }],
    onSelectHasDisableDate: [{ type: Input }],
    onLayout: [{ type: Input }],
    amCalendar: [{ type: HostBinding, args: ['class.am-calendar',] }],
    datePicker: [{ type: HostBinding, args: ['class.date-picker',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CalendarComponent {
    /**
     * @param {?} _localeProviderService
     */
    constructor(_localeProviderService) {
        this._localeProviderService = _localeProviderService;
        this.isShow = false;
        this.showClear = false;
        this.isSameDate = isSameDate;
        this.props = (/** @type {?} */ ({
            visible: false,
            showHeader: true,
            locale: zhCN,
            pickTime: false,
            showShortcut: false,
            prefixCls: 'rmc-calendar',
            type: 'range',
            defaultTimeValue: new Date(2000, 0, 1, 8)
        }));
        this.state = (/** @type {?} */ ({
            showTimePicker: false,
            timePickerTitle: '',
            startDate: undefined,
            endDate: undefined,
            disConfirmBtn: true,
            clientHight: 0
        }));
        this._unsubscribe$ = new Subject();
        this._dateModelTime = 0;
        this.onChangeFn = (/**
         * @return {?}
         */
        () => { });
        this.onTouchFn = (/**
         * @return {?}
         */
        () => { });
        this.onCancel = new EventEmitter();
        this.onConfirm = new EventEmitter();
        this.onSelectHasDisableDate = new EventEmitter();
        this.class = 'am-calendar';
        this.selectDate = (/**
         * @param {?} date
         * @param {?=} useDateTime
         * @param {?=} oldState
         * @param {?=} props
         * @return {?}
         */
        (date, useDateTime = false, oldState = {}, props = this.props) => {
            if (!date) {
                return (/** @type {?} */ ({}));
            }
            /** @type {?} */
            let newState = (/** @type {?} */ ({}));
            const { type, pickTime, defaultTimeValue, locale = (/** @type {?} */ ({})) } = props;
            /** @type {?} */
            const newDate = pickTime && !useDateTime ? mergeDateTime(date, defaultTimeValue) : date;
            const { startDate, endDate } = oldState;
            switch (type) {
                case 'one':
                    newState = Object.assign({}, newState, { startDate: newDate, disConfirmBtn: false });
                    if (pickTime) {
                        newState = Object.assign({}, newState, { timePickerTitle: locale.selectTime, showTimePicker: true });
                    }
                    break;
                case 'range':
                    if (!startDate || endDate) {
                        newState = Object.assign({}, newState, { startDate: newDate, endDate: undefined, disConfirmBtn: true });
                        if (pickTime) {
                            newState = Object.assign({}, newState, { timePickerTitle: locale.selectStartTime, showTimePicker: true });
                        }
                    }
                    else {
                        newState = Object.assign({}, newState, { timePickerTitle: +newDate >= +startDate || this.isSameDate(startDate, newDate) ? locale.selectEndTime : locale.selectStartTime, disConfirmBtn: false, endDate: pickTime && !useDateTime && (+newDate >= +startDate || this.isSameDate(startDate, newDate))
                                ? new Date(+mergeDateTime(newDate, startDate) + 3600000)
                                : newDate });
                    }
                    break;
            }
            this.writeModelData(date);
            return newState;
        });
        this.onSelectedDate = (/**
         * @param {?} date
         * @return {?}
         */
        (date) => {
            const { startDate, endDate } = this.state;
            const { onSelect } = this.props;
            if (onSelect) {
                /** @type {?} */
                const value = onSelect(date, [startDate, endDate]);
                if (value) {
                    this.shortcutSelect(value[0], value[1]);
                    return;
                }
            }
            this.state = Object.assign({}, this.state, this.selectDate(date, false, { startDate, endDate }));
            this.showClear = !!this.state.startDate;
        });
        this.triggerSelectHasDisableDate = (/**
         * @param {?} date
         * @return {?}
         */
        (date) => {
            this.triggerClear();
            this.onSelectHasDisableDate && this.onSelectHasDisableDate.emit(date);
        });
        this.onClose = (/**
         * @return {?}
         */
        () => {
            this.state = (/** @type {?} */ ({
                showTimePicker: false,
                timePickerTitle: '',
                startDate: undefined,
                endDate: undefined,
                disConfirmBtn: true,
                clientHight: 0
            }));
            this.showClear = !!this.state.startDate;
        });
        this.triggerConfirm = (/**
         * @return {?}
         */
        () => {
            const { startDate, endDate } = this.state;
            if (startDate && endDate && +startDate > +endDate) {
                this.onClose();
                return this.onConfirm && this.onConfirm.emit({ startDate: endDate, endDate: startDate });
            }
            this.onConfirm && this.onConfirm.emit({ startDate, endDate });
            this.onClose();
        });
        this.triggerClear = (/**
         * @return {?}
         */
        () => {
            // 清除数据做延迟，否则同步刷新数据导致报错
            setTimeout((/**
             * @return {?}
             */
            () => {
                this.state = Object.assign({}, this.state, { startDate: undefined, endDate: undefined, showTimePicker: false });
                this.props.onClear && this.props.onClear();
                this.showClear = !!this.state.startDate;
            }), 0);
        });
        this.onTimeChange = (/**
         * @param {?} date
         * @return {?}
         */
        (date) => {
            const { startDate, endDate } = this.state;
            if (endDate) {
                this.state.endDate = date;
            }
            else if (startDate) {
                this.state.startDate = date;
            }
        });
        this.shortcutSelect = (/**
         * @param {?} startDate
         * @param {?} endDate
         * @param {?=} props
         * @return {?}
         */
        (startDate, endDate, props = this.props) => {
            this.state = Object.assign({}, this.state, { startDate, showTimePicker: false }, this.selectDate(endDate, true, { startDate }, props));
            this.showClear = !!this.state.startDate;
        });
        this.setClientHeight = (/**
         * @param {?} height
         * @return {?}
         */
        (height) => {
            this.state.clientHight = height;
        });
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set locale(value) {
        if (value === 'enUS') {
            this.props.locale = Calendar;
        }
        else if (value === 'zhCN') {
            this.props.locale = zhCN;
        }
        this._unsubscribe$.next();
        this._unsubscribe$.complete();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set defaultTimeValue(value) {
        if (value) {
            this.props.defaultTimeValue = value;
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set prefixCls(value) {
        if (value) {
            this.props.prefixCls = value;
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set enterDirection(value) {
        this._enterDirection = value;
        if (this._enterDirection === 'horizontal') {
            this.contentAnimateClass = 'slideH-enter slideH-enter-active';
        }
        else {
            this.contentAnimateClass = 'slideV-enter slideV-enter-active';
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set visible(value) {
        this.props.visible = value;
        if (value === true || value === 'true') {
            this.showAnimation();
            this.isShow = true;
        }
        else {
            this.hideAnimation();
            setTimeout((/**
             * @return {?}
             */
            () => {
                this.isShow = false;
            }), 300);
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set getDateExtra(value) {
        this.props.getDateExtra = value;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set defaultDate(value) {
        this.props.defaultDate = value;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set minDate(value) {
        this.props.minDate = value;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set maxDate(value) {
        this.props.maxDate = value;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set pickTime(value) {
        this.props.pickTime = value;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set type(value) {
        this.props.type = value;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set showShortcut(value) {
        this.props.showShortcut = value;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set rowSize(value) {
        this.props.rowSize = value;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set infinite(value) { }
    /**
     * @param {?} value
     * @return {?}
     */
    set defaultValue(value) {
        this.props.defaultValue = value;
        if (value) {
            this.receiveProps(this.props);
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set onSelect(value) {
        this.props.onSelect = value;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        this._dateModelType = null;
        if (value && value instanceof Array) {
            if (value.length === 0) {
                console.error('[ng-zorro-antd-mobile]: calendar ngModel array need params!');
                return;
            }
            if (this.props.type === 'one' && value.length >= 2) {
                this._dateModelType = 1;
                console.error('[ng-zorro-antd-mobile]: type is one, but ngmodel has more than one param, just use first one');
                this.onSelectedDate(value[0]);
            }
            else if (value.length === 1) {
                this._dateModelType = 1;
                this.onSelectedDate(value[0]);
            }
            else {
                this._dateModelType = 2;
                this.onSelectedDate(value[0]);
                this.onSelectedDate(value[1]);
            }
        }
        else if (value && value instanceof Date) {
            this._dateModelType = 3;
            this.onSelectedDate(value);
        }
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.onChangeFn = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.onTouchFn = fn;
    }
    /**
     * @param {?} nextProps
     * @return {?}
     */
    receiveProps(nextProps) {
        if (nextProps.visible && nextProps.defaultValue) {
            this.shortcutSelect(nextProps.defaultValue[0], nextProps.defaultValue[1], nextProps);
        }
    }
    /**
     * @return {?}
     */
    showAnimation() {
        if (this._enterDirection === 'horizontal') {
            this.contentAnimateClass = 'slideH-enter slideH-enter-active';
        }
        else {
            this.contentAnimateClass = 'slideV-enter slideV-enter-active';
        }
        this.maskAnimateClass = 'fade-enter fade-enter-active';
    }
    /**
     * @return {?}
     */
    hideAnimation() {
        if (this._enterDirection === 'horizontal') {
            this.contentAnimateClass = 'slideH-leave slideH-leave-active';
        }
        else {
            this.contentAnimateClass = 'slideV-leave slideV-leave-active';
        }
        this.maskAnimateClass = 'fade-leave fade-leave-active';
    }
    /**
     * @param {?} date
     * @return {?}
     */
    writeModelData(date) {
        if (this._dateModelValue instanceof Array) {
            this._dateModelTime = this._dateModelValue.length;
        }
        else {
            this._dateModelTime = 0;
        }
        switch (this._dateModelType) {
            case 1:
                this._dateModelValue = [date];
                this.onChangeFn(this._dateModelValue);
                break;
            case 2:
                if (this._dateModelTime === 1) {
                    if (+date < +this._dateModelValue[0]) {
                        this._dateModelValue.unshift(date);
                    }
                    else {
                        this._dateModelValue.push(date);
                    }
                    this.onChangeFn(this._dateModelValue);
                }
                else {
                    this._dateModelValue = [];
                    this._dateModelValue.push(date);
                }
                break;
            case 3:
                this._dateModelValue = date;
                this.onChangeFn(this._dateModelValue);
                break;
            default:
                break;
        }
    }
    /**
     * @return {?}
     */
    triggerCancel() {
        this.props.onCancel && this.props.onCancel();
        this.onClose();
        this.onCancel && this.onCancel.emit();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        /** @type {?} */
        const defaultValue = this.props.defaultValue;
        if (defaultValue) {
            this.state = Object.assign({}, this.state, this.selectDate(defaultValue[1], true, { startDate: defaultValue[0] }, this.props));
        }
        this._localeProviderService.localeChange.pipe(takeUntil(this._unsubscribe$)).subscribe((/**
         * @param {?} _
         * @return {?}
         */
        _ => {
            this.props.locale = (/** @type {?} */ (Object.assign({}, this._localeProviderService.getLocaleSubObj('Calendar'))));
        }));
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._unsubscribe$.next();
        this._unsubscribe$.complete();
    }
}
CalendarComponent.decorators = [
    { type: Component, args: [{
                selector: 'Calendar, nzm-calendar',
                template: "<span *ngIf=\"isShow\">\n  <div class=\"{{'mask ' + maskAnimateClass}}\"></div>\n</span>\n<span *ngIf=\"isShow\">\n  <div class=\"{{'content animate ' + contentAnimateClass}}\">\n    <CalendarHeader [locale]=\"props.locale\"\n                    [closeIcon]=\"closeIconHtml\"\n                    [showClear]=\"showClear\"\n                    (onCancel)=\"triggerCancel()\"\n                    (onClear)=\"triggerClear()\"\n    ></CalendarHeader>\n    <CalendarDatePicker [propsData]=\"props\"\n                        [endDate]=\"state.endDate\"\n                        [startDate]=\"state.startDate\"\n                        [onCellClick]=\"onSelectedDate\"\n                        [onSelectHasDisableDate]=\"triggerSelectHasDisableDate\"\n                        [onLayout]=\"setClientHeight\"\n    ></CalendarDatePicker>\n    <CalendarTimePicker *ngIf=\"state.showTimePicker\"\n                        [propsData]=\"props\"\n                        [title]=\"state.timePickerTitle\"\n                        [clientHeight]=\"state.clientHight\"\n                        [prefixCls]=\"props.timePickerPrefixCls\"\n                        [defaultValue]=\"props.defaultTimeValue\"\n                        [pickerPrefixCls]=\"props.timePickerPickerPrefixCls\"\n                        [value]=\"state.endDate ? state.endDate : state.startDate\"\n                        [onValueChange]=\"onTimeChange\"\n    ></CalendarTimePicker>\n    <CalendarShortcutPanel *ngIf=\"props.showShortcut && !state.showTimePicker\"\n                           [locale]=\"props.locale\"\n                           [onSelect]=\"shortcutSelect\"\n    ></CalendarShortcutPanel>\n    <CalendarConfirmPanel *ngIf=\"state.startDate\"\n                          [startDateTime]=\"state.startDate\"\n                          [endDateTime]=\"state.endDate\"\n                          [propsData]=\"props\"\n                          [disableBtn]=\"state.disConfirmBtn\"\n                          [formatStr]=\"props.pickTime ? props.locale.dateTimeFormat : props.locale.dateFormat\"\n                          [onConfirm]=\"triggerConfirm\"\n    ></CalendarConfirmPanel>\n  </div>\n</span>\n<ng-template #closeIconHtml>\n  <Icon [type]=\"'cross'\"></Icon>\n</ng-template>\n",
                encapsulation: ViewEncapsulation.None,
                providers: [{ provide: NG_VALUE_ACCESSOR, useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => CalendarComponent)), multi: true }]
            }] }
];
/** @nocollapse */
CalendarComponent.ctorParameters = () => [
    { type: LocaleProviderService }
];
CalendarComponent.propDecorators = {
    datepicker: [{ type: ViewChild, args: [CalendarDatePickerComponent,] }],
    locale: [{ type: Input }],
    defaultTimeValue: [{ type: Input }],
    prefixCls: [{ type: Input }],
    enterDirection: [{ type: Input }],
    visible: [{ type: Input }],
    getDateExtra: [{ type: Input }],
    defaultDate: [{ type: Input }],
    minDate: [{ type: Input }],
    maxDate: [{ type: Input }],
    pickTime: [{ type: Input }],
    type: [{ type: Input }],
    showShortcut: [{ type: Input }],
    rowSize: [{ type: Input }],
    infinite: [{ type: Input }],
    defaultValue: [{ type: Input }],
    onSelect: [{ type: Input }],
    onCancel: [{ type: Output }],
    onConfirm: [{ type: Output }],
    onSelectHasDisableDate: [{ type: Output }],
    class: [{ type: HostBinding, args: ['class',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CalendarHeaderComponent {
    constructor() {
        this.closeIcon_component = false;
        this._closeIcon = 'X';
        this.onCancel = new EventEmitter();
        this.onClear = new EventEmitter();
        this.header = true;
    }
    /**
     * @return {?}
     */
    get locale() {
        return this._locale;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set locale(value) {
        this._locale = value;
    }
    /**
     * @return {?}
     */
    get closeIcon() {
        return this._closeIcon;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set closeIcon(value) {
        if (value instanceof TemplateRef) {
            this._closeIcon = value;
            this.closeIcon_component = true;
        }
        else {
            this._closeIcon = (/** @type {?} */ (value));
            this.closeIcon_component = false;
        }
    }
    /**
     * @return {?}
     */
    get showClear() {
        return this._showClear;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set showClear(value) {
        this._showClear = value;
    }
    /**
     * @return {?}
     */
    triggerCancel() {
        this.onCancel && this.onCancel.emit();
    }
    /**
     * @return {?}
     */
    triggerClear() {
        this.onClear && this.onClear.emit();
    }
}
CalendarHeaderComponent.decorators = [
    { type: Component, args: [{
                selector: 'CalendarHeader, nzm-calendar-header',
                template: "<span *ngIf=\"!closeIcon_component\" class=\"left\" (click)=\"triggerCancel()\" [innerHTML]=\"closeIcon\"></span>\n<span *ngIf=\"closeIcon_component\" class=\"left\" (click)=\"triggerCancel()\">\n  <ng-template [ngTemplateOutlet]=\"closeIcon\"></ng-template>\n</span>\n<span class=\"title\">{{title || locale.title}}</span>\n<span *ngIf=\"showClear\" class=\"right\" (click)=\"triggerClear()\">{{clearIcon || locale.clear}}</span>\n",
                encapsulation: ViewEncapsulation.None
            }] }
];
/** @nocollapse */
CalendarHeaderComponent.ctorParameters = () => [];
CalendarHeaderComponent.propDecorators = {
    locale: [{ type: Input }],
    closeIcon: [{ type: Input }],
    showClear: [{ type: Input }],
    onCancel: [{ type: Output }],
    onClear: [{ type: Output }],
    header: [{ type: HostBinding, args: ['class.header',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CalendarWeekPanelComponent {
    constructor() {
        this.week = ['日', '一', '二', '三', '四', '五', '六'];
        this.weekPanel = true;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set locale(value) {
        this._locale = value;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.week = this._locale.week;
    }
}
CalendarWeekPanelComponent.decorators = [
    { type: Component, args: [{
                selector: 'CalendarWeekPanel, nzm-calendar-week-panel',
                template: "<div class=\"cell cell-grey\">{{week[0]}}</div>\n<div class=\"cell\">{{week[1]}}</div>\n<div class=\"cell\">{{week[2]}}</div>\n<div class=\"cell\">{{week[3]}}</div>\n<div class=\"cell\">{{week[4]}}</div>\n<div class=\"cell\">{{week[5]}}</div>\n<div class=\"cell cell-grey\">{{week[6]}}</div>\n",
                encapsulation: ViewEncapsulation.None
            }] }
];
/** @nocollapse */
CalendarWeekPanelComponent.ctorParameters = () => [];
CalendarWeekPanelComponent.propDecorators = {
    locale: [{ type: Input }],
    weekPanel: [{ type: HostBinding, args: ['class.week-panel',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var Picker$1 = {
    okText: 'Ok',
    dismissText: 'Cancel',
    extra: 'please select',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// import  DatePickerLocale from 'rmc-date-picker/lib/locale/en_US';
var DatePicker$1 = {
    okText: 'OK',
    dismissText: 'Cancel',
    extra: 'please select',
    // DatePickerLocale,
    year: '',
    month: '',
    day: '',
    hour: '',
    minute: '',
    am: 'AM',
    pm: 'PM'
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// import  DatePickerLocale from 'rmc-date-picker/lib/locale/en_US';
var DatePickerView$1 = {
    okText: 'OK',
    dismissText: 'Cancel',
    extra: 'please select',
    // DatePickerLocale,
    year: '',
    month: '',
    day: '',
    hour: '',
    minute: '',
    am: 'AM',
    pm: 'PM'
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var Menu$1 = {
    okText: 'Ok',
    cancelText: 'Cancel',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var SearchBar$1 = {
    cancelText: 'Cancel',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var InputItem$1 = {
    confirmLabel: 'Done',
    backspaceLabel: 'Backspace',
    cancelKeyboardLabel: 'CancelKeyboard',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var Pagination$1 = {
    prevText: 'Prev',
    nextText: 'Next',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var PullToRefresh$1 = {
    activateText: 'Refresh immediately after release',
    deactivateText: 'Pull down to refresh',
    finishText: 'Finish refresh',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var ActionSheet$1 = {
    dismissText: 'Cancel'
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var en_US = {
    locale: 'en_US',
    Picker: Picker$1,
    DatePicker: DatePicker$1,
    DatePickerView: DatePickerView$1,
    Menu: Menu$1,
    Calendar,
    SearchBar: SearchBar$1,
    InputItem: InputItem$1,
    Pagination: Pagination$1,
    PullToRefresh: PullToRefresh$1,
    ActionSheet: ActionSheet$1
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var Picker$2 = {
    okText: 'Ок',
    dismissText: 'Отмена',
    extra: '',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// import DatePickerLocale from 'rmc-date-picker/lib/locale/en_US';
var DatePicker$2 = {
    okText: 'Ок',
    dismissText: 'Отмена',
    extra: '',
    // DatePickerLocale,
    year: '',
    month: '',
    day: '',
    hour: '',
    minute: '',
    am: 'AM',
    pm: 'PM'
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// import DatePickerLocale from 'rmc-date-picker/lib/locale/en_US';
var DatePickerView$2 = {
    okText: 'Ок',
    dismissText: 'Отмена',
    extra: '',
    // DatePickerLocale,
    year: '',
    month: '',
    day: '',
    hour: '',
    minute: '',
    am: 'AM',
    pm: 'PM'
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var Menu$2 = {
    okText: 'Ок',
    cancelText: 'Отмена',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var SearchBar$2 = {
    cancelText: 'Отмена',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var InputItem$2 = {
    confirmLabel: 'Ок',
    backspaceLabel: 'возврат на одну позицию',
    cancelKeyboardLabel: 'Отменить клавиатуру',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var Pagination$2 = {
    prevText: 'Назад',
    nextText: 'Вперёд',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var PullToRefresh$2 = {
    activateText: 'Обновить сразу после выпуска',
    deactivateText: 'Потяните вниз, чтобы обновить',
    finishText: 'Завершить обновление',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var ActionSheet$2 = {
    dismissText: 'Отмена'
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var ru_RU = {
    locale: 'ru_RU',
    Picker: Picker$2,
    DatePicker: DatePicker$2,
    DatePickerView: DatePickerView$2,
    Menu: Menu$2,
    // Calendar,
    SearchBar: SearchBar$2,
    InputItem: InputItem$2,
    Pagination: Pagination$2,
    PullToRefresh: PullToRefresh$2,
    ActionSheet: ActionSheet$2
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var Picker$3 = {
    okText: 'Ok',
    dismissText: 'Avbryt',
    extra: 'vänligen välj',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// import DatePickerLocale from 'rmc-date-picker/lib/locale/en_US';
var DatePicker$3 = {
    okText: 'Ok',
    dismissText: 'Avbryt',
    extra: 'vänligen välj',
    // DatePickerLocale,
    year: '',
    month: '',
    day: '',
    hour: '',
    minute: '',
    am: 'AM',
    pm: 'PM'
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// import DatePickerLocale from 'rmc-date-picker/lib/locale/en_US';
var DatePickerView$3 = {
    okText: 'Ok',
    dismissText: 'Avbryt',
    extra: 'vänligen välj',
    // DatePickerLocale,
    year: '',
    month: '',
    day: '',
    hour: '',
    minute: '',
    am: 'AM',
    pm: 'PM'
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var Menu$3 = {
    okText: 'Ok',
    cancelText: 'Avbryt',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var SearchBar$3 = {
    cancelText: 'Avbryt',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var InputItem$3 = {
    confirmLabel: 'Ok',
    backspaceLabel: 'Backspace',
    cancelKeyboardLabel: 'CancelKeyboard',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var Pagination$3 = {
    prevText: 'Föreg',
    nextText: 'Nästa',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var PullToRefresh$3 = {
    activateText: 'Uppdatera omedelbart efter utsläpp',
    deactivateText: 'Dra ner för att uppdatera',
    finishText: 'Avsluta uppdateringen',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var ActionSheet$3 = {
    dismissText: 'Avbryt'
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var sv_SE = {
    locale: 'sv_SE',
    Picker: Picker$3,
    DatePicker: DatePicker$3,
    DatePickerView: DatePickerView$3,
    Menu: Menu$3,
    // Calendar,
    SearchBar: SearchBar$3,
    InputItem: InputItem$3,
    Pagination: Pagination$3,
    PullToRefresh: PullToRefresh$3,
    ActionSheet: ActionSheet$3
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var Picker$4 = {
    okText: 'Ok',
    dismissText: 'Annuller',
    extra: 'Vælg venligst',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// import DatePickerLocale from 'rmc-date-picker/lib/locale/en_US';
var DatePicker$4 = {
    okText: 'Ok',
    dismissText: 'Annuller',
    extra: 'Vælg venligst',
    // DatePickerLocale,
    year: '',
    month: '',
    day: '',
    hour: '',
    minute: '',
    am: 'AM',
    pm: 'PM'
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// import DatePickerLocale from 'rmc-date-picker/lib/locale/en_US';
var DatePickerView$4 = {
    okText: 'Ok',
    dismissText: 'Annuller',
    extra: 'Vælg venligst',
    // DatePickerLocale,
    year: '',
    month: '',
    day: '',
    hour: '',
    minute: '',
    am: 'AM',
    pm: 'PM'
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var Menu$4 = {
    okText: 'Ok',
    cancelText: 'Annuller',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// 同步自 'rmc-calendar/lib/locale/en_US';
var Calendar$1 = {
    title: 'Kalender',
    today: 'I dag',
    month: 'Måned',
    year: 'År',
    am: 'AM',
    pm: 'PM',
    dateTimeFormat: 'dd/MM/yyyy w hh:mm',
    dateFormat: 'dd/MM/yyyy w',
    noChoose: 'Intet valgt',
    week: ['Søn', 'Man', 'Tir', 'Ons', 'Tor', 'Fre', 'Lør'],
    clear: 'Fjern',
    selectTime: 'Vælg tidspunkt',
    selectStartTime: 'Vælg starttidspunkt',
    selectEndTime: 'Vælg sluttidspunkt',
    start: 'Start',
    end: 'Slut',
    begin: 'Start',
    over: 'Slut',
    begin_over: 'Start/Stop',
    confirm: 'Bekræft',
    monthTitle: 'MM yyyy',
    loadPrevMonth: 'Indlæs forrige måned',
    yesterday: 'I går',
    lastWeek: 'Sidste uge',
    lastMonth: 'Sidste måned'
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var SearchBar$4 = {
    cancelText: 'Annuller',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var InputItem$4 = {
    confirmLabel: 'Ok',
    backspaceLabel: 'Backspace',
    cancelKeyboardLabel: 'CancelKeyboard',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var Pagination$4 = {
    prevText: 'Forrige',
    nextText: 'Næste',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var PullToRefresh$4 = {
    activateText: 'Opdater umiddelbart efter slip',
    deactivateText: 'Træk ned for at opdatere',
    finishText: 'Afslut opdatering',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var ActionSheet$4 = {
    dismissText: 'Annuller'
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var da_DK = {
    locale: 'da_DK',
    Picker: Picker$4,
    DatePicker: DatePicker$4,
    DatePickerView: DatePickerView$4,
    Menu: Menu$4,
    Calendar: Calendar$1,
    SearchBar: SearchBar$4,
    InputItem: InputItem$4,
    Pagination: Pagination$4,
    PullToRefresh: PullToRefresh$4,
    ActionSheet: ActionSheet$4
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CalendarTimePickerComponent {
    constructor() {
        this.defaultProps = (/** @type {?} */ ({
            minDate: new Date(0, 0, 0, 0, 0),
            maxDate: new Date(9999, 11, 31, 23, 59, 59),
            defaultValue: new Date(2000, 1, 1, 8),
            mode: 'time',
            datePickerViewLocale: zh_CN
        }));
        this.props = (/** @type {?} */ ({
            minDate: new Date(0, 0, 0, 0, 0),
            maxDate: new Date(9999, 11, 31, 23, 59, 59),
            defaultValue: new Date(2000, 1, 1, 8),
            mode: 'time',
            datePickerViewLocale: zh_CN
        }));
        this.timePicker = true;
        this.onDateChange = (/**
         * @param {?} date
         * @return {?}
         */
        (date) => {
            const { onValueChange } = this.props;
            onValueChange && onValueChange(date.date);
        });
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set propsData(value) {
        this.props = Object.assign({}, this.props, value);
        if (this.props.locale && this.props.locale.today === 'Today') {
            this.props.datePickerViewLocale = en_US;
        }
        else {
            this.props.datePickerViewLocale = zh_CN;
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set title(value) {
        this.props.title = value;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set value(value) {
        this.props.value = value;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set prefixCls(value) {
        this.props.prefixCls = value;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set defaultValue(value) {
        this.props.defaultValue = value;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set pickerPrefixCls(value) {
        this.props.pickerPrefixCls = value;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set clientHeight(value) {
        this.props.clientHeight = value;
        /** @type {?} */
        const height = (value && (value * 3) / 8 - 52) || Number.POSITIVE_INFINITY;
        this.selfHeight = (height > 164 || height < 0 ? 164 : height) + 'px';
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set onValueChange(value) {
        this.props.onValueChange = value;
    }
    /**
     * @param {?=} date
     * @return {?}
     */
    getMinTime(date) {
        /** @type {?} */
        const minDate = (/** @type {?} */ (this.props.minDate));
        if (!date ||
            date.getFullYear() > minDate.getFullYear() ||
            date.getMonth() > minDate.getMonth() ||
            date.getDate() > minDate.getDate()) {
            return this.defaultProps.minDate;
        }
        return minDate;
    }
    /**
     * @param {?=} date
     * @return {?}
     */
    getMaxTime(date) {
        /** @type {?} */
        const maxDate = (/** @type {?} */ (this.props.maxDate));
        if (!date ||
            date.getFullYear() < maxDate.getFullYear() ||
            date.getMonth() < maxDate.getMonth() ||
            date.getDate() < maxDate.getDate()) {
            return this.defaultProps.maxDate;
        }
        return maxDate;
    }
}
CalendarTimePickerComponent.decorators = [
    { type: Component, args: [{
                selector: 'CalendarTimePicker, nzm-calendar-time-picker',
                template: "<div class=\"title\">{{props.title}}</div>\n<DatePickerView [ngStyle]=\"{height: selfHeight, overflow: 'hidden'}\"\n                [mode]=\"props.mode\"\n                [value]=\"props.value\"\n                [locale]=\"props.datePickerViewLocale\"\n                [minDate]=\"getMinTime(props.value || props.defaultValue || undefined)\"\n                [maxDate]=\"getMaxTime(props.value || props.defaultValue || undefined)\"\n                (onValueChange)=\"onDateChange($event)\"\n></DatePickerView>\n",
                encapsulation: ViewEncapsulation.None
            }] }
];
/** @nocollapse */
CalendarTimePickerComponent.ctorParameters = () => [];
CalendarTimePickerComponent.propDecorators = {
    propsData: [{ type: Input }],
    title: [{ type: Input }],
    value: [{ type: Input }],
    prefixCls: [{ type: Input }],
    defaultValue: [{ type: Input }],
    pickerPrefixCls: [{ type: Input }],
    clientHeight: [{ type: Input }],
    onValueChange: [{ type: Input }],
    timePicker: [{ type: HostBinding, args: ['class.time-picker',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DatePickerOptions {
    constructor() {
        this.mode = 'date';
        this.value = new Date();
        this.minDate = new Date(2000, 6, 1, 0, 0, 0);
        this.maxDate = new Date(2030, 1, 1, 23, 59, 59);
        this.use12Hours = false;
        this.minuteStep = 1;
        this.data = [];
        this.mask = true;
        this.title = '';
        this.okText = '确定';
        this.dismissText = '取消';
        this.disabled = false;
        this.appendToBody = false;
        this.showErrorToast = true;
        this.showErrorToastInterval = 2000;
        this.onOk = new EventEmitter();
        this.onDismiss = new EventEmitter();
        this.onValueChange = new EventEmitter();
        this.onChange = new EventEmitter();
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @return {?}
 */
function getVelocity() {
    return ((/**
     * @param {?=} minInterval
     * @param {?=} maxInterval
     * @return {?}
     */
    (minInterval = 30, maxInterval = 100) => {
        /** @type {?} */
        let _time = 0;
        /** @type {?} */
        let _y = 0;
        /** @type {?} */
        let _velocity = 0;
        /** @type {?} */
        const recorder = {
            record: (/**
             * @param {?} y
             * @return {?}
             */
            (y) => {
                /** @type {?} */
                const now = +new Date();
                _velocity = (y - _y) / (now - _time);
                if (now - _time >= minInterval) {
                    _velocity = now - _time <= maxInterval ? _velocity : 0;
                    _y = y;
                    _time = now;
                }
            }),
            getVelocity: (/**
             * @param {?} y
             * @return {?}
             */
            (y) => {
                if (y !== _y) {
                    recorder.record(y);
                }
                return _velocity;
            }),
        };
        return recorder;
    }))();
}

var velocity = /*#__PURE__*/Object.freeze({
    getVelocity: getVelocity
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DatePickerComponent {
    /**
     * @param {?} elementRef
     * @param {?} options
     * @param {?} toast
     * @param {?} localeProviderService
     */
    constructor(elementRef, options, toast, localeProviderService) {
        this.elementRef = elementRef;
        this.options = options;
        this.toast = toast;
        this.localeProviderService = localeProviderService;
        this.transitionName = 'am-slide-up-enter am-slide-up-enter-active';
        this.maskTransitionName = 'am-fade-enter am-fade-enter-active';
        this.modeSwitch = [1, 1, 1, 1, 1, 1];
        this.localMinDate = [];
        this.localMaxDate = [];
        this.currentTime = [];
        this.indexArray = [];
        this.min_date = [];
        this.max_date = [];
        this.current_time = [
            new Date().getFullYear(),
            new Date().getMonth() + 1,
            new Date().getDate(),
            new Date().getHours(),
            new Date().getMinutes()
        ];
        this.clos = 0;
        this.resultArr = [];
        this.data = [];
        this.dataWithStr = [];
        this.startY = 0;
        this.differY = 0;
        this.currentY = 0;
        this.len = 0;
        this.dom = null;
        this.index = 0;
        this.maxY = 0;
        this.lineHeight = 34;
        this.selectedTarget = [];
        this.isMouseDown = false;
        this.localeNew = {};
        this.unsubscribe$ = new Subject();
        this.Velocity = getVelocity();
        this.errorMessage = '';
        this.curTLessThanMin = false;
        this.curTMoreThanMax = false;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    panstart(event) {
        if (!event.target.classList.contains('am-picker-col-mask')) {
            return;
        }
        this.isMouseDown = true;
        event.preventDefault();
        this.dom = event.target.parentElement.children[2];
        this.len = this.dom.children.length;
        this.maxY = -(this.len - 1);
        if (this.dom.style.transform === 'translateY(0px)') {
            this.currentY = 0;
            this.maxY = -(this.len - 1);
        }
        else if (this.selectedTarget.length > 0) {
            this.selectedTarget.forEach((/**
             * @param {?} item
             * @return {?}
             */
            item => {
                if (item.targetId === event.target.id) {
                    this.currentY = item.currentY;
                }
            }));
        }
        /** @type {?} */
        const ev = this.getEventTarget(event);
        this.startY = ev.clientY;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    panmove(event) {
        if (!event.target.classList.contains('am-picker-col-mask') || !this.isMouseDown) {
            return;
        }
        event.preventDefault();
        /** @type {?} */
        const ev = this.getEventTarget(event);
        this.differY = ev.clientY - this.startY;
        this.Velocity.record(this.differY);
        this.dom.style.transition = 'transform 0s';
        this.dom.style.transform = `translateY(${this.currentY * this.lineHeight + this.differY}px)`;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    panend(event) {
        if (!event.target.classList.contains('am-picker-col-mask') || !this.isMouseDown) {
            return;
        }
        this.isMouseDown = false;
        event.preventDefault();
        /** @type {?} */
        const ev = this.getEventTarget(event);
        this.differY = ev.clientY - this.startY;
        /** @type {?} */
        let time = 0.3;
        /** @type {?} */
        const velocityTemp = this.Velocity.getVelocity(this.differY) * 4;
        if (velocityTemp) {
            this.differY = velocityTemp * 40 + this.differY;
            time = Math.abs(velocityTemp) * 0.1;
        }
        this.dom.style.transition = 'transform ' + (time < 0.3 ? 0.3 : time) + 's';
        if (this.differY <= -this.lineHeight / 2) {
            this.currentY += Math.floor(this.differY / this.lineHeight);
            if (this.currentY <= this.maxY) {
                this.currentY = this.maxY;
            }
        }
        else if (this.differY >= this.lineHeight / 2) {
            this.currentY += Math.floor(this.differY / this.lineHeight);
            if (this.currentY >= 0) {
                this.currentY = 0;
            }
        }
        if (this.selectedTarget.length > 0) {
            /** @type {?} */
            let hasKey = false;
            this.selectedTarget.forEach((/**
             * @param {?} item
             * @return {?}
             */
            item => {
                if (item.targetId === event.target.id) {
                    hasKey = true;
                    item.targetId = event.target.id;
                    item.currentY = this.currentY;
                }
            }));
            if (!hasKey) {
                this.selectedTarget.push({ targetId: event.target.id, currentY: this.currentY });
            }
        }
        else {
            this.selectedTarget.push({ targetId: event.target.id, currentY: this.currentY });
        }
        this.dom.style.transform = `translateY(${this.currentY * this.lineHeight}px)`;
        this.index = Math.floor(Math.abs(this.currentY / 1)); // 记录当前位移在数组中的索引,必须取整，否则会出现浮点数
        this.current_time[this.indexArray[parseInt(event.target.id, 0)]] = this.resultArr[this.indexArray[parseInt(event.target.id, 0)]] = this.data[parseInt(event.target.id, 0)][this.index];
        if (this.judgeTime(this.current_time, this.max_date)) {
            this.currentTime = this.current_time = this.max_date.slice(0, this.indexArray.length);
            this.resultArr = this.current_time;
            this.options.onValueChange.emit({ date: this.handleReslut(), index: event.target.id });
            if (this.options.updateNgModel) {
                this.options.updateNgModel(this.handleReslut());
            }
            if (this.ngModelOnChange) {
                this.ngModelOnChange(this.handleReslut());
            }
            this.init();
        }
        else if (this.judgeTime(this.min_date, this.current_time)) {
            this.currentTime = this.current_time = this.min_date.slice(0, this.indexArray.length);
            this.resultArr = this.currentTime;
            this.options.onValueChange.emit({ date: this.handleReslut(), index: event.target.id });
            if (this.options.updateNgModel) {
                this.options.updateNgModel(this.handleReslut());
            }
            if (this.ngModelOnChange) {
                this.ngModelOnChange(this.handleReslut());
            }
            this.init();
        }
        else {
            this.setCurrentSelected(0, this.differY < 0, this.index);
            this.options.onValueChange.emit({ date: this.handleReslut(), index: event.target.id });
            if (this.options.updateNgModel) {
                this.options.updateNgModel(this.handleReslut());
            }
            if (this.ngModelOnChange) {
                this.ngModelOnChange(this.handleReslut());
            }
        }
    }
    /**
     * @return {?}
     */
    init() {
        if (!this.checkTime() && this.options.showErrorToast) {
            setTimeout((/**
             * @return {?}
             */
            () => {
                ToastService.fail(this.errorMessage, this.options.showErrorToastInterval);
            }), 0);
        }
        this.initResult();
        this.initReady();
        this.getInitValueIndex();
    }
    /**
     * @return {?}
     */
    reloadPicker() {
        if (!this.picker || this.picker === undefined) {
            return;
        }
        this.currentPicker = this.picker.element.nativeElement;
        if (this.currentPicker && this.currentPicker.children.length > 0) {
            /** @type {?} */
            const self = this;
            setTimeout((/**
             * @return {?}
             */
            () => {
                self.selectedTarget.forEach((/**
                 * @param {?} item
                 * @param {?} i
                 * @return {?}
                 */
                (item, i) => {
                    self.currentPicker.children[i].children[2].style.transition = 'transform .3s';
                    /** @type {?} */
                    const index = parseInt(item.currentY, 0);
                    self.currentPicker.children[i].children[2].style.transform = `translateY(${index * self.lineHeight}px)`;
                }));
            }), 0);
        }
    }
    /**
     * @return {?}
     */
    localeProvider() {
        /** @type {?} */
        const self = this;
        if (self.options.locale || self.options.locale !== undefined) {
            self.localeProviderService.setLocale(self.options.locale);
        }
        self.localeProviderService.localeChange.pipe(takeUntil(self.unsubscribe$)).subscribe((/**
         * @param {?} _
         * @return {?}
         */
        _ => {
            self.options.locale = self.localeProviderService.getLocale();
            self.localeNew = self.localeProviderService.getLocaleSubObj('DatePicker');
            self.options.okText = self.localeNew.okText;
            self.options.dismissText = self.localeNew.dismissText;
            self.init();
        }));
    }
    /**
     * @param {?} date
     * @return {?}
     */
    transformDateFormat(date) {
        if (!date) {
            return '';
        }
        else {
            return 'yyyy-mm-dd-HH-MM'
                .replace('yyyy', date.getFullYear() + '')
                .replace('mm', date.getMonth() + 1 + '')
                .replace('dd', date.getDate() + '')
                .replace('HH', date.getHours() + '')
                .replace('MM', date.getMinutes() + '');
        }
    }
    /**
     * @param {?} val
     * @return {?}
     */
    preZero(val) {
        return val < 10 ? '0' + val : val + '';
    }
    /**
     * @return {?}
     */
    getInitValueIndex() {
        this.selectedTarget = [];
        this.indexArray.map((/**
         * @param {?} index
         * @param {?} i
         * @return {?}
         */
        (index, i) => {
            this.data.forEach((/**
             * @param {?} item
             * @param {?} j
             * @return {?}
             */
            (item, j) => {
                item.forEach((/**
                 * @param {?} item1
                 * @param {?} k
                 * @return {?}
                 */
                (item1, k) => {
                    if (this.currentTime[index] === item1 && i === j) {
                        this.selectedTarget.push({ targetId: `${i}`, currentY: -k });
                    }
                }));
            }));
        }));
        this.reloadPicker();
    }
    /**
     * @param {?} mode
     * @return {?}
     */
    checkMode(mode) {
        this.modeSwitch = [1, 1, 1, 1, 1, 1];
        switch (mode) {
            case 'date':
                this.modeSwitch = [1, 1, 1, 0, 0, 0];
                break;
            case 'time':
                if (this.options.use12Hours) {
                    this.modeSwitch = [0, 0, 0, 1, 1, 1];
                }
                else {
                    this.modeSwitch = [0, 0, 0, 1, 1, 0];
                }
                break;
            case 'datetime':
                if (this.options.use12Hours) {
                    this.modeSwitch = [1, 1, 1, 1, 1, 1];
                }
                else {
                    this.modeSwitch = [1, 1, 1, 1, 1, 0];
                }
                break;
            case 'year':
                this.modeSwitch = [1, 0, 0, 0, 0];
                break;
            case 'month':
                this.modeSwitch = [1, 1, 0, 0, 0];
                break;
            default:
                break;
        }
        /** @type {?} */
        const tempIndexArray = [];
        for (let i = 0; i < this.modeSwitch.length; i++) {
            if (this.modeSwitch[i] > 0) {
                tempIndexArray.push(i);
            }
        }
        this.clos = tempIndexArray[tempIndexArray.length - 1] - tempIndexArray[0] + 1;
        this.indexArray = tempIndexArray;
    }
    /**
     * @return {?}
     */
    initResult() {
        this.resultArr = [];
        for (let i = 0; i < this.clos; i++) {
            /** @type {?} */
            const res = this.currentTime[i];
            if (this.options.mode === 'time') {
                this.resultArr = this.currentTime;
            }
            else {
                this.resultArr.push(res);
            }
        }
    }
    /**
     * @return {?}
     */
    checkTime() {
        /** @type {?} */
        const min_Date = this.transformDateFormat(this.options.minDate).split('-');
        if (min_Date.length > 0) {
            this.min_date = min_Date.map((/**
             * @param {?} item
             * @return {?}
             */
            item => {
                return parseInt(item, 0);
            }));
        }
        /** @type {?} */
        const max_Date = this.transformDateFormat(this.options.maxDate).split('-');
        if (max_Date.length > 0) {
            this.max_date = max_Date.map((/**
             * @param {?} item
             * @return {?}
             */
            item => {
                return parseInt(item, 0);
            }));
        }
        /** @type {?} */
        const min_date = this.min_date;
        /** @type {?} */
        const max_date = this.max_date;
        /** @type {?} */
        const current_time = this.currentTime;
        this.localMinDate = [];
        if (this.localMinDate.length === 0) {
            for (let index = 0; index < this.indexArray.length; index++) {
                this.localMinDate.push(min_date[this.indexArray[index]]);
            }
        }
        this.localMaxDate = [];
        if (this.localMaxDate.length === 0) {
            for (let index = 0; index < this.indexArray.length; index++) {
                this.localMaxDate.push(max_date[this.indexArray[index]]);
            }
        }
        if (this.indexArray.length === this.localMinDate.length &&
            this.localMinDate.length === this.localMaxDate.length) {
            /** @type {?} */
            const minT = new Date(min_date[0], min_date[1], min_date[2], min_date[3], min_date[4]).getTime();
            /** @type {?} */
            const maxT = new Date(max_date[0], max_date[1], max_date[2], max_date[3], max_date[4]).getTime();
            /** @type {?} */
            const curT = new Date(current_time[0], current_time[1], current_time[2], current_time[3] || 0, current_time[4] || 0).getTime();
            this.curTLessThanMin = false;
            this.curTMoreThanMax = false;
            if (curT < minT) {
                this.curTLessThanMin = true;
                this.currentTime = this.min_date;
                this.errorMessage = this.localeNew.curTLessthanMin;
            }
            if (curT > maxT) {
                this.curTMoreThanMax = true;
                this.currentTime = this.max_date;
                this.errorMessage = this.localeNew.curTMorethanMax;
            }
            /** @type {?} */
            let _indexArrayIndex = 0;
            for (let i = 0; i < this.modeSwitch.length; i++) {
                if (this.modeSwitch[i] === 0) {
                    switch (i) {
                        case 0:
                            min_date[i] = new Date().getFullYear();
                            max_date[i] = new Date().getFullYear();
                            break;
                        case 1:
                            min_date[i] = new Date().getMonth() + 1;
                            max_date[i] = new Date().getMonth() + 1;
                            break;
                        case 2:
                            min_date[i] = new Date().getDate();
                            max_date[i] = new Date().getDate();
                            break;
                        case 3:
                            min_date[i] = new Date().getHours();
                            max_date[i] = new Date().getHours();
                            break;
                        case 4:
                            min_date[i] = new Date().getMinutes();
                            max_date[i] = new Date().getMinutes();
                            break;
                        case 5:
                            min_date[i] = 0;
                            max_date[i] = 1;
                            break;
                    }
                }
                else {
                    switch (i) {
                        case 0:
                            this.localMinDate[_indexArrayIndex] = min_date[i] =
                                (this.localMinDate[_indexArrayIndex] >= 1900)
                                    ? this.localMinDate[_indexArrayIndex]
                                    : new Date().getFullYear();
                            this.localMaxDate[_indexArrayIndex] = max_date[i] =
                                this.localMaxDate[_indexArrayIndex] >= 1900
                                    ? this.localMaxDate[_indexArrayIndex]
                                    : new Date().getFullYear() + 1;
                            break;
                        case 1:
                            this.localMinDate[_indexArrayIndex] = min_date[i] =
                                this.localMinDate[_indexArrayIndex] > 0 && this.localMinDate[_indexArrayIndex] <= 12
                                    ? this.localMinDate[_indexArrayIndex]
                                    : 1;
                            this.localMaxDate[_indexArrayIndex] = max_date[i] =
                                this.localMaxDate[_indexArrayIndex] > 0 && this.localMaxDate[_indexArrayIndex] <= 12
                                    ? this.localMaxDate[_indexArrayIndex]
                                    : 12;
                            break;
                        case 2:
                            this.localMinDate[_indexArrayIndex] = min_date[i] =
                                this.localMinDate[_indexArrayIndex] > 0 &&
                                    this.localMinDate[_indexArrayIndex] <= new Date(min_date[0], min_date[1], 0).getDate()
                                    ? this.localMinDate[_indexArrayIndex]
                                    : 1;
                            this.localMaxDate[_indexArrayIndex] = max_date[i] =
                                this.localMaxDate[_indexArrayIndex] > 0 &&
                                    this.localMaxDate[_indexArrayIndex] <= new Date(max_date[0], max_date[1], 0).getDate()
                                    ? this.localMaxDate[_indexArrayIndex]
                                    : new Date(max_date[0], max_date[1], 0).getDate();
                            break;
                        case 3:
                            this.localMinDate[_indexArrayIndex] = min_date[i] =
                                this.localMinDate[_indexArrayIndex] >= 0 && this.localMinDate[_indexArrayIndex] <= 23
                                    ? this.localMinDate[_indexArrayIndex]
                                    : 0;
                            if (this.options.use12Hours) {
                                this.localMaxDate[_indexArrayIndex] = max_date[i] =
                                    this.localMaxDate[_indexArrayIndex] >= 0 && this.localMaxDate[_indexArrayIndex] <= 11
                                        ? this.localMaxDate[_indexArrayIndex]
                                        : 11;
                            }
                            else {
                                this.localMaxDate[_indexArrayIndex] = max_date[i] =
                                    this.localMaxDate[_indexArrayIndex] >= 0 && this.localMaxDate[_indexArrayIndex] <= 23
                                        ? this.localMaxDate[_indexArrayIndex]
                                        : 23;
                            }
                            break;
                        case 4:
                            this.localMinDate[_indexArrayIndex] = min_date[i] =
                                this.localMinDate[_indexArrayIndex] >= 0 && this.localMinDate[_indexArrayIndex] <= 59
                                    ? this.localMinDate[_indexArrayIndex]
                                    : 0;
                            this.localMaxDate[_indexArrayIndex] = max_date[i] =
                                this.localMaxDate[_indexArrayIndex] >= 0 && this.localMaxDate[_indexArrayIndex] <= 59
                                    ? this.localMaxDate[_indexArrayIndex]
                                    : 59;
                            break;
                    }
                }
                _indexArrayIndex++;
            }
            return minT <= curT && curT <= maxT;
        }
        else {
            this.errorMessage = this.localeNew.errorMessage;
            return false;
        }
    }
    /**
     * @param {?} arr1
     * @param {?} arr2
     * @return {?}
     */
    judgeTime(arr1, arr2) {
        /** @type {?} */
        let date1;
        /** @type {?} */
        let date2;
        date1 = arr1.slice(0, 3).join('-') + ' ' + arr1.slice(3, 5).join(':');
        date2 = arr2.slice(0, 3).join('-') + ' ' + arr2.slice(3, 5).join(':');
        return new Date(date1).getTime() >= new Date(date2).getTime();
    }
    /**
     * @param {?} arr1
     * @param {?} arr2
     * @param {?} length
     * @return {?}
     */
    judgeEqualArray(arr1, arr2, length) {
        /** @type {?} */
        let status = true;
        for (let i = 0; i < length; i++) {
            if (arr1[i] != arr2[i]) {
                status = false;
            }
        }
        return status;
    }
    /**
     * @return {?}
     */
    initReady() {
        /** @type {?} */
        let realIdx = 0;
        for (let i = 0; i < this.clos; i++) {
            realIdx = this.indexArray[i];
            /** @type {?} */
            let min = 0;
            /** @type {?} */
            let max = 0;
            /** @type {?} */
            const tempArray = [];
            switch (realIdx) {
                case 0:
                    this.initData(tempArray, this.localMinDate[i], this.localMaxDate[i], this.localeNew.year, i);
                    break;
                case 1:
                    min = this.judgeEqualArray(this.min_date, this.current_time, 1) ? this.localMinDate[i] : 1;
                    max = this.judgeEqualArray(this.max_date, this.current_time, 1) ? this.localMaxDate[i] : 12;
                    this.initData(tempArray, min, max, this.localeNew.month, i);
                    break;
                case 2:
                    min = this.judgeEqualArray(this.min_date, this.current_time, 2)
                        ? this.localMinDate[i]
                        : (this.curTLessThanMin ? this.localMinDate[i] : 1);
                    max = this.judgeEqualArray(this.max_date, this.current_time, 2)
                        ? this.localMaxDate[i]
                        : new Date(this.current_time[0], this.current_time[1], 0).getDate();
                    this.initData(tempArray, min, max, this.localeNew.day, i);
                    break;
                case 3:
                    min = this.judgeEqualArray(this.min_date, this.current_time, 3)
                        ? this.localMinDate[i]
                        : (this.curTLessThanMin ? this.localMinDate[i] : 0);
                    max = this.judgeEqualArray(this.max_date, this.current_time, 3)
                        ? this.localMaxDate[i]
                        : (this.curTMoreThanMax ? this.localMaxDate[i] : 23);
                    this.initData(tempArray, min, max, this.localeNew.hour, i);
                    break;
                case 4:
                    min = this.judgeEqualArray(this.min_date, this.current_time, 4)
                        ? this.localMinDate[i]
                        : (this.curTLessThanMin ? this.localMinDate[i] : 0);
                    max = this.judgeEqualArray(this.max_date, this.current_time, 4)
                        ? this.localMaxDate[i]
                        : (this.curTMoreThanMax ? this.localMaxDate[i] : 59);
                    this.initData(tempArray, min, max, this.localeNew.minute, i);
                    break;
                case 5:
                    min = 0;
                    max = 1;
                    this.initData(tempArray, min, max, 'use12Hours', i);
                    break;
            }
        }
    }
    /**
     * @param {?} tempArr
     * @param {?} min
     * @param {?} max
     * @param {?} str
     * @param {?} idx
     * @return {?}
     */
    initData(tempArr, min, max, str, idx) {
        /** @type {?} */
        const dataWithStr = [];
        /** @type {?} */
        const increaseValue = str === this.localeNew.minute ? this.options.minuteStep : 1;
        for (min; min < max + 1; min += increaseValue) {
            tempArr.push(min);
            dataWithStr.push(min + str);
        }
        if (this.data.length > this.indexArray.length) {
            this.data = [];
            this.dataWithStr = [];
        }
        if (this.data.length > idx && this.data[idx].toString() !== tempArr.toString()) {
            this.data[idx] = tempArr;
        }
        else if (this.data.length > idx && this.data[idx].toString() === tempArr.toString()) {
            this.data[idx] = tempArr;
        }
        else {
            this.data.push(tempArr);
        }
        if (this.options.locale === undefined || this.options.locale.locale === 'zh_CN') {
            if (this.dataWithStr.length > idx && this.dataWithStr[idx].toString() !== dataWithStr.toString()) {
                this.dataWithStr[idx] = dataWithStr;
            }
            else if (this.dataWithStr.length > idx && this.dataWithStr[idx].toString() === dataWithStr.toString()) {
                this.dataWithStr[idx] = dataWithStr;
            }
            else {
                this.dataWithStr.push(dataWithStr);
            }
        }
        else {
            this.dataWithStr = this.data;
        }
    }
    /**
     * @return {?}
     */
    ok() {
        this.options.onOk.emit(this.handleReslut());
        this.setTransitionName();
    }
    /**
     * @return {?}
     */
    handleReslut() {
        /** @type {?} */
        let result = '';
        if (this.options.mode === 'datetime' || this.options.mode === 'time') {
            /** @type {?} */
            const temp = this.resultArr;
            result = temp.slice(0, 3).join('-') + ' ' + temp.slice(3, 5).join(':');
        }
        else {
            if (this.resultArr.length < 3) {
                this.resultArr.push('1');
            }
            result = this.resultArr.map((/**
             * @param {?} v
             * @return {?}
             */
            v => {
                return this.preZero(parseInt(v, 0));
            })).join('-');
        }
        this.resultDate = new Date(result.replace(/-/g, '/'));
        if (this.options.minDate.getTime() > this.resultDate.getTime()) {
            if (this.resultArr.length > 0) {
                for (let index = 0; index < this.resultArr.length; index++) {
                    this.resultArr = this.min_date;
                    this.currentTime = this.resultArr;
                    this.current_time = this.currentTime;
                }
            }
            this.resultDate = this.options.minDate;
        }
        return this.resultDate;
    }
    /**
     * @return {?}
     */
    cancel() {
        this.options.onDismiss.emit();
        this.setTransitionName();
    }
    /**
     * @return {?}
     */
    setTransitionName() {
        this.transitionName = 'am-slide-up-leave am-slide-up-leave-active';
        this.maskTransitionName = 'am-fade-leave am-fade-leave-active';
        setTimeout((/**
         * @return {?}
         */
        () => {
            this.options.hidePicker();
        }), 200);
    }
    /**
     * @param {?} checkIdx
     * @param {?} sta
     * @param {?} indexT
     * @return {?}
     */
    setCurrentSelected(checkIdx, sta, indexT) {
        if (checkIdx >= this.clos - 1) {
            return;
        }
        /** @type {?} */
        let status = null;
        if (sta) {
            status = this.judgeEqualArray(this.min_date, this.resultArr, checkIdx + 1);
        }
        else {
            status = this.judgeEqualArray(this.max_date, this.resultArr, checkIdx + 1);
        }
        if (!status) {
            /** @type {?} */
            let min = 0;
            /** @type {?} */
            let max = 0;
            /** @type {?} */
            let str = '';
            /** @type {?} */
            const realIdx = this.indexArray[checkIdx];
            switch (realIdx) {
                case 0:
                    min = this.judgeEqualArray(this.min_date, this.current_time, 1) ? this.localMinDate[checkIdx + 1] : 1;
                    max = this.judgeEqualArray(this.max_date, this.current_time, 1) ? this.localMaxDate[checkIdx + 1] : 12;
                    str = '月';
                    break;
                case 1:
                    min = this.judgeEqualArray(this.min_date, this.current_time, 2)
                        ? this.localMinDate[checkIdx + 1]
                        : (this.curTLessThanMin ? this.localMinDate[checkIdx + 1] : 1);
                    max = this.judgeEqualArray(this.max_date, this.current_time, 2)
                        ? this.localMaxDate[checkIdx + 1]
                        : new Date(this.current_time[0], this.current_time[1], 0).getDate();
                    str = '日';
                    break;
                case 2:
                    min = this.judgeEqualArray(this.min_date, this.current_time, 3)
                        ? this.localMinDate[checkIdx + 1]
                        : (this.curTLessThanMin ? this.localMinDate[checkIdx + 1] : 0);
                    max = this.judgeEqualArray(this.max_date, this.current_time, 3)
                        ? this.localMaxDate[checkIdx + 1]
                        : (this.curTMoreThanMax ? this.localMaxDate[checkIdx + 1] : 23);
                    str = '时';
                    break;
                case 3:
                    min = this.judgeEqualArray(this.min_date, this.current_time, 4)
                        ? this.localMinDate[checkIdx + 1]
                        : (this.curTLessThanMin ? this.localMinDate[checkIdx + 1] : 0);
                    max = this.judgeEqualArray(this.max_date, this.current_time, 4)
                        ? this.localMaxDate[checkIdx + 1]
                        : (this.curTMoreThanMax ? this.localMaxDate[checkIdx + 1] : 59);
                    str = '分';
                    break;
            }
            this.initRangeArr(min, max, indexT, checkIdx + 1, str);
        }
        this.setCurrentSelected(checkIdx + 1, sta, indexT);
    }
    /**
     * @param {?} min
     * @param {?} max
     * @param {?} indexT
     * @param {?} checkIdx
     * @param {?} str
     * @return {?}
     */
    initRangeArr(min, max, indexT, checkIdx, str) {
        /** @type {?} */
        const realIdx = this.indexArray[checkIdx];
        /** @type {?} */
        const arr = [];
        /** @type {?} */
        let targetLong = 0;
        /** @type {?} */
        const increaseValue = str === this.localeNew.minute ? this.options.minuteStep : 1;
        for (let index = min; index < max + 1; index += increaseValue) {
            arr.push(index);
        }
        if (arr.indexOf(this.resultArr[checkIdx]) == -1) {
            if (-this.selectedTarget[checkIdx].currentY > max - min) {
                indexT = max - min;
                this.selectedTarget[checkIdx].currentY = -indexT;
            }
            targetLong = -arr.length * this.lineHeight;
        }
        else {
            targetLong = -arr.indexOf(this.resultArr[checkIdx]) * this.lineHeight;
            this.selectedTarget[checkIdx].currentY = -arr.indexOf(this.resultArr[checkIdx]);
        }
        if (this.data[checkIdx].toString() !== arr.toString()) {
            if (checkIdx >= 3) {
                this.current_time[realIdx] = -targetLong / this.lineHeight;
                this.resultArr[checkIdx] = -targetLong / this.lineHeight;
            }
            else {
                this.current_time[realIdx] = -targetLong / this.lineHeight + 1;
                this.resultArr[checkIdx] = -targetLong / this.lineHeight + 1;
            }
            this.data[checkIdx] = arr;
            this.dataWithStr[checkIdx] =
                this.options.locale.locale === 'zh_CN'
                    ? arr.map((/**
                     * @param {?} item
                     * @return {?}
                     */
                    item => {
                        return item + str;
                    }))
                    : arr;
            setTimeout((/**
             * @return {?}
             */
            () => {
                this.selectedTarget.forEach((/**
                 * @param {?} item
                 * @param {?} i
                 * @return {?}
                 */
                (item, i) => {
                    if (i >= checkIdx) {
                        this.currentPicker.children[i].children[2].style.transition = '';
                        /** @type {?} */
                        const index = parseInt(item.currentY, 0);
                        this.currentPicker.children[i].children[2].style.transform = `translateY(${index * this.lineHeight}px)`;
                    }
                }));
            }), 0);
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    getEventTarget(event) {
        if (event.type === 'mousedown' ||
            event.type === 'mousemove' ||
            event.type === 'mouseup' ||
            event.type === 'mouseleave') {
            return event;
        }
        else {
            if (event && event.changedTouches && event.changedTouches[0]) {
                return event.changedTouches[0];
            }
            return null;
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.checkMode(this.options.mode);
        /** @type {?} */
        const value = this.transformDateFormat(this.options.value).split('-');
        if (value.length > 1) {
            this.current_time = this.currentTime = value.map((/**
             * @param {?} item
             * @return {?}
             */
            item => {
                return parseInt(item, 0);
            }));
        }
        else {
            this.currentTime = this.current_time;
        }
        this.localeProvider();
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.reloadPicker();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.unsubscribe$.next();
        this.unsubscribe$.complete();
    }
}
DatePickerComponent.decorators = [
    { type: Component, args: [{
                selector: 'DatePicker, nzm-date-picker',
                template: "<div *ngIf=\"options.mask\" class=\"am-picker-popup-mask {{maskTransitionName}}\" (click)=\"cancel()\"></div>\n<div class=\"am-picker-popup {{transitionName}}\" style=\"z-index: 1000\">\n  <div class=\"am-picker-popup-content\">\n    <div class=\"am-picker-popup-body\">\n      <div>\n        <div class=\"am-picker-popup-header\">\n          <div class=\"am-picker-popup-item am-picker-popup-header-left\"\n               (click)=\"cancel()\"\n          >\n            {{options.dismissText}}\n          </div>\n          <div class=\"am-picker-popup-item am-picker-popup-title\">{{options.title}}</div>\n          <div class=\"am-picker-popup-item am-picker-popup-header-right\"\n               (click)=\"ok()\"\n          >\n            {{options.okText}}\n          </div>\n        </div>\n        <div #picker\n             class=\"am-picker\"\n             style=\"flex-direction: row; align-items: center;\"\n        >\n          <div *ngFor=\"let item of dataWithStr; let i = index\" class=\"am-picker-col\">\n            <div class=\"am-picker-col-indicator \" style=\"top: 102px;\"></div>\n            <div id={{i}}\n                 class=\"am-picker-col-mask\"\n                 style=\"background-size: 100% 102px;\"\n            ></div>\n            <div class=\"am-picker-col-content\">\n              <div id={{i}}\n                   class=\"am-picker-col-item\"\n                   *ngFor=\"let val of item; let i = index\"\n              >{{val.label?val.label:val}}</div>\n            </div>\n          </div>\n        </div>\n      </div>\n    </div>\n  </div>\n</div>\n",
                encapsulation: ViewEncapsulation.None
            }] }
];
/** @nocollapse */
DatePickerComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: DatePickerOptions },
    { type: ToastService },
    { type: LocaleProviderService }
];
DatePickerComponent.propDecorators = {
    picker: [{ type: ViewChild, args: ['picker', { read: ViewContainerRef },] }],
    panstart: [{ type: HostListener, args: ['mousedown', ['$event'],] }, { type: HostListener, args: ['touchstart', ['$event'],] }],
    panmove: [{ type: HostListener, args: ['mousemove', ['$event'],] }, { type: HostListener, args: ['touchmove', ['$event'],] }],
    panend: [{ type: HostListener, args: ['mouseleave', ['$event'],] }, { type: HostListener, args: ['mouseup', ['$event'],] }, { type: HostListener, args: ['touchend', ['$event'],] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DatePickerViewComponent extends DatePickerComponent {
    constructor() {
        super(...arguments);
        this.mode = 'date';
        this.minDate = new Date(2000, 5, 1, 0, 0, 0);
        this.maxDate = new Date(2030, 1, 1, 23, 59, 59);
        this.value = new Date();
        this.disabled = false;
        this.indicatorStyle = {};
        this.showErrorToast = true;
        this.showErrorToastInterval = 2000;
        this.onValueChange = new EventEmitter();
        this.amPicker = true;
    }
    /**
     * @return {?}
     */
    get locale() {
        return this.options.locale;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set locale(value) {
        this.options.locale = value;
        this.unsubscribe$.next();
        this.unsubscribe$.complete();
    }
    /**
     * @return {?}
     */
    reloadPicker() {
        if (this.currentPicker) {
            /** @type {?} */
            const self = this;
            setTimeout((/**
             * @return {?}
             */
            () => {
                self.selectedTarget.forEach((/**
                 * @param {?} item
                 * @param {?} i
                 * @return {?}
                 */
                (item, i) => {
                    self.currentPicker.children[i].children[2].style.transition = 'transform .3s';
                    /** @type {?} */
                    const index = parseInt(item.currentY, 0);
                    self.currentPicker.children[i].children[2].style.transform = `translateY(${index * self.lineHeight}px)`;
                }));
            }), 0);
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        if (value) {
            this.value = value;
            this.optionInit();
            this.init();
        }
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.ngModelOnChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.ngModelOnTouched = fn;
    }
    /**
     * @param {?} isDisabled
     * @return {?}
     */
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
    /**
     * @return {?}
     */
    optionInit() {
        this.options.mode = this.mode;
        this.options.minDate = this.minDate;
        this.options.maxDate = this.maxDate;
        this.options.disabled = this.disabled;
        this.options.locale = this.locale;
        this.options.value = this.value;
        this.options.showErrorToast = this.showErrorToast;
        this.options.showErrorToastInterval = this.showErrorToastInterval;
        this.options.onValueChange = this.onValueChange;
        this.checkMode(this.options.mode);
        /** @type {?} */
        const value = this.transformDateFormat(this.options.value).split('-');
        if (value.length > 0) {
            this.currentTime = value.map((/**
             * @param {?} item
             * @return {?}
             */
            item => {
                return parseInt(item, 0);
            }));
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.optionInit();
        this.localeProvider();
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.currentPicker = this.elementRef.nativeElement;
        this.reloadPicker();
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes.value) {
            this.options.value = changes.value.currentValue;
            /** @type {?} */
            const value = this.transformDateFormat(this.options.value).split('-');
            if (value.length > 0) {
                this.currentTime = value.map((/**
                 * @param {?} item
                 * @return {?}
                 */
                item => {
                    return parseInt(item, 0);
                }));
            }
            if (!this.judgeEqualArray(this.currentTime, this.resultArr, this.resultArr.length) ||
                this.judgeEqualArray(this.currentTime, this.min_date, this.currentTime.length) ||
                this.judgeTime(this.currentTime, this.max_date)) {
                this.optionInit();
                this.init();
            }
        }
        if (changes.mode || changes.minDate || changes.maxDate || changes.disabled || changes.locale) {
            this.optionInit();
            this.init();
        }
    }
}
DatePickerViewComponent.decorators = [
    { type: Component, args: [{
                selector: 'DatePickerView, nzm-date-picker-view',
                template: "<div *ngFor=\"let item of dataWithStr; let i = index\" class=\"am-picker-col\">\n  <div class=\"am-picker-col-indicator \" style=\"top: 102px;\" [ngStyle]=\"indicatorStyle\"></div>\n  <div id={{i}} class=\"am-picker-col-mask\" style=\"background-size: 100% 102px;\"></div>\n  <div class=\"am-picker-col-content\">\n    <div id={{i}} *ngFor=\"let val of item; let i = index\" class=\"am-picker-col-item\">{{val.label?val.label:val}}</div>\n  </div>\n</div>\n",
                encapsulation: ViewEncapsulation.None,
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => DatePickerViewComponent)),
                        multi: true
                    }
                ]
            }] }
];
DatePickerViewComponent.propDecorators = {
    mode: [{ type: Input }],
    minDate: [{ type: Input }],
    maxDate: [{ type: Input }],
    value: [{ type: Input }],
    disabled: [{ type: Input }],
    indicatorStyle: [{ type: Input }],
    locale: [{ type: Input }],
    showErrorToast: [{ type: Input }],
    showErrorToastInterval: [{ type: Input }],
    onValueChange: [{ type: Output }],
    amPicker: [{ type: HostBinding, args: ['class.am-picker',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DatePickerDirective {
    /**
     * @param {?} _viewContainerRef
     * @param {?} _defaultOptions
     * @param {?} _cfr
     */
    constructor(_viewContainerRef, _defaultOptions, _cfr) {
        this._viewContainerRef = _viewContainerRef;
        this._defaultOptions = _defaultOptions;
        this._cfr = _cfr;
        this._eventListeners = [];
        this.minuteStep = 1;
        this.value = new Date();
        this.onVisibleChange = new EventEmitter(true);
        this.onValueChange = new EventEmitter();
        this.onOk = new EventEmitter();
        this.onDismiss = new EventEmitter();
    }
    /**
     * @return {?}
     */
    togglePicker() {
        if (!this.picker) {
            this.showPicker();
        }
        else {
            this.hidePicker();
        }
    }
    /**
     * @return {?}
     */
    showPicker() {
        if (!this.picker && !this.disabled) {
            setTimeout((/**
             * @return {?}
             */
            () => {
                this._eventListeners = [];
            }));
            /** @type {?} */
            const options = new DatePickerOptions();
            Object.assign(options, this._defaultOptions, {
                hidePicker: (/**
                 * @param {?} event
                 * @return {?}
                 */
                (event) => {
                    this.hidePicker();
                }),
                updateNgModel: (/**
                 * @param {?} value
                 * @return {?}
                 */
                (value) => {
                    if (this._ngModelOnChange) {
                        this.value = value;
                        this._ngModelOnChange(value);
                    }
                })
            });
            /** @type {?} */
            const optionalParams = [
                'mode',
                'minDate',
                'maxDate',
                'minuteStep',
                'value',
                'mask',
                'title',
                'okText',
                'dismissText',
                'disabled',
                'locale',
                'appendToBody',
                'showErrorToast',
                'showErrorToastInterval',
                'onOk',
                'onDismiss',
                'onValueChange'
            ];
            optionalParams.forEach((/**
             * @param {?} param
             * @return {?}
             */
            param => {
                if (typeof this[param] !== 'undefined') {
                    ((/** @type {?} */ (options)))[param] = this[param];
                }
            }));
            /** @type {?} */
            const componentFactory = this._cfr.resolveComponentFactory(DatePickerComponent);
            /** @type {?} */
            const childInjector = Injector.create([
                {
                    provide: DatePickerOptions,
                    useValue: options
                }
            ]);
            this.picker = this._viewContainerRef.createComponent(componentFactory, this._viewContainerRef.length, childInjector);
            if (options.appendToBody) {
                document.body.appendChild(this.picker.location.nativeElement);
            }
            this.onVisibleChange.emit(true);
        }
    }
    /**
     * @return {?}
     */
    hidePicker() {
        if (this.picker) {
            this.picker.destroy();
            delete this.picker;
            this.onVisibleChange.emit(false);
            this._eventListeners.forEach((/**
             * @param {?} fn
             * @return {?}
             */
            fn => fn()));
            this._eventListeners = [];
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        this.value = value;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this._ngModelOnChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this._ngModelOnTouched = fn;
    }
    /**
     * @param {?} isDisabled
     * @return {?}
     */
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.onVisibleChange.emit(false);
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes.isOpen) {
            if (changes.isOpen.currentValue === true) {
                this.showPicker();
            }
            else {
                this.hidePicker();
            }
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.hidePicker();
    }
}
DatePickerDirective.decorators = [
    { type: Directive, args: [{
                selector: '[DatePicker]',
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => DatePickerDirective)),
                        multi: true
                    }
                ]
            },] }
];
/** @nocollapse */
DatePickerDirective.ctorParameters = () => [
    { type: ViewContainerRef },
    { type: DatePickerOptions },
    { type: ComponentFactoryResolver }
];
DatePickerDirective.propDecorators = {
    isOpen: [{ type: Input }],
    mode: [{ type: Input }],
    minDate: [{ type: Input }],
    maxDate: [{ type: Input }],
    use12Hours: [{ type: Input }],
    minuteStep: [{ type: Input }],
    value: [{ type: Input }],
    mask: [{ type: Input }],
    title: [{ type: Input }],
    okText: [{ type: Input }],
    dismissText: [{ type: Input }],
    disabled: [{ type: Input }],
    locale: [{ type: Input }],
    appendToBody: [{ type: Input }],
    showErrorToast: [{ type: Input }],
    showErrorToastInterval: [{ type: Input }],
    onVisibleChange: [{ type: Output }],
    onValueChange: [{ type: Output }],
    onOk: [{ type: Output }],
    onDismiss: [{ type: Output }],
    togglePicker: [{ type: HostListener, args: ['click',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DatePickerModule {
}
DatePickerModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, LocaleProviderModule, ToastModule, FormsModule],
                exports: [DatePickerComponent, DatePickerDirective],
                declarations: [DatePickerComponent, DatePickerDirective],
                entryComponents: [DatePickerComponent],
                providers: [DatePickerOptions, LocaleProviderModule]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DatePickerViewModule {
}
DatePickerViewModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, DatePickerModule, LocaleProviderModule, ToastModule, FormsModule],
                exports: [DatePickerViewComponent],
                declarations: [DatePickerViewComponent],
                providers: [LocaleProviderModule]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CalendarSingleMonthComponent {
    /**
     * @param {?} _elementRef
     */
    constructor(_elementRef) {
        this._elementRef = _elementRef;
        this.props = (/** @type {?} */ ({
            rowSize: 'normal'
        }));
        this.state = {
            weekComponents: []
        };
        this.singleMonth = true;
        this.genWeek = (/**
         * @param {?} weeksData
         * @param {?} index
         * @return {?}
         */
        (weeksData, index) => {
            const { getDateExtra, monthData, onCellClick, locale, rowSize } = this.props;
            /** @type {?} */
            let rowCls = 'row';
            /** @type {?} */
            let weeksDataList = [];
            if (rowSize === 'xl') {
                rowCls += ' row-xl';
            }
            weeksData.forEach((/**
             * @param {?} day
             * @param {?} dayOfWeek
             * @return {?}
             */
            (day, dayOfWeek) => {
                /** @type {?} */
                const extra = (getDateExtra && getDateExtra(new Date(day.tick))) || {};
                /** @type {?} */
                let info = extra.info;
                /** @type {?} */
                const disable = extra.disable || day.outOfDate;
                /** @type {?} */
                let cls = 'date';
                /** @type {?} */
                let lCls = 'left';
                /** @type {?} */
                let rCls = 'right';
                /** @type {?} */
                let infoCls = 'info';
                if (dayOfWeek === 0 || dayOfWeek === 6) {
                    cls += ' grey';
                }
                if (disable) {
                    cls += ' disable';
                }
                else if (info) {
                    cls += ' important';
                }
                if (day.selected) {
                    cls += ' date-selected';
                    /** @type {?} */
                    let styleType = day.selected;
                    switch (styleType) {
                        case DateModels.SelectType.Only:
                            info = locale.begin;
                            infoCls += ' date-selected';
                            break;
                        case DateModels.SelectType.All:
                            info = locale.begin_over;
                            infoCls += ' date-selected';
                            break;
                        case DateModels.SelectType.Start:
                            info = locale.begin;
                            infoCls += ' date-selected';
                            if (dayOfWeek === 6 || day.isLastOfMonth) {
                                styleType = DateModels.SelectType.All;
                            }
                            break;
                        case DateModels.SelectType.Middle:
                            if (dayOfWeek === 0 || day.isFirstOfMonth) {
                                if (day.isLastOfMonth || dayOfWeek === 6) {
                                    styleType = DateModels.SelectType.All;
                                }
                                else {
                                    styleType = DateModels.SelectType.Start;
                                }
                            }
                            else if (dayOfWeek === 6 || day.isLastOfMonth) {
                                styleType = DateModels.SelectType.End;
                            }
                            break;
                        case DateModels.SelectType.End:
                            info = locale.over;
                            infoCls += ' date-selected';
                            if (dayOfWeek === 0 || day.isFirstOfMonth) {
                                styleType = DateModels.SelectType.All;
                            }
                            break;
                    }
                    switch (styleType) {
                        case DateModels.SelectType.Single:
                        case DateModels.SelectType.Only:
                        case DateModels.SelectType.All:
                            cls += ' selected-single';
                            break;
                        case DateModels.SelectType.Start:
                            cls += ' selected-start';
                            rCls += ' date-selected';
                            break;
                        case DateModels.SelectType.Middle:
                            cls += ' selected-middle';
                            lCls += ' date-selected';
                            rCls += ' date-selected';
                            break;
                        case DateModels.SelectType.End:
                            cls += ' selected-end';
                            lCls += ' date-selected';
                            break;
                    }
                }
                weeksDataList[dayOfWeek] = {
                    lCls,
                    cls,
                    day,
                    rCls,
                    infoCls,
                    info,
                    extra,
                    disable,
                    onCellClick: onCellClick,
                    monthData
                };
            }));
            this.state.weekComponents[index] = {
                index: index,
                rowCls,
                weeksDataList
            };
        });
        this.updateWeeks = (/**
         * @param {?=} monthData
         * @return {?}
         */
        (monthData) => {
            (monthData || this.props.monthData).weeks.forEach((/**
             * @param {?} week
             * @param {?} index
             * @return {?}
             */
            (week, index) => {
                this.genWeek(week, index);
            }));
        });
        this.setWarpper = (/**
         * @param {?} dom
         * @return {?}
         */
        (dom) => {
            this.wrapperDivDOM = dom;
        });
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set data(value) {
        this.props = Object.assign({}, this.props, value);
    }
    /**
     * @param {?} item
     * @return {?}
     */
    onClickCell(item) {
        !item.disable && item.onCellClick && item.onCellClick(item.day, item.monthData);
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.setWarpper(this._elementRef.nativeElement);
        this.props.monthData.weeks.forEach((/**
         * @param {?} week
         * @param {?} index
         * @return {?}
         */
        (week, index) => {
            this.genWeek(week, index);
        }));
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.ref = this.props.ref;
        this.ref(this);
    }
}
CalendarSingleMonthComponent.decorators = [
    { type: Component, args: [{
                selector: 'CalendarSingleMonth, nzm-single-month',
                template: "<div class=\"month-title\">\n  {{props.monthData.title}}\n</div>\n<div class=\"date\">\n  <div *ngFor=\"let row of state.weekComponents;let i = index;\" [ngClass]=\"row.rowCls\">\n    <div *ngFor=\"let cell of row.weeksDataList;let j = index;\"\n         class=\"{{'cell ' + (row.extra && row.extra.cellCls || '')}}\"\n         (click)=\"onClickCell(cell)\"\n    >\n      <div *ngIf=\"row.extra && row.extra.cellRender\">test</div>\n      <div *ngIf=\"!row.extra || (row.extra && row.extra.cellRender)\" class=\"date-wrapper\">\n        <span [ngClass]=\"cell.lCls\"></span>\n        <div [ngClass]=\"cell.cls\">\n          {{cell.day && cell.day.dayOfMonth || ''}}\n        </div>\n        <span [ngClass]=\"cell.rCls\"></span>\n      </div>\n      <div *ngIf=\"!row.extra || (row.extra && row.extra.cellRender)\" [ngClass]=\"cell.infoCls\">\n        {{cell.info}}\n      </div>\n    </div>\n  </div>\n</div>\n",
                encapsulation: ViewEncapsulation.None
            }] }
];
/** @nocollapse */
CalendarSingleMonthComponent.ctorParameters = () => [
    { type: ElementRef }
];
CalendarSingleMonthComponent.propDecorators = {
    data: [{ type: Input }],
    singleMonth: [{ type: HostBinding, args: ['class.single-month',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CalendarConfirmPanelComponent {
    constructor() {
        this.props = (/** @type {?} */ ({
            formatStr: 'yyyy-MM-dd hh:mm'
        }));
        this.confirmPane = true;
        this.triggerConfirm = (/**
         * @return {?}
         */
        () => {
            const { onConfirm, disableBtn } = this.props;
            !disableBtn && onConfirm();
        });
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set propsData(value) {
        this.props = Object.assign({}, this.props, value);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set disableBtn(value) {
        this.props.disableBtn = value;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set formatStr(value) {
        this.props.formatStr = value;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set startDateTime(value) {
        this.props.startDateTime = value;
        this.formatTime();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set endDateTime(value) {
        this.props.endDateTime = value;
        this.formatTime();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set onConfirm(value) {
        this.props.onConfirm = value;
    }
    /**
     * @return {?}
     */
    formatTime() {
        const { type, locale, disableBtn } = this.props;
        let { startDateTime, endDateTime } = this.props;
        if (startDateTime && endDateTime && +startDateTime > +endDateTime) {
            /** @type {?} */
            const tmp = startDateTime;
            startDateTime = endDateTime;
            endDateTime = tmp;
        }
        this.startTimeStr = startDateTime ? this.selfFormatDate(startDateTime) : locale.noChoose;
        this.endTimeStr = endDateTime ? this.selfFormatDate(endDateTime) : locale.noChoose;
        /** @type {?} */
        let btnCls = disableBtn ? 'button button-disable' : 'button';
        if (type === 'one') {
            btnCls += ' button-full';
        }
        this.btnCls = btnCls;
    }
    /**
     * @param {?} date
     * @return {?}
     */
    selfFormatDate(date) {
        const { formatStr = '', locale } = this.props;
        return formatDate(date, formatStr, locale);
    }
}
CalendarConfirmPanelComponent.decorators = [
    { type: Component, args: [{
                selector: 'CalendarConfirmPanel, nzm-calendar-confirm-panel',
                template: "<div *ngIf=\"props.type === 'range'\" class=\"info\">\n  <p>{{props.locale.start}}: <span class=\"{{!props.startDateTime ? 'grey' : ''}}\">{{startTimeStr}}</span></p>\n  <p>{{props.locale.end}}: <span class=\"{{!props.endDateTime ? 'grey' : ''}}\">{{endTimeStr}}</span></p>\n</div>\n<div [ngClass]=\"btnCls\" (click)=\"triggerConfirm()\">\n  {{props.locale.confirm}}\n</div>\n",
                encapsulation: ViewEncapsulation.None
            }] }
];
/** @nocollapse */
CalendarConfirmPanelComponent.ctorParameters = () => [];
CalendarConfirmPanelComponent.propDecorators = {
    propsData: [{ type: Input }],
    disableBtn: [{ type: Input }],
    formatStr: [{ type: Input }],
    startDateTime: [{ type: Input }],
    endDateTime: [{ type: Input }],
    onConfirm: [{ type: Input }],
    confirmPane: [{ type: HostBinding, args: ['class.confirm-panel',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CalendarShortcutPanelComponent {
    constructor() {
        this.props = (/** @type {?} */ ({}));
        this.shortcutPanel = true;
        this.onClick = (/**
         * @param {?} type
         * @return {?}
         */
        (type) => {
            const { onSelect } = this.props;
            /** @type {?} */
            const today = new Date();
            switch (type) {
                case 'today':
                    onSelect(new Date(today.getFullYear(), today.getMonth(), today.getDate(), 0), new Date(today.getFullYear(), today.getMonth(), today.getDate(), 12));
                    break;
                case 'yesterday':
                    onSelect(new Date(today.getFullYear(), today.getMonth(), today.getDate() - 1, 0), new Date(today.getFullYear(), today.getMonth(), today.getDate() - 1, 12));
                    break;
                case 'lastweek':
                    onSelect(new Date(today.getFullYear(), today.getMonth(), today.getDate() - 6, 0), new Date(today.getFullYear(), today.getMonth(), today.getDate(), 12));
                    break;
                case 'lastmonth':
                    onSelect(new Date(today.getFullYear(), today.getMonth(), today.getDate() - 29, 0), new Date(today.getFullYear(), today.getMonth(), today.getDate(), 12));
                    break;
            }
        });
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set locale(value) {
        this.props.locale = value;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set onSelect(value) {
        this.props.onSelect = value;
    }
}
CalendarShortcutPanelComponent.decorators = [
    { type: Component, args: [{
                selector: 'CalendarShortcutPanel, nzm-calendar-shortcut-panel',
                template: "<div class=\"item\" (click)=\"onClick('today')\">{{props.locale.today}}</div>\n<div class=\"item\" (click)=\"onClick('yesterday')\">{{props.locale.yesterday}}</div>\n<div class=\"item\" (click)=\"onClick('lastweek')\">{{props.locale.lastWeek}}</div>\n<div class=\"item\" (click)=\"onClick('lastmonth')\">{{props.locale.lastMonth}}</div>\n",
                encapsulation: ViewEncapsulation.None
            }] }
];
/** @nocollapse */
CalendarShortcutPanelComponent.ctorParameters = () => [];
CalendarShortcutPanelComponent.propDecorators = {
    locale: [{ type: Input }],
    onSelect: [{ type: Input }],
    shortcutPanel: [{ type: HostBinding, args: ['class.shortcut-panel',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CalendarModule {
}
CalendarModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, IconModule, DatePickerViewModule, LocaleProviderModule],
                declarations: [
                    CalendarComponent,
                    CalendarHeaderComponent,
                    CalendarWeekPanelComponent,
                    CalendarDatePickerComponent,
                    CalendarTimePickerComponent,
                    CalendarSingleMonthComponent,
                    CalendarConfirmPanelComponent,
                    CalendarShortcutPanelComponent
                ],
                exports: [
                    CalendarComponent,
                    CalendarHeaderComponent,
                    CalendarWeekPanelComponent,
                    CalendarDatePickerComponent,
                    CalendarTimePickerComponent,
                    CalendarSingleMonthComponent,
                    CalendarConfirmPanelComponent,
                    CalendarShortcutPanelComponent
                ],
                providers: [LocaleProviderModule]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PopoverItemComponent {
    /**
     * @param {?} _elementRef
     */
    constructor(_elementRef) {
        this._elementRef = _elementRef;
        this.defaultProps = {
            prefixCls: 'am-popover',
            disabled: false
        };
        this.isActive = false;
        this.select = new EventEmitter();
        this.amPopoverItem = true;
    }
    /**
     * @return {?}
     */
    get icon() {
        return this._icon;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set icon(value) {
        this._icon = value;
    }
    /**
     * @return {?}
     */
    get style() {
        return this._style;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set style(value) {
        this._style = value;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set disabled(value) {
        this.defaultProps.disabled = value;
    }
    /**
     * @return {?}
     */
    get amPopoverItemActive() {
        return this.isActive;
    }
    /**
     * @return {?}
     */
    get amPopoverItemDisabled() {
        return this.defaultProps.disabled;
    }
    /**
     * @param {?} e
     * @return {?}
     */
    touchStart(e) {
        this.select.emit();
        this.isActive = true;
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() { }
}
PopoverItemComponent.decorators = [
    { type: Component, args: [{
                selector: 'PopoverItem, nzm-popover-item',
                template: "<div class=\"{{defaultProps.prefixCls}}-item-container\">\n  <span class=\"{{defaultProps.prefixCls}}-item-icon\" aria-hidden=\"true\">\n    <ng-template [ngTemplateOutlet]=\"icon\"></ng-template>\n  </span>\n  <span class=\"{{defaultProps.prefixCls}}-item-content\">\n    <ng-content></ng-content>\n  </span>\n</div>\n",
                encapsulation: ViewEncapsulation.None
            }] }
];
/** @nocollapse */
PopoverItemComponent.ctorParameters = () => [
    { type: ElementRef }
];
PopoverItemComponent.propDecorators = {
    icon: [{ type: Input }],
    style: [{ type: Input }],
    disabled: [{ type: Input }],
    select: [{ type: Output }],
    amPopoverItem: [{ type: HostBinding, args: ['class.am-popover-item',] }],
    amPopoverItemActive: [{ type: HostBinding, args: ['class.am-popover-item-active',] }],
    amPopoverItemDisabled: [{ type: HostBinding, args: ['class.am-popover-item-disabled',] }],
    touchStart: [{ type: HostListener, args: ['touchstart', ['$event'],] }, { type: HostListener, args: ['mousedown', ['$event'],] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PopoverItemModule {
}
PopoverItemModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, IconModule],
                exports: [PopoverItemComponent],
                declarations: [PopoverItemComponent]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FlexComponent {
    constructor() {
        this.defaultProps = {
            prefixCls: 'am-flexbox',
            align: 'center'
        };
        // _wrapCls = {};
        this._direction = '';
        this._justify = '';
        this._alignContent = '';
        this.amFlexbox = true;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set direction(value) {
        this._direction = value;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set wrap(value) {
        this._wrap = value;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set justify(value) {
        this._justify = value;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set align(value) {
        this.defaultProps.align = value;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set alignContent(value) {
        this._alignContent = value;
    }
    /**
     * @return {?}
     */
    get amFlexboxDirRow() {
        return this._direction === 'row';
    }
    /**
     * @return {?}
     */
    get amFlexboxDirRowReverse() {
        return this._direction === 'row-reverse';
    }
    /**
     * @return {?}
     */
    get amFlexboxDirColumn() {
        return this._direction === 'column';
    }
    /**
     * @return {?}
     */
    get amFlexboxDirColumnReverse() {
        return this._direction === 'column-reverse';
    }
    /**
     * @return {?}
     */
    get amFlexboxNowrap() {
        return this._wrap === 'nowrap';
    }
    /**
     * @return {?}
     */
    get amFlexboxWrap() {
        return this._wrap === 'wrap';
    }
    /**
     * @return {?}
     */
    get amFlexboxWrapReverse() {
        return this._wrap === 'wrap-reverse';
    }
    /**
     * @return {?}
     */
    get amFlexboxJustifyStart() {
        return this._justify === 'start';
    }
    /**
     * @return {?}
     */
    get amFlexboxJustifyCenter() {
        return this._justify === 'center';
    }
    /**
     * @return {?}
     */
    get amFlexboxJustifyEnd() {
        return this._justify === 'end';
    }
    /**
     * @return {?}
     */
    get amFlexboxJustifyBetween() {
        return this._justify === 'between';
    }
    /**
     * @return {?}
     */
    get amFlexboxAlignAround() {
        return this._justify === 'around';
    }
    /**
     * @return {?}
     */
    get amFlexboxAlignStart() {
        return this.defaultProps.align === 'start';
    }
    /**
     * @return {?}
     */
    get amFlexboxAlignCenter() {
        return this.defaultProps.align === 'center';
    }
    /**
     * @return {?}
     */
    get amFlexboxAlignEnd() {
        return this.defaultProps.align === 'end';
    }
    /**
     * @return {?}
     */
    get amFlexboxAlignBaseline() {
        return this.defaultProps.align === 'baseline';
    }
    /**
     * @return {?}
     */
    get amFlexboxAlignStretch() {
        return this.defaultProps.align === 'stretch';
    }
    /**
     * @return {?}
     */
    get amFlexboxAlignContentStart() {
        return this._alignContent === 'start';
    }
    /**
     * @return {?}
     */
    get amFlexboxAlignCotentCenter() {
        return this._alignContent === 'center';
    }
    /**
     * @return {?}
     */
    get amFlexboxAlignContentEnd() {
        return this._alignContent === 'end';
    }
    /**
     * @return {?}
     */
    get amFlexboxAlignContentBetween() {
        return this._alignContent === 'between';
    }
    /**
     * @return {?}
     */
    get amFlexboxAlignContentAround() {
        return this._alignContent === 'around';
    }
    /**
     * @return {?}
     */
    get amFlexboxAlignContentStretch() {
        return this._alignContent === 'stretch';
    }
}
FlexComponent.decorators = [
    { type: Component, args: [{
                selector: 'Flex, nzm-flex',
                template: "<ng-content></ng-content>\n",
                encapsulation: ViewEncapsulation.None
            }] }
];
/** @nocollapse */
FlexComponent.ctorParameters = () => [];
FlexComponent.propDecorators = {
    direction: [{ type: Input }],
    wrap: [{ type: Input }],
    justify: [{ type: Input }],
    align: [{ type: Input }],
    alignContent: [{ type: Input }],
    amFlexbox: [{ type: HostBinding, args: ['class.am-flexbox',] }],
    amFlexboxDirRow: [{ type: HostBinding, args: ['class.am-flexbox-dir-row',] }],
    amFlexboxDirRowReverse: [{ type: HostBinding, args: ['class.am-flexbox-dir-row-reverse',] }],
    amFlexboxDirColumn: [{ type: HostBinding, args: ['class.am-flexbox-dir-column',] }],
    amFlexboxDirColumnReverse: [{ type: HostBinding, args: ['class.am-flexbox-dir-column-reverse',] }],
    amFlexboxNowrap: [{ type: HostBinding, args: ['class.am-flexbox-nowrap',] }],
    amFlexboxWrap: [{ type: HostBinding, args: ['class.am-flexbox-wrap',] }],
    amFlexboxWrapReverse: [{ type: HostBinding, args: ['class.am-flexbox-wrap-reverse',] }],
    amFlexboxJustifyStart: [{ type: HostBinding, args: ['class.am-flexbox-justify-start',] }],
    amFlexboxJustifyCenter: [{ type: HostBinding, args: ['class.am-flexbox-justify-center',] }],
    amFlexboxJustifyEnd: [{ type: HostBinding, args: ['class.am-flexbox-justify-end',] }],
    amFlexboxJustifyBetween: [{ type: HostBinding, args: ['class.am-flexbox-justify-between',] }],
    amFlexboxAlignAround: [{ type: HostBinding, args: ['class.am-flexbox-justify-around',] }],
    amFlexboxAlignStart: [{ type: HostBinding, args: ['class.am-flexbox-align-start',] }],
    amFlexboxAlignCenter: [{ type: HostBinding, args: ['class.am-flexbox-align-center',] }],
    amFlexboxAlignEnd: [{ type: HostBinding, args: ['class.am-flexbox-align-end',] }],
    amFlexboxAlignBaseline: [{ type: HostBinding, args: ['class.am-flexbox-align-baseline',] }],
    amFlexboxAlignStretch: [{ type: HostBinding, args: ['class.am-flexbox-align-stretch',] }],
    amFlexboxAlignContentStart: [{ type: HostBinding, args: ['class.am-flexbox-align-content-start',] }],
    amFlexboxAlignCotentCenter: [{ type: HostBinding, args: ['class.am-flexbox-align-content-center',] }],
    amFlexboxAlignContentEnd: [{ type: HostBinding, args: ['class.am-flexbox-align-content-end',] }],
    amFlexboxAlignContentBetween: [{ type: HostBinding, args: ['class.am-flexbox-align-content-between',] }],
    amFlexboxAlignContentAround: [{ type: HostBinding, args: ['class.am-flexbox-align-content-around',] }],
    amFlexboxAlignContentStretch: [{ type: HostBinding, args: ['class.am-flexbox-align-content-stretch',] }]
};
class FlexItemComponent {
    constructor() {
        this.defaultProps = {
            prefixCls: 'am-flexbox',
            align: 'center'
        };
        this.flexboxItem = true;
    }
}
FlexItemComponent.decorators = [
    { type: Component, args: [{
                selector: 'FlexItem, nzm-flex-item',
                template: `
    <ng-content></ng-content>
  `,
                encapsulation: ViewEncapsulation.None
            }] }
];
FlexItemComponent.propDecorators = {
    flexboxItem: [{ type: HostBinding, args: ['class.am-flexbox-item',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FlexModule {
}
FlexModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                exports: [FlexComponent, FlexItemComponent],
                declarations: [FlexComponent, FlexItemComponent]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class GridComponent {
    constructor() {
        this.wrapCls = {};
        this.itemCls = {};
        this.carouselProps = {
            dots: false,
            dragging: false
        };
        this.defaultProps = {
            data: [],
            hasLine: true,
            isCarousel: false,
            columnNum: 4,
            carouselMaxRow: 2,
            prefixCls: 'am-grid',
            square: true,
            itemStyle: {}
        };
        this.carouselData = [];
        this.carouselDataTmp = [];
        this.gridData = [];
        this._data = [];
        this.columnNum = 4;
        this.carouselMaxRow = 2;
        this.itemStyle = {};
        this.square = true;
        this.hasLine = true;
        this.activeStyle = true;
        this.onClick = new EventEmitter();
        this.amGrid = true;
    }
    /**
     * @return {?}
     */
    get isCarousel() {
        return this.defaultProps.isCarousel;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set isCarousel(value) {
        this.defaultProps.isCarousel = value;
        this.init();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set data(value) {
        this._data = value;
        this.init();
    }
    /**
     * @return {?}
     */
    get amGridSquare() {
        return true === this.square;
    }
    /**
     * @return {?}
     */
    get amGridLine() {
        return true === this.hasLine;
    }
    /**
     * @return {?}
     */
    get amGridCarousel() {
        return true === this.isCarousel;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    getContentType(value) {
        if ((value.indexOf('http') >= 0 || value.indexOf('assets') >= 0) && value.indexOf('<') < 0) {
            return 'url';
        }
        else if (value.indexOf('<') >= 0) {
            return 'innerHTML';
        }
        else if (value instanceof TemplateRef) {
            return 'TemplateRef';
        }
        else {
            return 'icon';
        }
    }
    /**
     * @return {?}
     */
    init() {
        /** @type {?} */
        const dataLength = (this._data && this._data.length) || 0;
        /** @type {?} */
        let rowCount = Math.ceil(dataLength / this.columnNum);
        /** @type {?} */
        let rowsArr;
        if (this.defaultProps.isCarousel) {
            if (rowCount % this.carouselMaxRow !== 0) {
                rowCount = rowCount + this.carouselMaxRow - (rowCount % this.carouselMaxRow);
            }
            /** @type {?} */
            const pageCount = Math.ceil(rowCount / this.carouselMaxRow);
            rowsArr = this.getRows(rowCount, dataLength);
            if (pageCount <= 1) {
                this.carouselProps = {
                    dots: false,
                    dragging: false
                };
            }
            else {
                this.carouselProps = {
                    dots: true,
                    dragging: true
                };
            }
            this.carouselDataTmp = this.getCarouselData(rowsArr, pageCount, rowCount);
        }
        else {
            this.gridData = this.getRows(rowCount, dataLength);
        }
    }
    /**
     * @param {?} rowsArr
     * @param {?} pageCount
     * @param {?} rowCount
     * @return {?}
     */
    getCarouselData(rowsArr, pageCount, rowCount) {
        /** @type {?} */
        const pagesArr = [];
        for (let pageIndex = 0; pageIndex < pageCount; pageIndex++) {
            /** @type {?} */
            const pageRows = [];
            for (let ii = 0; ii < this.carouselMaxRow; ii++) {
                /** @type {?} */
                const rowIndex = pageIndex * this.carouselMaxRow + ii;
                if (rowIndex < rowCount) {
                    pageRows.push(rowsArr[rowIndex]);
                }
                else {
                    // 空节点为了确保末尾页的最后未到底的行有底线(样式中last-child会没线)
                    pageRows.push(null);
                }
            }
            pagesArr.push(pageRows);
        }
        return pagesArr;
    }
    /**
     * @param {?} rowCount
     * @param {?} dataLength
     * @return {?}
     */
    getRows(rowCount, dataLength) {
        /** @type {?} */
        const columnNum = this.columnNum;
        /** @type {?} */
        const rowArr = new Array();
        for (let i = 0; i < rowCount; i++) {
            rowArr[i] = new Array();
            for (let j = 0; j < columnNum; j++) {
                /** @type {?} */
                const dataIndex = i * columnNum + j;
                if (dataIndex < dataLength) {
                    rowArr[i][j] = this._data[dataIndex];
                }
                else {
                    rowArr[i][j] = null;
                }
            }
        }
        return rowArr;
    }
    /**
     * @param {?} data
     * @param {?} index
     * @return {?}
     */
    click(data, index) {
        /** @type {?} */
        const outputData = {
            data: data,
            index: index
        };
        this.onClick.emit(outputData);
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.itemCls = {
            [`${this.defaultProps.prefixCls}-item`]: true,
            [`${this.defaultProps.prefixCls}-active-item`]: false
        };
    }
}
GridComponent.decorators = [
    { type: Component, args: [{
                selector: 'Grid, nzm-grid',
                template: "<ng-container *ngIf=\"!isCarousel\">\n  <Flex *ngFor=\"let item of gridData; let i = index;\"\n        [justify]=\"'center'\"\n        [align]=\"'stretch'\"\n  >\n    <FlexItem TouchFeedbackDirective\n              *ngFor=\"let subItem of item; let j = index;\"\n              [ngClass]=\"itemCls\"\n              [ngStyle]=\"itemStyle\"\n              [className]=\"['am-grid-item-active']\"\n              [activeStyle]=\"activeStyle\"\n    >\n      <div *ngIf=\"subItem !== null\"\n           class=\"{{defaultProps.prefixCls}}-item-content\"\n           (click)=\"click(subItem,i * columnNum + j)\"\n      >\n        <div class=\"{{defaultProps.prefixCls}}-item-inner-content column-num-{{columnNum}}\">\n          <img *ngIf=\"subItem.icon && getContentType(subItem.icon) === 'url'\"\n               src=\"{{subItem.icon}}\"\n               class=\"{{defaultProps.prefixCls}}-icon\"\n          >\n          <Icon *ngIf=\"subItem.icon && getContentType(subItem.icon)==='icon'\"\n                [type]=\"subItem.icon\"\n                [size]=\"subItem.size\"\n          ></Icon>\n          <div *ngIf=\"subItem.icon && getContentType(subItem.icon)==='innerHTML'\" [innerHTML]=\"subItem.icon | safeHTML\"></div>\n          <ng-template *ngIf=\"subItem.icon && getContentType(subItem.icon)==='TemplateRef'\" [ngTemplateOutlet]=\"subItem.icon\"></ng-template>\n          <div class=\"{{defaultProps.prefixCls}}-text\">{{subItem.text}}</div>\n        </div>\n      </div>\n      <div *ngIf=\"subItem === null\" class=\"{{defaultProps.prefixCls}}-null-item\"></div>\n    </FlexItem>\n  </Flex>\n  <ng-content></ng-content>\n</ng-container>\n\n<Carousel *ngIf=\"isCarousel && carouselDataTmp.length > 0\"\n          [autoplay]=\"false\"\n          [infinite]=\"true\"\n          [selectedIndex]=\"0\"\n          [autoplayInterval]='3000'\n          [dots]=\"carouselProps.dots\"\n          [dragging]=\"carouselProps.dragging\"\n>\n  <CarouselSlide *ngFor=\"let gridData of carouselDataTmp\"\n                 class=\"{{defaultProps.prefixCls}}-carousel-page\"\n                 style=\"display: block;\"\n  >\n    <Flex *ngFor=\"let item of gridData; let i = index;\"\n          [justify]=\"'center'\"\n          [align]=\"'stretch'\"\n    >\n      <FlexItem TouchFeedbackDirective\n                *ngFor=\"let subItem of item; let j = index;\"\n                class=\"{{defaultProps.prefixCls}}-item\"\n                [ngStyle]=\"itemStyle\"\n                [className]=\"['am-grid-item-active']\"\n      >\n        <div *ngIf=\"subItem !== null\"\n             class=\"{{defaultProps.prefixCls}}-item-content\"\n             (click)=\"click(subItem,i * columnNum + j)\"\n        >\n          <div class=\"{{defaultProps.prefixCls}}-item-inner-content column-num-4\">\n            <img class=\"{{defaultProps.prefixCls}}-icon\" src=\"{{subItem.icon}}\">\n            <div class=\"{{defaultProps.prefixCls}}-text\">{{subItem.text}}</div>\n          </div>\n        </div>\n        <div *ngIf=\"subItem === null\" class=\"{{defaultProps.prefixCls}}-null-item\"></div>\n      </FlexItem>\n    </Flex>\n  </CarouselSlide>\n</Carousel>"
            }] }
];
/** @nocollapse */
GridComponent.ctorParameters = () => [];
GridComponent.propDecorators = {
    columnNum: [{ type: Input }],
    carouselMaxRow: [{ type: Input }],
    itemStyle: [{ type: Input }],
    square: [{ type: Input }],
    hasLine: [{ type: Input }],
    isCarousel: [{ type: Input }],
    activeStyle: [{ type: Input }],
    data: [{ type: Input }],
    onClick: [{ type: Output }],
    amGrid: [{ type: HostBinding, args: ['class.am-grid',] }],
    amGridSquare: [{ type: HostBinding, args: ['class.am-grid-square',] }],
    amGridLine: [{ type: HostBinding, args: ['class.am-grid-line',] }],
    amGridCarousel: [{ type: HostBinding, args: ['class.am-grid-carousel',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const INTERFACE_TOKEN = new InjectionToken('InterfaceToken');
class TouchFeedbackDirective {
    /**
     * @param {?} _elementRef
     * @param {?} _renderer
     */
    constructor(_elementRef, _renderer) {
        this._elementRef = _elementRef;
        this._renderer = _renderer;
        this.activeStyle = true;
        this.clickStart = new EventEmitter();
        this.clickEnd = new EventEmitter();
    }
    /**
     * @private
     * @param {?} className
     * @return {?}
     */
    addClass(className) {
        this._renderer.addClass(this._elementRef.nativeElement, className);
    }
    /**
     * @private
     * @param {?} className
     * @return {?}
     */
    removeClass(className) {
        this._renderer.removeClass(this._elementRef.nativeElement, className);
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this._className = this.className;
    }
    /**
     * @return {?}
     */
    touchStart() {
        if (this.activeStyle) {
            this.addClass(this._className);
            this.clickStart.emit();
        }
    }
    /**
     * @return {?}
     */
    touchEnd() {
        if (this.activeStyle) {
            this.removeClass(this._className);
            this.clickEnd.emit();
        }
    }
}
TouchFeedbackDirective.decorators = [
    { type: Directive, args: [{
                selector: '[TouchFeedbackDirective]'
            },] }
];
/** @nocollapse */
TouchFeedbackDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
TouchFeedbackDirective.propDecorators = {
    className: [{ type: Input }],
    activeStyle: [{ type: Input }],
    clickStart: [{ type: Output }],
    clickEnd: [{ type: Output }],
    touchStart: [{ type: HostListener, args: ['touchstart',] }, { type: HostListener, args: ['mousedown',] }],
    touchEnd: [{ type: HostListener, args: ['touchend',] }, { type: HostListener, args: ['mouseup',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TouchFeedBackComponent {
    /**
     * @param {?} _ele
     * @param {?} _render
     */
    constructor(_ele, _render) {
        this._ele = _ele;
        this._render = _render;
        this.activeClassName = '';
        this.activeStyle = true;
    }
    /**
     * @return {?}
     */
    touchStart() {
        if (this.activeStyle) {
            this._render.addClass(this._ele.nativeElement, this.activeClassName);
        }
    }
    /**
     * @return {?}
     */
    touchEnd() {
        if (this.activeStyle) {
            this._render.removeClass(this._ele.nativeElement, this.activeClassName);
        }
    }
}
TouchFeedBackComponent.decorators = [
    { type: Component, args: [{
                selector: 'TouchFeedBack',
                template: '<ng-content></ng-content>',
                encapsulation: ViewEncapsulation.None
            }] }
];
/** @nocollapse */
TouchFeedBackComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
TouchFeedBackComponent.propDecorators = {
    activeClassName: [{ type: Input }],
    activeStyle: [{ type: Input }],
    touchStart: [{ type: HostListener, args: ['touchstart',] }, { type: HostListener, args: ['mousedown',] }],
    touchEnd: [{ type: HostListener, args: ['touchend',] }, { type: HostListener, args: ['mouseup',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TouchFeedbackModule {
}
TouchFeedbackModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                exports: [TouchFeedbackDirective, TouchFeedBackComponent],
                declarations: [TouchFeedbackDirective, TouchFeedBackComponent]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class GridModule {
}
GridModule.decorators = [
    { type: NgModule, args: [{
                imports: [FlexModule, IconModule, CommonModule, CarouselModule, TouchFeedbackModule, NgZorroAntdMobilePipesModule],
                exports: [GridComponent],
                declarations: [GridComponent]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ActionSheetComponent {
    /**
     * @param {?} localeProviderService
     */
    constructor(localeProviderService) {
        this.localeProviderService = localeProviderService;
        this.unsubscribe$ = new Subject();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.localeProvider();
    }
    /**
     * @return {?}
     */
    localeProvider() {
        /** @type {?} */
        const self = this;
        if (self.option.locale || self.option.locale !== undefined) {
            self.localeProviderService.setLocale(self.option.locale);
        }
        self.localeProviderService.localeChange.pipe(takeUntil(self.unsubscribe$)).subscribe((/**
         * @param {?} _
         * @return {?}
         */
        _ => {
            if (self.option.cancelButtonText) {
                self.option.cancelButtonText = self.localeProviderService.getLocaleSubObj('ActionSheet')['dismissText'];
            }
        }));
    }
    /**
     * @param {?} index
     * @param {?=} rowIndex
     * @param {?=} event
     * @return {?}
     */
    onPress(index, rowIndex = 0, event) { }
    /**
     * @param {?} option
     * @return {?}
     */
    showShare(option) {
        /** @type {?} */
        const cls = { [`${option.prefixCls}-share`]: option.flag === 'SHARE' };
        return cls;
    }
    /**
     * @param {?} option
     * @param {?} suffix
     * @return {?}
     */
    setActiveClassName(option, suffix) {
        return [`${option.prefixCls}-${suffix}-active`];
    }
    /**
     * @param {?} value
     * @return {?}
     */
    isNoTitle(value) {
        return value === '' || value === null || value === undefined;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    isTemplateRef(value) {
        if (value) {
            return value instanceof TemplateRef;
        }
        return false;
    }
    /**
     * @param {?} options
     * @param {?} value
     * @return {?}
     */
    isArray(options, value) {
        if (options.length > 0 && value) {
            return value instanceof Array;
        }
        return false;
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.unsubscribe$.next();
        this.unsubscribe$.complete();
    }
}
ActionSheetComponent.decorators = [
    { type: Component, args: [{
                selector: 'ActionSheet',
                template: "<div class=\"{{option.prefixCls}}-mask {{option.maskTransitionName}}\"></div>\n<div role=\"dialog\" class=\"{{option.prefixCls}}-wrap {{option.transitionName}}\" (click)=\"option.maskClose(-1, 0, $event)\">\n  <div role=\"document\"\n       class=\"{{option.prefixCls}}\"\n       [ngClass]=\"showShare(option)\">\n    <div class=\"{{option.prefixCls}}-content\">\n      <button aria-label=\"Close\" class=\"{{option.prefixCls}}-close\">\n        <span class=\"{{option.prefixCls}}-close-x\"></span>\n      </button>\n      <div class=\"{{option.prefixCls}}-body\">\n        <div>\n          <ng-container *ngIf=\"!isNoTitle(option.title)\">\n            <ng-template *ngIf=\"isTemplateRef(option.title)\" [ngTemplateOutlet]=\"option.title\"></ng-template>\n            <h3 *ngIf=\"!isTemplateRef(option.title)\" class=\"{{option.prefixCls}}-title\">{{option.title}}</h3>\n          </ng-container>\n          <ng-container *ngIf=\"!isNoTitle(option.message)\">\n            <ng-template *ngIf=\"isTemplateRef(option.message)\" [ngTemplateOutlet]=\"option.message\"></ng-template>\n            <div *ngIf=\"!isTemplateRef(option.message)\" class=\"{{option.prefixCls}}-message\">{{option.message}}</div>\n          </ng-container>\n          <ng-container [ngSwitch]=\"option.flag\">\n            <div *ngSwitchCase=\"'NORMAL'\" class=\"{{option.prefixCls}}-button-list\" role=\"group\">\n              <ng-container *ngFor=\"let item of option.options; let i = index;\">\n                  <div TouchFeedbackDirective class=\"{{option.prefixCls}}-button-list-item\" [className]=\"setActiveClassName(option, 'button-list-item')\">\n                      <div *ngIf=\"option.destructiveButtonIndex !== i && option.cancelButtonIndex !== i\"\n                           class=\"{{option.prefixCls}}-button-list-item\"\n                           (click)=\"option.onPress(i, 0, $event)\"\n                      >\n                        {{item}}\n                      </div>\n                      <div *ngIf=\"option.destructiveButtonIndex === i\"\n                           class=\"{{option.prefixCls}}-button-list-item {{option.prefixCls}}-destructive-button\"\n                           (click)=\"option.onPress(i, 0, $event)\"\n                      >\n                        {{item}}\n                      </div>\n                      <div *ngIf=\"option.cancelButtonIndex === i\"\n                           class=\"{{option.prefixCls}}-button-list-item {{option.prefixCls}}-cancel-button\"\n                           (click)=\"option.onPress(i, 0, $event)\"\n                      >\n                        {{item}}\n                        <span class=\"{{option.prefixCls}}-cancel-button-mask\"></span>\n                      </div>\n                  </div>\n              </ng-container>\n            </div>\n            <div *ngSwitchCase=\"'SHARE'\" class=\"{{option.prefixCls}}-share {{option.prefixCls}}-share-content\">\n              <div *ngIf=\"!isArray(option.options, option.options[0])\" class=\"{{option.prefixCls}}-share-list\">\n                <ng-container *ngFor=\"let item of option.options; let i = index;\">\n                  <div class=\"{{option.prefixCls}}-share-list-item\" (click)=\"option.onPress(i, 0, $event)\">\n                    <div class=\"{{option.prefixCls}}-share-list-item-icon\">\n                      <ng-template *ngIf=\"isTemplateRef(item.icon)\" [ngTemplateOutlet]=\"item.icon\"></ng-template>\n                      <div *ngIf=\"!isTemplateRef(item.icon)\" [innerHTML]=\"item.icon | safeHTML\"></div>\n                    </div>\n                    <div class=\"{{option.prefixCls}}-share-list-item-title\">{{item.title}}</div>\n                  </div>\n                </ng-container>\n              </div>\n              <ng-container *ngIf=\"isArray(option.options, option.options[0])\">\n                <div *ngFor=\"let items of option.options; let rowIndex = index\" class=\"{{option.prefixCls}}-share-list\">\n                  <ng-container *ngFor=\"let item of items; let i = index;\">\n                    <div class=\"{{option.prefixCls}}-share-list-item\" (click)=\"option.onPress(i, rowIndex, $event)\">\n                      <div class=\"{{option.prefixCls}}-share-list-item-icon\">\n                        <ng-template *ngIf=\"isTemplateRef(item.icon)\" [ngTemplateOutlet]=\"item.icon\"></ng-template>\n                        <div *ngIf=\"!isTemplateRef(item.icon)\" [innerHTML]=\"item.icon | safeHTML\"></div>\n                      </div>\n                      <div class=\"{{option.prefixCls}}-share-list-item-title\">{{item.title}}</div>\n                    </div>\n                  </ng-container>\n                </div>\n              </ng-container>\n              <div TouchFeedbackDirective [className]=\"setActiveClassName(option, 'share-cancel-button')\" class=\"{{option.prefixCls}}-share-cancel-button\">{{option.cancelButtonText}}</div>\n            </div>\n          </ng-container>\n        </div>\n      </div>\n    </div>\n  </div>\n</div>",
                encapsulation: ViewEncapsulation.None
            }] }
];
/** @nocollapse */
ActionSheetComponent.ctorParameters = () => [
    { type: LocaleProviderService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ActionSheetOptions {
    constructor() {
        this.prefixCls = 'am-action-sheet';
        this.maskClosable = true;
        this.transitionName = 'am-slide-up';
        this.maskTransitionName = 'am-fade';
    }
}
ActionSheetOptions.decorators = [
    { type: Injectable }
];
class ShareOption {
}
ShareOption.decorators = [
    { type: Injectable }
];
class ShareActionSheetWithOptions extends ActionSheetOptions {
    constructor() {
        super(...arguments);
        this.cancelButtonText = 'Cancel';
    }
}
ShareActionSheetWithOptions.decorators = [
    { type: Injectable }
];
class ActionSheetWithOptions extends ActionSheetOptions {
}
ActionSheetWithOptions.decorators = [
    { type: Injectable }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ActionSheetSubjectService extends Subject {
    constructor() {
        super();
        this._eventsQueue = {};
        this.subscribe((/**
         * @param {?} value
         * @return {?}
         */
        (value) => {
            /** @type {?} */
            const eventQueue = this._eventsQueue[value] || [];
            eventQueue.forEach((/**
             * @param {?} cb
             * @return {?}
             */
            cb => {
                if (cb !== null && cb !== undefined) {
                    cb();
                }
            }));
        }));
    }
    /**
     * @param {?=} type
     * @return {?}
     */
    destroy(type = 'onCancel') {
        if (!this.isStopped && !this.closed) {
            this.next(type);
        }
    }
    /**
     * @param {?} eventType
     * @param {?} cb
     * @return {?}
     */
    on(eventType, cb) {
        if (this._eventsQueue[eventType]) {
            this._eventsQueue[eventType].push(cb);
        }
        else {
            this._eventsQueue[eventType] = [cb];
        }
    }
}
ActionSheetSubjectService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
ActionSheetSubjectService.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const NORMAL = 'NORMAL';
/** @type {?} */
const SHARE = 'SHARE';
/**
 * @return {?}
 */
function noop() { }
class ActionSheetService extends PopupService {
    /**
     * @param {?} config
     * @param {?=} options
     * @return {?}
     */
    static _initConfig(config, options = {}) {
        /** @type {?} */
        const props = new ActionSheetOptions();
        /** @type {?} */
        const optionalParams = [
            'prefixCls',
            'maskClosable',
            'cancelButtonText',
            'cancelButtonIndex',
            'destructiveButtonIndex',
            'title',
            'message',
            'className',
            'transitionName',
            'maskTransitionName',
            'options',
            'locale'
        ];
        config = Object.assign(options, config, {
            close: (/**
             * @return {?}
             */
            () => {
                if (config.maskClosable) {
                    ActionSheetService.closeWithAnimation(config.transitionName, config.maskTransitionName);
                }
            })
        });
        optionalParams.forEach((/**
         * @param {?} key
         * @return {?}
         */
        key => {
            if (config[key] !== undefined) {
                props[key] = config[key];
            }
        }));
        return props;
    }
    /**
     * @param {?} props
     * @return {?}
     */
    static _open(props) {
        setTimeout((/**
         * @return {?}
         */
        () => {
            ActionSheetService.comRef = ActionSheetService.showPopup('ActionSheetComponent', ActionSheetComponent);
            ActionSheetService.comRef.instance.option = props;
        }), 0);
    }
    /**
     * @param {?} flag
     * @param {?} config
     * @param {?} callback
     * @return {?}
     */
    static createActionSheet(flag, config, callback) {
        /** @type {?} */
        const options = flag === NORMAL ? new ActionSheetOptions() : new ShareActionSheetWithOptions();
        /** @type {?} */
        const transitionName = config.transitionName ? config.transitionName : options.transitionName;
        options.transitionName = `${transitionName}-enter ${transitionName}-enter-active`;
        /** @type {?} */
        const maskTransitionName = config.maskTransitionName ? config.maskTransitionName : options.maskTransitionName;
        options.maskTransitionName = `${maskTransitionName}-enter ${maskTransitionName}-enter-active`;
        /** @type {?} */
        const props = ActionSheetService._initConfig(config, options);
        Object.assign(props, { onPress: cb }, { flag: flag }, { maskClose: props.maskClosable ? cb : (/**
             * @return {?}
             */
            () => { }) });
        /**
         * @param {?} index
         * @param {?=} rowIndex
         * @param {?=} event
         * @return {?}
         */
        function cb(index, rowIndex = 0, event) {
            event.stopPropagation();
            /** @type {?} */
            const res = callback(index, rowIndex);
            if (res && res.then) {
                res.then((/**
                 * @return {?}
                 */
                () => {
                    ActionSheetService.closeWithAnimation(transitionName, maskTransitionName);
                }));
            }
            else {
                ActionSheetService.closeWithAnimation(transitionName, maskTransitionName);
            }
        }
        return ActionSheetService._open(props);
    }
    /**
     * @param {?} transitionName
     * @param {?} maskTransitionName
     * @return {?}
     */
    static closeWithAnimation(transitionName, maskTransitionName) {
        ActionSheetService.comRef.instance.option.transitionName = `${transitionName}-leave ${transitionName}-leave-active`;
        ActionSheetService.comRef.instance.option.maskTransitionName = `${maskTransitionName}-leave ${maskTransitionName}-leave-active`;
        setTimeout((/**
         * @return {?}
         */
        () => {
            ActionSheetService.close();
        }), 200);
    }
    /**
     * @param {?} config
     * @param {?=} callback
     * @return {?}
     */
    static showActionSheetWithOptions(config, callback = noop) {
        ActionSheetService.createActionSheet(NORMAL, config, callback);
    }
    /**
     * @param {?} config
     * @param {?=} callback
     * @return {?}
     */
    static showShareActionSheetWithOptions(config, callback = noop) {
        ActionSheetService.createActionSheet(SHARE, config, callback);
    }
    /**
     * @return {?}
     */
    static close() {
        ActionSheetService.hidePopup('ActionSheetComponent');
    }
}
ActionSheetService.compRef = null;
ActionSheetService._actionSheetCompFactory = null;
ActionSheetService.appRef = null;
ActionSheetService.comRef = null;
ActionSheetService.instance = null;
ActionSheetService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */ ActionSheetService.ngInjectableDef = defineInjectable({ factory: function ActionSheetService_Factory() { return new ActionSheetService(inject(Overlay)); }, token: ActionSheetService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ActionSheetModule {
}
ActionSheetModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, OverlayModule, NgZorroAntdMobilePipesModule, ListModule, WhiteSpaceModule, WingBlankModule, LocaleProviderModule],
                declarations: [
                    ActionSheetComponent
                ],
                exports: [
                    ActionSheetComponent
                ],
                entryComponents: [ActionSheetComponent],
                providers: [PopupService, ActionSheetService]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SegmentedControlComponent {
    constructor() {
        this.prefixCls = 'am-segment';
        this.tintColor = '#2DB7F5';
        this.disabled = false;
        this.selectedIndex = 0;
        this.onChange = new EventEmitter();
        this.role = 'tablist';
        this.amSegment = true;
    }
    /**
     * @return {?}
     */
    get amDisabled() {
        return this.disabled;
    }
    /**
     * @param {?} index
     * @param {?} value
     * @return {?}
     */
    onClick(index, value) {
        if (!this.disabled && index !== this.selectedIndex) {
            this.selectedIndex = index;
            this.onChange.emit({ selectedIndex: index, value: value });
        }
    }
}
SegmentedControlComponent.decorators = [
    { type: Component, args: [{
                selector: 'SegmentedControl, nz-segmented-control',
                template: "<div role=\"tab\"\n     *ngFor=\"let value of values; let i = index;\"\n     class=\"{{prefixCls}}-item\"\n     [ngClass]=\"{'am-segment-item-selected' : i === selectedIndex}\"\n     [ngStyle]=\"{'border-color': tintColor, 'color': i === selectedIndex ? '#fff' : tintColor, 'background-color': i === selectedIndex ? tintColor : 'transparent'}\"\n     (click)=\"onClick(i, value)\"\n>\n  <div class=\"{{prefixCls}}-item-inner\"\n       [ngStyle]=\"{'background-color': i === selectedIndex ? tintColor : 'transparent'}\"\n  ></div>\n  {{value}}\n</div>\n"
            }] }
];
/** @nocollapse */
SegmentedControlComponent.ctorParameters = () => [];
SegmentedControlComponent.propDecorators = {
    tintColor: [{ type: Input }],
    disabled: [{ type: Input }],
    selectedIndex: [{ type: Input }],
    values: [{ type: Input }],
    onChange: [{ type: Output }],
    role: [{ type: HostBinding, args: ['attr.role',] }],
    amSegment: [{ type: HostBinding, args: ['class.am-segment',] }],
    amDisabled: [{ type: HostBinding, args: ['class.am-segment-disabled',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SegmentedControlModule {
}
SegmentedControlModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                declarations: [SegmentedControlComponent],
                exports: [SegmentedControlComponent]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TextareaItemComponent {
    /**
     * @param {?} element
     * @param {?} render
     */
    constructor(element, render) {
        this.element = element;
        this.render = render;
        this.prefixCls = 'am-textarea';
        this.isTitleString = true;
        this.maxLength = Infinity;
        this._prefixListCls = 'am-list';
        this._defaultValue = '';
        this._placeholder = '';
        this._editable = true;
        this._disabled = false;
        this._clear = false;
        this._rows = 1;
        this._error = false;
        this._labelNumber = 5;
        this._name = '';
        this._focus = false;
        this._autoFocus = false;
        this._isClear = false;
        this._isClickingClear = false;
        this.onChange = new EventEmitter();
        this.onBlur = new EventEmitter();
        this.onFocus = new EventEmitter();
        this.onErrorClick = new EventEmitter();
        this.clsItem = true;
        this._onChange = (/**
         * @param {?} _
         * @return {?}
         */
        (_) => { });
        this._el = element.nativeElement;
    }
    /**
     * @return {?}
     */
    get value() {
        return this._value;
    }
    /**
     * @param {?} v
     * @return {?}
     */
    set value(v) {
        if (typeof v === 'undefined' || v === null) {
            this._value = '';
        }
        else {
            this._value = v;
        }
        this.textRef.nativeElement.value = this._value;
        this._onChange(this._value);
    }
    /**
     * @return {?}
     */
    get defaultValue() {
        return this._defaultValue;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set defaultValue(value) {
        this._defaultValue = value;
        this._value = this._defaultValue;
        this.textRef.nativeElement.value = this._value;
    }
    /**
     * @return {?}
     */
    get placeholder() {
        return this._placeholder;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set placeholder(value) {
        this._placeholder = value;
    }
    /**
     * @return {?}
     */
    get editable() {
        return this._editable;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set editable(value) {
        this._editable = value;
    }
    /**
     * @return {?}
     */
    get disabled() {
        return this._disabled;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set disabled(value) {
        this._disabled = value;
        this.setCls();
    }
    /**
     * @return {?}
     */
    get clear() {
        return this._clear;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set clear(value) {
        this._clear = value;
    }
    /**
     * @return {?}
     */
    get rows() {
        return this._rows;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set rows(value) {
        this._rows = value;
        this.setCls();
    }
    /**
     * @return {?}
     */
    get error() {
        return this._error;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set error(value) {
        this._error = value;
        this.setCls();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set labelNumber(value) {
        this._labelNumber = value;
        this.setCls();
    }
    /**
     * @return {?}
     */
    get count() {
        return this._count;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set count(value) {
        this._count = value;
        this.setCls();
        this.setCharacterLength();
    }
    /**
     * @return {?}
     */
    get prefixListCls() {
        return this._prefixListCls;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set prefixListCls(value) {
        this._prefixListCls = value;
        this.setCls();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set name(value) {
        this._name = value;
        this.textRef.nativeElement.name = this._name;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set autoHeight(value) {
        this._autoHeight = value;
    }
    /**
     * @return {?}
     */
    get title() {
        return this._title;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set title(value) {
        this._title = value;
        this.isTitleString = true;
        if (typeof value !== 'string') {
            this.isTitleString = false;
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set focus(value) {
        if (value && value.focus) {
            this.textRef.nativeElement.focus();
            this.inputFocus('');
        }
    }
    /**
     * @return {?}
     */
    get autoFocus() {
        return this._autoFocus;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set autoFocus(value) {
        this._autoFocus = value;
    }
    /**
     * @return {?}
     */
    setCls() {
        this.hasCount = this._count > 0 && this._rows > 1;
        this.render.addClass(this._el, this._prefixListCls + '-item');
        this.clsSingleLine = this._rows === 1 && !this._autoHeight;
        this.clsDisabled = this._disabled;
        this.clsError = this._error;
        this.clsFocus = this._focus;
        this.clsHasCount = this.hasCount;
        this.labelCls = {
            [`${this.prefixCls}-label`]: true,
            [`${this.prefixCls}-label-2`]: this._labelNumber === 2,
            [`${this.prefixCls}-label-3`]: this._labelNumber === 3,
            [`${this.prefixCls}-label-4`]: this._labelNumber === 4,
            [`${this.prefixCls}-label-5`]: this._labelNumber === 5,
            [`${this.prefixCls}-label-6`]: this._labelNumber === 6,
            [`${this.prefixCls}-label-7`]: this._labelNumber === 7
        };
        this.controlCls = { [`${this.prefixCls}-control`]: true };
        this.clearCls = {
            [`${this.prefixCls}-clear-active`]: this._isClickingClear
        };
    }
    /**
     * @return {?}
     */
    setCharacterLength() {
        this.characterLength = this.countSymbols(this._value);
        if (this._count > 0) {
            this.maxLength = this._count - this.characterLength + (this._value ? this._value.length : 0);
        }
    }
    /**
     * @param {?} e
     * @return {?}
     */
    inputChange(e) {
        this._value = e;
        this.textRef.nativeElement.value = this._value;
        this.setCharacterLength();
        this._onChange(this._value);
        this.onChange.emit(this._value);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    inputFocus(value) {
        this._focus = true;
        this.setCls();
        if (value !== undefined) {
            this.onFocus.emit(value);
        }
    }
    /**
     * @param {?} value
     * @param {?} event
     * @return {?}
     */
    inputBlur(value, event) {
        setTimeout((/**
         * @return {?}
         */
        () => {
            this._focus = false;
            this.setCls();
            this.onBlur.emit(value);
            this._isClear = false;
        }), 100);
    }
    /**
     * @return {?}
     */
    clearInput() {
        this._isClickingClear = true;
        this.setCls();
        setTimeout((/**
         * @return {?}
         */
        () => {
            this._value = '';
            this.inputChange('');
            this.inputFocus(this._value);
            this._isClickingClear = false;
            this.setCls();
        }), 100);
    }
    /**
     * @param {?} e
     * @return {?}
     */
    errorClick(e) {
        if (this.onErrorClick) {
            this.onErrorClick.emit(e);
        }
    }
    /**
     * @return {?}
     */
    reAlignHeight() {
        /** @type {?} */
        const textareaDom = this.textRef.nativeElement;
        textareaDom.style.height = '';
        textareaDom.style.height = `${textareaDom.scrollHeight}px`;
    }
    /**
     * @param {?=} text
     * @return {?}
     */
    countSymbols(text = '') {
        /** @type {?} */
        const regexAstralSymbols = /[\uD800-\uDBFF][\uDC00-\uDFFF]|\n/g;
        return text.replace(regexAstralSymbols, '_').length;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        if (typeof value === 'undefined' || value === null) {
            this._value = '';
        }
        else {
            this._value = value;
        }
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this._onChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) { }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.setCls();
        this.setCharacterLength();
        this.textRef.nativeElement.value = this._value;
    }
    /**
     * @return {?}
     */
    ngAfterContentChecked() {
        if (this._autoHeight && this._focus) {
            this.reAlignHeight();
        }
    }
}
TextareaItemComponent.decorators = [
    { type: Component, args: [{
                selector: 'TextareaItem , nzm-textarea-item',
                template: "<div *ngIf=\"title &&  isTitleString\" [ngClass]=\"labelCls\">{{title}}</div>\n  <div *ngIf=\"title &&  !isTitleString\" [ngClass]=\"labelCls\">\n    <ng-template [ngTemplateOutlet]=\"title\"></ng-template>\n  </div>\n  <div [ngClass]=\"controlCls\">\n    <textarea #text\n              [rows]=\"rows\"\n              [maxlength]=\"maxLength\"\n              [(ngModel)]=\"value\"\n              [defaultValue]=\"defaultValue\"\n              [placeholder]=\"placeholder\"\n              [disabled]=\"disabled\"\n              [readOnly]=\"!editable\"\n              [autofocus]=\"autoFocus\"\n              (ngModelChange)=\"inputChange($event)\"\n              (blur)=\"inputBlur(value , $event)\"\n              (focus)=\"inputFocus(value)\"\n    ></textarea>\n  </div>\n  <div *ngIf=\"clear && editable && !disabled && (value && value.length >0 )\"\n       class=\"{{prefixCls}}-clear\"\n       [ngClass]=\"clearCls\"\n       (click)=\"clearInput()\"\n  ></div>\n  <div *ngIf=\"error\" class=\"{{prefixCls}}-error-extra\" (click)=\"errorClick($event)\"></div>\n  <span *ngIf=\"hasCount\" class=\"{{prefixCls}}-count\">\n    <span>{{characterLength}}</span>/{{count}}\n  </span>\n",
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => TextareaItemComponent)),
                        multi: true
                    }
                ]
            }] }
];
/** @nocollapse */
TextareaItemComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
TextareaItemComponent.propDecorators = {
    textRef: [{ type: ViewChild, args: ['text',] }],
    value: [{ type: Input }],
    defaultValue: [{ type: Input }],
    placeholder: [{ type: Input }],
    editable: [{ type: Input }],
    disabled: [{ type: Input }],
    clear: [{ type: Input }],
    rows: [{ type: Input }],
    error: [{ type: Input }],
    labelNumber: [{ type: Input }],
    count: [{ type: Input }],
    prefixListCls: [{ type: Input }],
    name: [{ type: Input }],
    autoHeight: [{ type: Input }],
    title: [{ type: Input }],
    focus: [{ type: Input }],
    autoFocus: [{ type: Input }],
    onChange: [{ type: Output }],
    onBlur: [{ type: Output }],
    onFocus: [{ type: Output }],
    onErrorClick: [{ type: Output }],
    clsItem: [{ type: HostBinding, args: ['class.am-textarea-item',] }],
    clsDisabled: [{ type: HostBinding, args: ['class.am-textarea-disabled',] }],
    clsError: [{ type: HostBinding, args: ['class.am-textarea-error',] }],
    clsFocus: [{ type: HostBinding, args: ['class.am-textarea-focus',] }],
    clsSingleLine: [{ type: HostBinding, args: ['class.am-textarea-item-single-line',] }],
    clsHasCount: [{ type: HostBinding, args: ['class.am-textarea-has-count',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TextareaItemModule {
}
TextareaItemModule.decorators = [
    { type: NgModule, args: [{
                exports: [TextareaItemComponent],
                declarations: [TextareaItemComponent],
                imports: [CommonModule, FormsModule]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TabPaneComponent {
    constructor() {
        this.isTitleString = true;
    }
    /**
     * @return {?}
     */
    get title() {
        return this._title;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set title(value) {
        this.isTitleString = !(value instanceof TemplateRef);
        this._title = value;
    }
}
TabPaneComponent.decorators = [
    { type: Component, args: [{
                selector: 'TabPane, nzm-tab-pane',
                template: "<ng-template #content>\n  <ng-content></ng-content>\n</ng-template>"
            }] }
];
/** @nocollapse */
TabPaneComponent.ctorParameters = () => [];
TabPaneComponent.propDecorators = {
    content: [{ type: ViewChild, args: ['content',] }],
    title: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TabsComponent {
    constructor() {
        this.prefixCls = 'am-tabs';
        this.selectedKey = 0;
        this.keyToSelect = 0;
        this.paneMoveStyle = 'translate3d(0, 0, 0)';
        this._startTime = 0;
        this._startPosition = 0;
        this._velocityThreshold = 0.3;
        this._tabDirection = 'horizontal';
        this._tabBarPosition = 'top';
        this.page = 5;
        this.swipeable = true;
        this.useOnPan = true;
        this.animated = true;
        this.distanceToChangeTab = 0.3;
        this.tabTitleSize = 0;
        this.tabBarActiveTextColor = '';
        this.tabBarInactiveTextColor = '';
        this.renderTabBar = null;
        this.tabBarBackgroundColor = '#FFF';
        this.prerenderingSiblingsNumber = -1;
        this.tabBarTextStyle = {};
        /**
         * should be removed when https://github.com/angular/angular/issues/20810 resolved *
         */
        this.tabPanesContent = null;
        this.onChange = new EventEmitter();
        this.onTabClick = new EventEmitter();
        this.amTabs = true;
        this.amTabsTop = true;
        this.amTabsLeft = false;
        this.amTabsRight = false;
        this.amTabsBottom = false;
        this.amTabsVertical = false;
        this.amTabsHorizontal = true;
    }
    /**
     * @return {?}
     */
    get activeTab() {
        return this.selectedKey;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set activeTab(value) {
        this.keyToSelect = value;
    }
    /**
     * @return {?}
     */
    get tabBarPosition() {
        return this._tabBarPosition;
    }
    /**
     * @param {?} position
     * @return {?}
     */
    set tabBarPosition(position) {
        this._tabBarPosition = position;
        switch (position) {
            case 'top':
                this.amTabsTop = true;
                this.amTabsLeft = false;
                this.amTabsRight = false;
                this.amTabsBottom = false;
                break;
            case 'left':
                this.amTabsTop = false;
                this.amTabsLeft = true;
                this.amTabsRight = false;
                this.amTabsBottom = false;
                break;
            case 'bottom':
                this.amTabsTop = false;
                this.amTabsLeft = false;
                this.amTabsRight = false;
                this.amTabsBottom = true;
                break;
            case 'right':
                this.amTabsTop = false;
                this.amTabsLeft = false;
                this.amTabsRight = true;
                this.amTabsBottom = false;
                break;
            default:
                break;
        }
    }
    /**
     * @return {?}
     */
    get tabDirection() {
        return this._tabDirection;
    }
    /**
     * @param {?} direction
     * @return {?}
     */
    set tabDirection(direction) {
        this._tabDirection = direction;
        switch (direction) {
            case 'horizontal':
                this.amTabsHorizontal = true;
                this.amTabsVertical = false;
                break;
            case 'vertical':
                this.amTabsHorizontal = false;
                this.amTabsVertical = true;
                break;
            default:
                break;
        }
    }
    /**
     * @param {?} index
     * @return {?}
     */
    clickTab(index) {
        if (this.selectedKey !== index) {
            this.keyToSelect = index;
            this.onTabClick.emit({ index: this.keyToSelect });
        }
    }
    /**
     * @return {?}
     */
    getCurrentTabPanes() {
        return this.tabPanesContent || this.tabPanes;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onTouchStart(event) {
        this._startTime = event.timeStamp;
        if (this.getCurrentTabPanes() && this.getCurrentTabPanes().length > 0) {
            if ('horizontal' === this._tabDirection) {
                this._startPosition =
                    event && event.changedTouches && event.changedTouches[0] && event.changedTouches[0].clientX;
            }
            else if ('vertical' === this._tabDirection) {
                this._startPosition =
                    event && event.changedTouches && event.changedTouches[0] && event.changedTouches[0].clientY;
            }
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onTouchMove(event) {
        if (this.getCurrentTabPanes() && this.getCurrentTabPanes().length > 0) {
            if ('horizontal' === this._tabDirection) {
                /** @type {?} */
                const distance = event.changedTouches[0].clientX - this._startPosition;
                if (distance < 0 && this.activeTab === this.getCurrentTabPanes().length - 1) {
                    return;
                }
                else if (distance > 0 && this.activeTab === 0) {
                    return;
                }
                // velocity 小于阈值才认为是pan操作
                if (this.getVelocity(distance, event.timeStamp - this._startTime) <= this._velocityThreshold &&
                    this.useOnPan &&
                    this.swipeable &&
                    this.animated) {
                    this.paneMoveStyle = 'translate3d(calc(-' + this.selectedKey * 100 + '% + ' + distance + 'px), 0, 0 )';
                }
            }
            else if ('vertical' === this._tabDirection) {
                /** @type {?} */
                const distance = event.changedTouches[0].clientY - this._startPosition;
                if (distance < 0 && this.activeTab === this.getCurrentTabPanes().length - 1) {
                    return;
                }
                else if (distance > 0 && this.activeTab === 0) {
                    return;
                }
                if (this.getVelocity(distance, event.timeStamp - this._startTime) <= this._velocityThreshold &&
                    this.useOnPan &&
                    this.swipeable &&
                    this.animated) {
                    this.paneMoveStyle = 'translate3d(0, calc(-' + this.selectedKey * 100 + '% + ' + distance + 'px, 0 )';
                }
            }
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onTouchEnd(event) {
        if (this.getCurrentTabPanes() && this.getCurrentTabPanes().length > 0) {
            if ('horizontal' === this._tabDirection) {
                /** @type {?} */
                const distance = event.changedTouches[0].clientX - this._startPosition;
                /** @type {?} */
                const distanceToChangeTabPx = this.tabContent.nativeElement.offsetWidth * this.distanceToChangeTab;
                if ((this.getVelocity(distance, event.timeStamp - this._startTime) <= this._velocityThreshold &&
                    (this.useOnPan && this.swipeable && Math.abs(distance) > distanceToChangeTabPx)) ||
                    (this.getVelocity(distance, event.timeStamp - this._startTime) > this._velocityThreshold &&
                        (this.swipeable && Math.abs(distance) > distanceToChangeTabPx / 2))) {
                    if (distance < 0 && this.activeTab < this.getCurrentTabPanes().length - 1) {
                        this.keyToSelect++;
                    }
                    else if (distance > 0 && this.activeTab > 0) {
                        this.keyToSelect--;
                    }
                }
                this.paneMoveStyle = 'translate3d(-' + this.selectedKey * 100 + '%, 0, 0 )';
            }
            else if ('vertical' === this._tabDirection) {
                /** @type {?} */
                const distance = event.changedTouches[0].clientY - this._startPosition;
                /** @type {?} */
                const distanceToChangeTabPx = this.tabContent.nativeElement.offsetHeight * this.distanceToChangeTab;
                if ((this.getVelocity(distance, event.timeStamp - this._startTime) <= this._velocityThreshold &&
                    (this.useOnPan && this.swipeable && Math.abs(distance) > distanceToChangeTabPx)) ||
                    (this.getVelocity(distance, event.timeStamp - this._startTime) > this._velocityThreshold &&
                        (this.swipeable && Math.abs(distance) > distanceToChangeTabPx / 2))) {
                    if (distance < 0 && this.activeTab < this.getCurrentTabPanes().length - 1) {
                        this.keyToSelect++;
                    }
                    else if (distance > 0 && this.activeTab > 0) {
                        this.keyToSelect--;
                    }
                }
                this.paneMoveStyle = 'translate3d(0, -' + this.selectedKey * 100 + '%, 0 )';
            }
        }
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.selectTabPane(this.keyToSelect);
        this.selectedKey = this.keyToSelect;
    }
    /**
     * @return {?}
     */
    ngDoCheck() {
        if (this.keyToSelect !== this.selectedKey && this.getCurrentTabPanes() && this.getCurrentTabPanes().length > 0) {
            this.selectTabPane(this.keyToSelect);
            this.selectedKey = this.keyToSelect;
            this.onChange.emit({ index: this.selectedKey });
        }
    }
    /**
     * @private
     * @param {?} index
     * @return {?}
     */
    selectTabPane(index) {
        if (this.getCurrentTabPanes() && this.getCurrentTabPanes().length > 0) {
            /** @type {?} */
            const actualKeyToSelect = Math.min(this.getCurrentTabPanes().length - 1, Math.max(index || 0, 0));
            if ('horizontal' === this._tabDirection) {
                this.paneMoveStyle = 'translate3d(-' + actualKeyToSelect * 100 + '%, 0, 0 )';
            }
            else if ('vertical' === this._tabDirection) {
                this.paneMoveStyle = 'translate3d(0, -' + actualKeyToSelect * 100 + '%, 0 )';
            }
        }
    }
    /**
     * @private
     * @param {?} deltaDistance
     * @param {?} deltaTime
     * @return {?}
     */
    getVelocity(deltaDistance, deltaTime) {
        return Math.abs(deltaDistance / deltaTime);
    }
}
TabsComponent.decorators = [
    { type: Component, args: [{
                selector: 'Tabs, nzm-tabs',
                template: "<ng-container>\n  <ng-template *ngIf=\"'top' === tabBarPosition || 'left' === tabBarPosition\"\n               [ngTemplateOutlet]=\"renderTabBar || renderDefaultTabBar\">\n  </ng-template>\n  <div #TabContent\n       class=\"{{prefixCls}}-content-wrap\"\n       [ngClass]=\"{'am-tabs-content-wrap-animated': animated}\"\n       [ngStyle]=\"{'transform': paneMoveStyle, 'webkitTransform': paneMoveStyle}\"\n       (touchstart)=\"onTouchStart($event)\"\n       (touchmove)=\"onTouchMove($event)\"\n       (touchend)=\"onTouchEnd($event)\"\n  >\n    <div tab-pane-body\n         *ngFor=\"let tabPane of getCurrentTabPanes(); let i = index\"\n         [active]=\"i === selectedKey\"\n         [prerender]=\"prerenderingSiblingsNumber < 0 || ((selectedKey - i <= prerenderingSiblingsNumber) && (selectedKey - i + prerenderingSiblingsNumber >= 0))\"\n         [content]=\"tabPane.content\"\n    ></div>\n  </div>\n  <ng-template *ngIf=\"'bottom' === tabBarPosition || 'right' === tabBarPosition\"\n               [ngTemplateOutlet]=\"renderTabBar || renderDefaultTabBar\"\n  ></ng-template>\n</ng-container>\n\n<ng-template #renderDefaultTabBar>\n  <DefaultTabBar #DefaultTabBar\n                 [page]=\"page\"\n                 [animated]=\"animated\"\n                 [activeTab]=\"selectedKey\"\n                 [tabTitleSize]=\"tabTitleSize\"\n                 [tabBarPosition]=\"tabBarPosition\"\n                 [tabBarBackgroundColor]=\"tabBarBackgroundColor\"\n                 [tabBarUnderlineStyle]=\"tabBarUnderlineStyle\"\n  >\n    <div #TabTitle\n         *ngFor=\"let tabPane of getCurrentTabPanes(); let i = index\"\n         class=\"{{prefixCls}}-default-bar-tab\"\n         [ngClass]=\"{'am-tabs-default-bar-tab-active': i === selectedKey, 'am-tabs-default-bar-tab-disabled': tabPane.disabled}\"\n         [ngStyle]=\"tabBarTextStyle\"\n         [style.color]=\"i === selectedKey ? tabBarActiveTextColor : tabBarInactiveTextColor\"\n         (click)=\"clickTab(i)\"\n    >\n      <ng-container *ngIf=\"tabPane.isTitleString; else titleTemplate\">\n        {{tabPane.title}}\n      </ng-container>\n      <ng-template #titleTemplate>\n        <ng-template [ngTemplateOutlet]=\"tabPane.title\"></ng-template>\n      </ng-template>\n    </div>\n  </DefaultTabBar>\n</ng-template>",
                encapsulation: ViewEncapsulation.None
            }] }
];
/** @nocollapse */
TabsComponent.ctorParameters = () => [];
TabsComponent.propDecorators = {
    tabPanes: [{ type: ContentChildren, args: [TabPaneComponent, { descendants: false },] }],
    tabContent: [{ type: ViewChild, args: ['TabContent',] }],
    tabsBarSwipe: [{ type: ViewChild, args: ['TabsBarSwipe',] }],
    defaultTabBar: [{ type: ViewChild, args: ['DefaultTabBar',] }],
    tabsBarContainer: [{ type: ViewChild, args: ['TabsBarContainer',] }],
    page: [{ type: Input }],
    swipeable: [{ type: Input }],
    useOnPan: [{ type: Input }],
    animated: [{ type: Input }],
    tabBarUnderlineStyle: [{ type: Input }],
    distanceToChangeTab: [{ type: Input }],
    tabTitleSize: [{ type: Input }],
    tabBarActiveTextColor: [{ type: Input }],
    tabBarInactiveTextColor: [{ type: Input }],
    renderTabBar: [{ type: Input }],
    tabBarBackgroundColor: [{ type: Input }],
    prerenderingSiblingsNumber: [{ type: Input }],
    tabBarTextStyle: [{ type: Input }],
    tabPanesContent: [{ type: Input }],
    activeTab: [{ type: Input }],
    tabBarPosition: [{ type: Input }],
    tabDirection: [{ type: Input }],
    onChange: [{ type: Output }],
    onTabClick: [{ type: Output }],
    amTabs: [{ type: HostBinding, args: ['class.am-tabs',] }],
    amTabsTop: [{ type: HostBinding, args: ['class.am-tabs-top',] }],
    amTabsLeft: [{ type: HostBinding, args: ['class.am-tabs-left',] }],
    amTabsRight: [{ type: HostBinding, args: ['class.am-tabs-right',] }],
    amTabsBottom: [{ type: HostBinding, args: ['class.am-tabs-bottom',] }],
    amTabsVertical: [{ type: HostBinding, args: ['class.am-tabs-vertical',] }],
    amTabsHorizontal: [{ type: HostBinding, args: ['class.am-tabs-horizontal',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TabPaneBodyComponent {
    constructor() {
        this._prerender = false;
        this.active = false;
        this.loaded = false;
        this.paneWrap = true;
    }
    /**
     * @return {?}
     */
    get prerender() {
        return this._prerender;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set prerender(value) {
        this._prerender = value;
        if (value) {
            this.loaded = true;
        }
    }
    /**
     * @return {?}
     */
    get wrapActive() {
        return this.active;
    }
    /**
     * @return {?}
     */
    get wrapInactive() {
        return !this.active;
    }
    /**
     * @return {?}
     */
    ngOnInit() { }
}
TabPaneBodyComponent.decorators = [
    { type: Component, args: [{
                selector: '[tab-pane-body]',
                template: "<ng-container *ngIf=\"loaded || prerender\">\n  <ng-template [ngTemplateOutlet]=\"content\"></ng-template>\n</ng-container>",
                encapsulation: ViewEncapsulation.None
            }] }
];
/** @nocollapse */
TabPaneBodyComponent.ctorParameters = () => [];
TabPaneBodyComponent.propDecorators = {
    active: [{ type: Input }],
    loaded: [{ type: Input }],
    content: [{ type: Input }],
    prerender: [{ type: Input }],
    paneWrap: [{ type: HostBinding, args: ['class.am-tabs-pane-wrap',] }],
    wrapActive: [{ type: HostBinding, args: ['class.am-tabs-pane-wrap-active',] }],
    wrapInactive: [{ type: HostBinding, args: ['class.am-tabs-pane-wrap-inactive',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DefaultTabBarComponent {
    /**
     * @param {?} _renderer
     * @param {?} _ref
     */
    constructor(_renderer, _ref) {
        this._renderer = _renderer;
        this._ref = _ref;
        this.prefixCls = 'am-tabs-default-bar';
        this.inkBarStyle = {};
        this.tabsBarStyle = {};
        this.showPrev = false;
        this.showNext = false;
        this.selectedKey = 0;
        this.inkBarOffSet = 0;
        this.inkBarLength = 0;
        this.tabBarNavSwipedPosition = 0;
        this.tabBarNavSwipingPosition = 0;
        this._startPosition = 0;
        this.page = 5;
        this.animated = true;
        this.tabBarBackgroundColor = '#FFF';
        this.tabTitleSize = 0;
        this.tabBarPosition = 'top';
        this.tabBarWrap = true;
        this.getTabSize = (/**
         * @param {?} page
         * @param {?} tabLength
         * @return {?}
         */
        (page, tabLength) => 100 / Math.min(page, tabLength));
    }
    /**
     * @return {?}
     */
    get activeTab() {
        return this.selectedKey;
    }
    /**
     * @param {?} index
     * @return {?}
     */
    set activeTab(index) {
        if (index !== this.selectedKey) {
            this.selectedKey = index;
            if (this.tabTitles && this.tabTitles.length > 0) {
                this.setTabBarStyleCenter();
                this.setInkBarStatus(this.selectedKey);
            }
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onTouchStart(event) {
        if ((this.tabTitleSize > 0 &&
            (this.tabTitleSize * this.tabTitles.length >
                (('top' === this.tabBarPosition || 'bottom' === this.tabBarPosition) ?
                    this.tabsBarSwipe.nativeElement.offsetWidth :
                    this.tabsBarSwipe.nativeElement.offsetHeight))) || (this.tabTitleSize <= 0 && this.page < this.tabTitles.length)) {
            if ('top' === this.tabBarPosition || 'bottom' === this.tabBarPosition) {
                this._startPosition = event && event.changedTouches && event.changedTouches[0] && event.changedTouches[0].clientX;
            }
            else {
                this._startPosition = event && event.changedTouches && event.changedTouches[0] && event.changedTouches[0].clientY;
            }
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onTouchMove(event) {
        event.preventDefault();
        event.stopPropagation();
        if ((this.tabTitleSize > 0 &&
            (this.tabTitleSize * this.tabTitles.length >
                (('top' === this.tabBarPosition || 'bottom' === this.tabBarPosition) ?
                    this.tabsBarSwipe.nativeElement.offsetWidth :
                    this.tabsBarSwipe.nativeElement.offsetHeight))) || (this.tabTitleSize <= 0 && this.page < this.tabTitles.length)) {
            if ('top' === this.tabBarPosition || 'bottom' === this.tabBarPosition) {
                this.setTabBarNavSwipingPosition(event.changedTouches[0].clientX - this._startPosition, this.tabTitles.first.nativeElement.offsetWidth, this.tabsBarSwipe.nativeElement.offsetWidth);
                this.tabsBarStyle = {
                    transition: '0ms',
                    transform: 'translate3d(' + this.tabBarNavSwipingPosition + 'px, 0px, 0px)',
                    webkitTransform: 'translate3d(' + this.tabBarNavSwipingPosition + 'px, 0px, 0px)'
                };
            }
            else {
                this.setTabBarNavSwipingPosition(event.changedTouches[0].clientY - this._startPosition, this.tabTitles.first.nativeElement.offsetHeight, this.tabsBarSwipe.nativeElement.offsetHeight);
                this.tabsBarStyle = {
                    transition: '0ms',
                    transform: 'translate3d(0, ' + this.tabBarNavSwipingPosition + 'px, 0px)',
                    webkitTransform: 'translate3d(0, ' + this.tabBarNavSwipingPosition + 'px, 0px)'
                };
            }
        }
    }
    /**
     * @return {?}
     */
    onTouchEnd() {
        if ((this.tabTitleSize > 0 &&
            (this.tabTitleSize * this.tabTitles.length >
                (('top' === this.tabBarPosition || 'bottom' === this.tabBarPosition) ?
                    this.tabsBarSwipe.nativeElement.offsetWidth :
                    this.tabsBarSwipe.nativeElement.offsetHeight))) || (this.tabTitleSize <= 0 && this.page < this.tabTitles.length)) {
            this.tabBarNavSwipedPosition = this.tabBarNavSwipingPosition;
        }
    }
    /**
     * @return {?}
     */
    onContentChange() {
        this.setTabsStyle();
        this.setInkBarStatus(this.selectedKey);
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.setTabsStyle();
        this.setTabBarStyleCenter();
        this.setInkBarStatus(this.selectedKey);
    }
    /**
     * @private
     * @return {?}
     */
    setTabsStyle() {
        if (this.tabTitles && this.tabTitles.length > 0) {
            if ('top' === this.tabBarPosition || 'bottom' === this.tabBarPosition) {
                this.tabTitles.forEach((/**
                 * @param {?} tabTitle
                 * @return {?}
                 */
                (tabTitle) => {
                    this._renderer.setStyle(tabTitle.nativeElement, 'width', this.tabTitleSize > 0 ? (this.tabTitleSize + 'px') : (this.getTabSize(this.page, this.tabTitles.length) + '%'));
                }));
            }
            else {
                this.tabTitles.forEach((/**
                 * @param {?} tabTitle
                 * @return {?}
                 */
                (tabTitle) => {
                    this._renderer.setStyle(tabTitle.nativeElement, 'height', this.tabTitleSize > 0 ? (this.tabTitleSize + 'px') : this.getTabSize(this.page, this.tabTitles.length) + '%');
                }));
            }
        }
    }
    /**
     * @private
     * @return {?}
     */
    setTabBarStyleCenter() {
        if ('top' === this.tabBarPosition || 'bottom' === this.tabBarPosition) {
            this.setTabBarNavSwipedPosition(this.tabTitleSize > 0 ? this.tabTitleSize :
                (this.tabsBarSwipe.nativeElement.offsetWidth / Math.min(this.tabTitles.length, this.page)), this.tabsBarSwipe.nativeElement.offsetWidth);
            this.tabsBarStyle = {
                transform: 'translate3d(' + this.tabBarNavSwipedPosition + 'px, 0px, 0px)',
                webkitTransform: 'translate3d(' + this.tabBarNavSwipedPosition + ', 0px, 0px)'
            };
        }
        else {
            this.setTabBarNavSwipedPosition(this.tabTitleSize > 0 ? this.tabTitleSize :
                (this.tabsBarSwipe.nativeElement.offsetHeight / Math.min(this.tabTitles.length, this.page)), this.tabsBarSwipe.nativeElement.offsetHeight);
            this.tabsBarStyle = {
                transform: 'translate3d(0, ' + this.tabBarNavSwipedPosition + 'px, 0px)',
                webkitTransform: 'translate3d(0, ' + this.tabBarNavSwipedPosition + 'px, 0px)'
            };
        }
    }
    /**
     * @private
     * @param {?} key
     * @return {?}
     */
    setInkBarStatus(key) {
        if (this.tabTitles && this.tabTitles.length > 0) {
            if ('top' === this.tabBarPosition || 'bottom' === this.tabBarPosition) {
                this.inkBarOffSet = this.tabTitles.toArray()[key].nativeElement.offsetLeft;
                this.inkBarLength = this.tabTitles.toArray()[key].nativeElement.style.width;
                this.inkBarStyle = {
                    width: this.inkBarLength,
                    left: this.tabTitleSize > 0 ?
                        (this.selectedKey * this.tabTitleSize + 'px') :
                        ((this.selectedKey * 100) / Math.min(this.tabTitles.length, this.page) + '%')
                };
                Object.assign(this.inkBarStyle, this.tabBarUnderlineStyle);
            }
            else {
                this.inkBarOffSet = this.tabTitles.toArray()[key].nativeElement.offsetTop;
                this.inkBarLength = this.tabTitles.toArray()[key].nativeElement.style.height;
                this.inkBarStyle = {
                    height: this.inkBarLength,
                    top: this.tabTitleSize > 0 ?
                        (this.selectedKey * this.tabTitleSize + 'px') :
                        ((this.selectedKey * 100) / Math.min(this.tabTitles.length, this.page) + '%')
                };
                Object.assign(this.inkBarStyle, this.tabBarUnderlineStyle);
            }
            this._ref.detectChanges();
        }
    }
    /**
     * @private
     * @param {?} swipingDistance
     * @param {?} swipingItemLength
     * @param {?} viewportLength
     * @return {?}
     */
    setTabBarNavSwipingPosition(swipingDistance, swipingItemLength, viewportLength) {
        if (this.tabBarNavSwipedPosition + swipingDistance > 0) {
            this.tabBarNavSwipingPosition = 0;
        }
        else if ((this.tabBarNavSwipedPosition + swipingDistance) <
            (viewportLength - swipingItemLength * this.tabTitles.length)) {
            this.tabBarNavSwipingPosition = viewportLength - swipingItemLength * this.tabTitles.length;
            this.showNext = false;
        }
        else {
            this.tabBarNavSwipingPosition = this.tabBarNavSwipedPosition + swipingDistance;
            this.showNext = true;
        }
        if (this.tabBarNavSwipingPosition < 0) {
            this.showPrev = true;
        }
        else {
            this.showPrev = false;
        }
    }
    /**
     * @private
     * @param {?} swipingItemLength
     * @param {?} viewportLength
     * @return {?}
     */
    setTabBarNavSwipedPosition(swipingItemLength, viewportLength) {
        if (this.selectedKey * swipingItemLength + this.tabBarNavSwipedPosition <= 0) {
            if (0 === this.selectedKey) {
                this.tabBarNavSwipedPosition = 0;
            }
            else {
                this.tabBarNavSwipedPosition = (1 - this.selectedKey) * swipingItemLength;
            }
        }
        else if ((this.selectedKey + 1) * swipingItemLength >=
            (viewportLength - this.tabBarNavSwipedPosition)) {
            if (this.tabTitles.length - 1 === this.selectedKey) {
                this.tabBarNavSwipedPosition = viewportLength - (this.selectedKey + 1) * swipingItemLength;
            }
            else {
                this.tabBarNavSwipedPosition = viewportLength - (this.selectedKey + 2) * swipingItemLength;
            }
        }
        if (this.tabBarNavSwipedPosition < 0) {
            this.showPrev = true;
        }
        else {
            this.showPrev = false;
        }
        if ((this.tabBarNavSwipedPosition + swipingItemLength * this.tabTitles.length - viewportLength) > 0) {
            this.showNext = true;
        }
        else {
            this.showNext = false;
        }
    }
}
DefaultTabBarComponent.decorators = [
    { type: Component, args: [{
                selector: 'DefaultTabBar, nzm-default-tab-bar',
                template: "<div class=\"{{prefixCls}} {{prefixCls}}-{{tabBarPosition}}\"\n     [ngClass]=\"{'am-tabs-default-bar-animated' : animated}\"\n     [ngStyle]=\"{backgroundColor: tabBarBackgroundColor || '#FFF'}\"\n>\n  <div *ngIf=\"showPrev\" class=\"{{prefixCls}}-prevpage\"></div>\n  <div #TabsBarSwipe\n       class=\"{{prefixCls}}-content\"\n       [ngStyle]=\"tabsBarStyle\"\n       (touchstart)=\"onTouchStart($event)\"\n       (touchmove)=\"onTouchMove($event)\"\n       (touchend)=\"onTouchEnd()\"\n       (cdkObserveContent)=\"onContentChange()\"\n  >\n    <ng-content></ng-content>\n    <div class=\"{{prefixCls}}-underline\" [ngStyle]=\"inkBarStyle\">\n    </div>\n  </div>\n  <div *ngIf=\"showNext\" class=\"{{prefixCls}}-nextpage\"></div>\n</div>"
            }] }
];
/** @nocollapse */
DefaultTabBarComponent.ctorParameters = () => [
    { type: Renderer2 },
    { type: ChangeDetectorRef }
];
DefaultTabBarComponent.propDecorators = {
    tabTitles: [{ type: ContentChildren, args: ['TabTitle',] }],
    tabsBarSwipe: [{ type: ViewChild, args: ['TabsBarSwipe',] }],
    page: [{ type: Input }],
    animated: [{ type: Input }],
    tabBarUnderlineStyle: [{ type: Input }],
    tabBarBackgroundColor: [{ type: Input }],
    tabTitleSize: [{ type: Input }],
    tabBarPosition: [{ type: Input }],
    activeTab: [{ type: Input }],
    tabBarWrap: [{ type: HostBinding, args: ['class.am-tabs-tab-bar-wrap',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TabsModule {
}
TabsModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, ObserversModule],
                declarations: [TabPaneComponent, TabsComponent, TabPaneBodyComponent, DefaultTabBarComponent],
                exports: [TabPaneComponent, TabsComponent, TabPaneBodyComponent, DefaultTabBarComponent],
                providers: []
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TabBarItemComponent extends TabPaneComponent {
    constructor() {
        super();
        this.prefixCls = 'am-tab-bar-tab';
        this.selected = false;
        this.tintColor = '#108ee9';
        this.unselectedTintColor = '#888';
        this.key = '';
        this.title = '';
        this.dot = false;
        this.badge = null;
        this.icon = null;
        this.selectedIcon = null;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    isTemplateRef(value) {
        return value instanceof TemplateRef;
    }
}
TabBarItemComponent.decorators = [
    { type: Component, args: [{
                selector: 'TabBarItem, nzm-tab-bar-item',
                template: "<ng-template #content>\n  <ng-content></ng-content>\n</ng-template>\n\n<ng-template #tabBarTab>\n  <div class=\"{{prefixCls}}-icon\"\n       [style.color]=\"selected ? tintColor : unselectedTintColor\">\n    <Badge *ngIf=\"badge\" className=\"{{prefixCls}}-badge tab-badge\" [text]=\"badge\">\n      <ng-container *ngIf=\"isTemplateRef(selected ? selectedIcon : icon); then domTemplate; else imgTemplate\">\n      </ng-container>\n    </Badge>\n    <Badge className=\"{{prefixCls}}-badge tab-badge\" [dot]=\"dot\" *ngIf=\"dot\">\n      <ng-container *ngIf=\"isTemplateRef(selected ? selectedIcon : icon); then domTemplate; else imgTemplate\">\n      </ng-container>\n    </Badge>\n    <ng-container *ngIf=\"!badge && !dot\" >\n      <ng-container *ngIf=\"isTemplateRef(selected ? selectedIcon : icon); then domTemplate; else imgTemplate\">\n      </ng-container>\n    </ng-container>\n  </div>\n  <p class=\"{{prefixCls}}-title\" [style.color]=\"selected ? tintColor : unselectedTintColor\">\n    {{title}}\n  </p>\n</ng-template>\n\n<ng-template #domTemplate>\n  <ng-template [ngTemplateOutlet]=\"(selected ? selectedIcon : icon)\"></ng-template>\n</ng-template>\n\n<ng-template #imgTemplate >\n  <img src=\"{{selected ? selectedIcon : icon}}\" alt=\"{{title}}\">\n</ng-template>"
            }] }
];
/** @nocollapse */
TabBarItemComponent.ctorParameters = () => [];
TabBarItemComponent.propDecorators = {
    tabBarTab: [{ type: ViewChild, args: ['tabBarTab',] }],
    key: [{ type: Input }],
    title: [{ type: Input }],
    dot: [{ type: Input }],
    badge: [{ type: Input }],
    icon: [{ type: Input }],
    selectedIcon: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TabBarComponent {
    constructor() {
        this.prefixCls = 'am-tab-bar';
        this._activeTab = 0;
        this._tintColor = '#108ee9';
        this._unselectedTintColor = '#888';
        this.hidden = false;
        this.prerenderingSiblingsNumber = -1;
        this.barTintColor = 'white';
        this.tabBarPosition = 'bottom';
        this.onPress = new EventEmitter();
        this.tabBar = true;
    }
    /**
     * @return {?}
     */
    get activeTab() {
        return this._activeTab;
    }
    /**
     * @param {?} tab
     * @return {?}
     */
    set activeTab(tab) {
        this._activeTab = tab;
        if (this.tabBarItems && this.tabBarItems.length > 0) {
            this.selectTabBarItem(tab);
        }
    }
    /**
     * @return {?}
     */
    get tintColor() {
        return this._tintColor;
    }
    /**
     * @param {?} color
     * @return {?}
     */
    set tintColor(color) {
        this._tintColor = color;
        if (this.tabBarItems && this.tabBarItems.length > 0) {
            this.tabBarItems.forEach((/**
             * @param {?} tabBarItem
             * @return {?}
             */
            (tabBarItem) => {
                tabBarItem.tintColor = this._tintColor;
            }));
        }
    }
    /**
     * @return {?}
     */
    get unselectedTintColor() {
        return this._unselectedTintColor;
    }
    /**
     * @param {?} color
     * @return {?}
     */
    set unselectedTintColor(color) {
        this._unselectedTintColor = color;
        if (this.tabBarItems && this.tabBarItems.length > 0) {
            this.tabBarItems.forEach((/**
             * @param {?} tabBarItem
             * @return {?}
             */
            (tabBarItem) => {
                tabBarItem.unselectedTintColor = this._unselectedTintColor;
            }));
        }
    }
    /**
     * @param {?} index
     * @return {?}
     */
    selectTabBarItem(index) {
        if (this.tabBarItems && this.tabBarItems.length > 0) {
            this.tabBarItems.forEach((/**
             * @param {?} tabBarItem
             * @return {?}
             */
            (tabBarItem) => {
                tabBarItem.selected = false;
            }));
            this.tabBarItems.toArray()[index].selected = true;
        }
    }
    /**
     * @param {?} pressParam
     * @return {?}
     */
    tabBarTabOnPress(pressParam) {
        this.onPress.emit(pressParam);
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        if (this.tabBarItems && this.tabBarItems.length > 0) {
            this.tabBarItems.forEach((/**
             * @param {?} tabBarItem
             * @return {?}
             */
            (tabBarItem) => {
                tabBarItem.tintColor = this._tintColor;
                tabBarItem.unselectedTintColor = this._unselectedTintColor;
            }));
        }
        this.selectTabBarItem(this.activeTab);
    }
}
TabBarComponent.decorators = [
    { type: Component, args: [{
                selector: 'TabBar, nzm-tab-bar',
                template: "<Tabs [activeTab]=\"activeTab\"\n      [swipeable]=\"false\"\n      [useOnPan]=\"false\"\n      [animated]=\"false\"\n      [tabDirection]=\"'horizontal'\"\n      [tabBarPosition]='tabBarPosition'\n      [renderTabBar]=\"TabBarBar\"\n      [prerenderingSiblingsNumber]=\"prerenderingSiblingsNumber\"\n      [tabPanesContent]=\"tabBarItems\"\n></Tabs>\n\n<ng-template #TabBarBar>\n  <div class=\"am-tabs-tab-bar-wrap\">\n    <div class=\"{{prefixCls}}-bar\"\n         [ngClass]=\"{'am-tab-bar-bar-hidden-top': 'top' === tabBarPosition && hidden, 'am-tab-bar-bar-hidden-bottom': 'bottom' === tabBarPosition && hidden}\"\n         [style.background-color]=\"barTintColor\">\n      <div class=\"am-tab-bar-tab\" *ngFor=\"let tabBarItem of tabBarItems; let i = index;\" (click)=\"tabBarTabOnPress({'index': i, 'key': tabBarItem.key, 'title': tabBarItem.title})\">\n        <ng-container [ngTemplateOutlet]=\"tabBarItem.tabBarTab\"></ng-container>\n      </div>\n    </div>\n  </div>\n</ng-template>"
            }] }
];
/** @nocollapse */
TabBarComponent.ctorParameters = () => [];
TabBarComponent.propDecorators = {
    tabBarItems: [{ type: ContentChildren, args: [TabBarItemComponent, { descendants: true },] }],
    hidden: [{ type: Input }],
    prerenderingSiblingsNumber: [{ type: Input }],
    activeTab: [{ type: Input }],
    barTintColor: [{ type: Input }],
    tabBarPosition: [{ type: Input }],
    tintColor: [{ type: Input }],
    unselectedTintColor: [{ type: Input }],
    onPress: [{ type: Output }],
    tabBar: [{ type: HostBinding, args: ['class.am-tab-bar',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TabBarModule {
}
TabBarModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, TabsModule, BadgeModule],
                exports: [TabBarComponent, TabBarItemComponent],
                declarations: [TabBarComponent, TabBarItemComponent],
                providers: []
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PickerOptions {
    constructor() {
        this.data = [];
        this.value = [];
        this.cols = 3;
        this.mask = true;
        this.title = '';
        this.okText = '确定';
        this.dismissText = '取消';
        this.disabled = false;
        this.cascade = true;
        this.appendToBody = false;
        this.onDismiss = new EventEmitter();
        this.onPickerChange = new EventEmitter();
        this.indicatorStyle = {};
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PickerComponent {
    /**
     * @param {?} elementRef
     * @param {?} options
     * @param {?} _localeProviderService
     */
    constructor(elementRef, options, _localeProviderService) {
        this.elementRef = elementRef;
        this.options = options;
        this._localeProviderService = _localeProviderService;
        this.transitionName = 'am-slide-up-enter am-slide-up-enter-active';
        this.maskTransitionName = 'am-fade-enter am-fade-enter-active';
        this.startY = 0;
        this.differY = 0;
        this.currentY = 0;
        this.len = 0;
        this.dom = null;
        this.index = 0;
        this.maxY = 0;
        this.lineHeight = 34;
        this.dataForRender = [];
        this.selectedTarget = [];
        this.isMouseDown = false;
        this.Velocity = getVelocity();
        this._unsubscribe$ = new Subject();
        this.onChange = (/**
         * @param {?} _
         * @return {?}
         */
        (_) => { });
    }
    /**
     * @param {?} event
     * @return {?}
     */
    panstart(event) {
        if (!event.target.classList.contains('am-picker-col-mask') || this.options.disabled) {
            return;
        }
        this.isMouseDown = true;
        event.preventDefault();
        this.dom = getEventTarget(event).target.parentElement.children[2];
        this.len = this.dom.children.length;
        this.maxY = -(this.len - 1);
        if (this.dom.style.transform === 'translateY(0px)') {
            this.currentY = 0;
            this.maxY = -(this.len - 1);
        }
        else if (this.selectedTarget.length > 0) {
            this.selectedTarget.forEach((/**
             * @param {?} item
             * @return {?}
             */
            item => {
                if (item.targetId === event.target.id) {
                    this.currentY = item.currentY;
                }
            }));
        }
        this.startY = getEventTarget(event).clientY;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    panmove(event) {
        if (!event.target.classList.contains('am-picker-col-mask') || !this.isMouseDown || this.options.disabled) {
            return;
        }
        event.preventDefault();
        /** @type {?} */
        const ev = getEventTarget(event);
        this.differY = ev.clientY - this.startY;
        this.Velocity.record(this.differY);
        this.dom.style.transition = 'transform 0s';
        this.dom.style.transform = `translateY(${this.currentY * this.lineHeight + this.differY}px)`;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    panend(event) {
        if (!event.target.classList.contains('am-picker-col-mask') || !this.isMouseDown || this.options.disabled) {
            return;
        }
        this.isMouseDown = false;
        event.preventDefault();
        /** @type {?} */
        const ev = getEventTarget(event);
        this.differY = ev.clientY - this.startY;
        /** @type {?} */
        let time = 0.3;
        /** @type {?} */
        const velocityTemp = this.Velocity.getVelocity(this.differY) * 4;
        if (velocity) {
            this.differY = velocityTemp * 40 + this.differY;
            time = Math.abs(velocityTemp) * 0.1;
        }
        this.dom.style.transition = 'transform ' + (time < 0.3 ? 0.3 : time) + 's';
        if (this.differY <= -this.lineHeight / 2) {
            this.currentY += Math.floor(this.differY / this.lineHeight);
            if (this.currentY <= this.maxY) {
                this.currentY = this.maxY;
            }
        }
        else if (this.differY >= this.lineHeight / 2) {
            this.currentY += Math.floor(this.differY / this.lineHeight);
            if (this.currentY >= 0) {
                this.currentY = 0;
            }
        }
        if (this.selectedTarget.length > 0) {
            /** @type {?} */
            let hasKey = false;
            this.selectedTarget.forEach((/**
             * @param {?} item
             * @return {?}
             */
            item => {
                if (item.targetId === event.target.id) {
                    hasKey = true;
                    item.targetId = event.target.id;
                    item.currentY = this.currentY;
                }
                else if (parseInt(item.targetId, 0) > parseInt(event.target.id, 0) && this.options.cascade) {
                    item.currentY = 0;
                }
            }));
            if (!hasKey) {
                this.selectedTarget.push({ targetId: event.target.id, currentY: this.currentY });
            }
        }
        else {
            this.selectedTarget.push({ targetId: event.target.id, currentY: this.currentY });
        }
        this.dom.style.transform = `translateY(${this.currentY * this.lineHeight}px)`;
        this.index = Math.floor(Math.abs(this.currentY / 1));
        this.setCurrentSelected(parseInt(event.target.id, 0), this.index);
        if (this.options.value !== this.combineReslut()) {
            this.options.onPickerChange.emit(this.combineReslut());
            this.onChange(this.combineReslut());
        }
    }
    /**
     * @return {?}
     */
    init() {
        if (this.dataForRender.length === 0 && this.generateArrayData(this.options.data).length > 0) {
            this.dataForRender.push(this.generateArrayData(this.options.data));
        }
        if (this.options.value.length > 0) {
            this.getInitValueIndex(this.dataForRender);
        }
        else {
            this.checkArrayDeep(this.options.data[0]);
            for (let index = 0; index < this.dataForRender.length; index++) {
                this.selectedTarget.push({ targetId: `${index}`, currentY: 0 });
            }
        }
    }
    /**
     * @param {?} dataTemp
     * @return {?}
     */
    getInitValueIndex(dataTemp) {
        /** @type {?} */
        const self = this;
        self.selectedTarget = [];
        self.options.value.forEach((/**
         * @param {?} element
         * @param {?} i
         * @return {?}
         */
        (element, i) => {
            dataTemp.forEach((/**
             * @param {?} item
             * @param {?} j
             * @return {?}
             */
            (item, j) => {
                item.forEach((/**
                 * @param {?} item1
                 * @param {?} k
                 * @return {?}
                 */
                (item1, k) => {
                    if ((element === item1.label || element === item1.value || element === item1) && i === j) {
                        self.checkArrayDeep(self.dataForRender[i][k], false);
                        self.selectedTarget.push({ targetId: `${i}`, currentY: -k });
                    }
                }));
            }));
        }));
    }
    /**
     * @return {?}
     */
    reloadPicker() {
        if (!this._picker || this._picker === undefined) {
            return;
        }
        this.currentPicker = this._picker.element.nativeElement;
        if (this.currentPicker && this.currentPicker.children.length > 0) {
            /** @type {?} */
            const self = this;
            setTimeout((/**
             * @return {?}
             */
            () => {
                self.selectedTarget.forEach((/**
                 * @param {?} item
                 * @param {?} i
                 * @return {?}
                 */
                (item, i) => {
                    self.currentPicker.children[i].children[2].style.transition = 'transform .3s';
                    /** @type {?} */
                    const index = parseInt(item.currentY, 0);
                    self.currentPicker.children[i].children[2].style.transform = `translateY(${index * self.lineHeight}px)`;
                }));
            }), 0);
        }
    }
    /**
     * @param {?} targetArr
     * @return {?}
     */
    generateArrayData(targetArr) {
        /** @type {?} */
        const tempArr = [];
        if (targetArr instanceof Array) {
            targetArr.forEach((/**
             * @param {?} item
             * @param {?} i
             * @return {?}
             */
            (item, i) => {
                if (item instanceof Array) {
                    /** @type {?} */
                    const keys = Object.keys(item);
                    /** @type {?} */
                    const element = {};
                    keys.forEach((/**
                     * @param {?} key
                     * @return {?}
                     */
                    key => {
                        element[key] = targetArr[i][key] || targetArr[i];
                    }));
                    tempArr.push(element);
                }
                else {
                    tempArr.push(item);
                }
            }));
            return tempArr;
        }
        return [];
    }
    /**
     * @param {?} parent
     * @param {?=} init
     * @return {?}
     */
    checkArrayDeep(parent, init = true) {
        if (parent instanceof Object && parent.children && parent.children.length > 0) {
            if (this.generateArrayData(parent.children).length > 0 && this.dataForRender.length < this.options.cols) {
                /** @type {?} */
                let hasValue = false;
                this.dataForRender.filter((/**
                 * @param {?} item
                 * @param {?} index
                 * @return {?}
                 */
                (item, index) => {
                    if (JSON.stringify(item) === JSON.stringify(parent.children)) {
                        hasValue = true;
                    }
                }));
                if (!hasValue) {
                    this.dataForRender.push(this.generateArrayData(parent.children));
                }
                if (init) {
                    this.checkArrayDeep(parent.children[0]);
                }
            }
        }
    }
    /**
     * @return {?}
     */
    ok() {
        if (this.options.updateNgModel) {
            this.options.updateNgModel(this.combineReslut());
        }
        if (this.options.confirm) {
            this.options.confirm(this.combineReslut());
        }
        this.setTransitionName();
    }
    /**
     * @return {?}
     */
    combineReslut() {
        /** @type {?} */
        const result = [];
        /** @type {?} */
        const self = this;
        self.selectedTarget.forEach((/**
         * @param {?} item
         * @return {?}
         */
        item => {
            if (self.dataForRender.length > 0 && self.dataForRender.length >= parseInt(item.targetId, 0) + 1) {
                /** @type {?} */
                const curItem = self.dataForRender[parseInt(item.targetId, 0)][-item.currentY];
                if (curItem !== undefined) {
                    result.push(curItem);
                }
            }
        }));
        return result;
    }
    /**
     * @return {?}
     */
    cancel() {
        this.setTransitionName();
        this.options.onDismiss.emit();
        if (this.options.cancel) {
            this.options.cancel();
        }
    }
    /**
     * @return {?}
     */
    setTransitionName() {
        this.transitionName = 'am-slide-up-leave am-slide-up-leave-active';
        this.maskTransitionName = 'am-fade-leave am-fade-leave-active';
        setTimeout((/**
         * @return {?}
         */
        () => {
            this.options.hidePicker();
        }), 200);
    }
    /**
     * @param {?} target
     * @param {?} index
     * @return {?}
     */
    setCurrentSelected(target, index) {
        if (!this.options.cascade) {
            return;
        }
        /** @type {?} */
        const a = this.dataForRender.slice(0, target + 1);
        this.dataForRender = a;
        this.checkArrayDeep(this.dataForRender[target][index]);
        if (this.selectedTarget.length > 0 && this.selectedTarget.length < this.dataForRender.length) {
            for (let i = 0; i < this.dataForRender.length; i++) {
                if (i > target) {
                    if (i < this.selectedTarget.length) {
                        this.selectedTarget[i] = { targetId: `${i}`, currentY: 0 };
                    }
                    else {
                        this.selectedTarget.push({ targetId: `${i}`, currentY: 0 });
                    }
                }
            }
        }
        setTimeout((/**
         * @return {?}
         */
        () => {
            this.dataForRender.forEach((/**
             * @param {?} item
             * @param {?} i
             * @return {?}
             */
            (item, i) => {
                if (target !== `${i}` && i > target) {
                    this._picker.element.nativeElement.children[i].children[2].style.transition = 'transform .3s';
                    this._picker.element.nativeElement.children[i].children[2].style.transform = 'translateY(0px)';
                }
            }));
        }), 0);
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.init();
        this._localeProviderService.localeChange.pipe(takeUntil(this._unsubscribe$)).subscribe((/**
         * @param {?} _
         * @return {?}
         */
        _ => {
            /** @type {?} */
            const locale = this._localeProviderService.getLocaleSubObj('Picker');
            this.options.okText = locale.okText;
            this.options.dismissText = locale.dismissText;
        }));
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.reloadPicker();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._unsubscribe$.next();
        this._unsubscribe$.complete();
    }
}
PickerComponent.decorators = [
    { type: Component, args: [{
                selector: 'Picker',
                template: "<div *ngIf=\"options.mask\" class=\"am-picker-popup-mask {{maskTransitionName}}\" (click)=\"cancel()\"></div>\n<div class=\"am-picker-popup am-picker-popup-wrap {{transitionName}}\" style=\" min-height: 280px\">\n  <div class=\"am-picker-popup-content\">\n    <div class=\"am-picker-popup-body\">\n      <div>\n        <div class=\"am-picker-popup-header\">\n          <div class=\"am-picker-popup-item am-picker-popup-header-left\" (click)=\"cancel()\">{{options.dismissText}}</div>\n          <div class=\"am-picker-popup-item am-picker-popup-title\">{{options.title}}</div>\n          <div class=\"am-picker-popup-item am-picker-popup-header-right\" (click)=\"ok()\">{{options.okText}}</div>\n        </div>\n        <div class=\"am-picker\" style=\"flex-direction: row; align-items: center;\" #picker>\n          <div *ngFor=\"let item of dataForRender; let i = index\" class=\"am-picker-col\">\n            <div class=\"am-picker-col-indicator \" style=\"top: 102px;\" [ngStyle]=\"options.indicatorStyle\"></div>\n            <div class=\"am-picker-col-mask\" style=\"background-size: 100% 102px;\" id={{i}}></div>\n            <div class=\"am-picker-col-content\">\n              <div *ngFor=\"let val of item; let i = index\" class=\"am-picker-col-item\" id={{i}}>{{val.label?val.label:val}}</div>\n            </div>\n          </div>\n        </div>\n      </div>\n    </div>\n  </div>\n</div>\n",
                encapsulation: ViewEncapsulation.None
            }] }
];
/** @nocollapse */
PickerComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: PickerOptions },
    { type: LocaleProviderService }
];
PickerComponent.propDecorators = {
    _picker: [{ type: ViewChild, args: ['picker', { read: ViewContainerRef },] }],
    panstart: [{ type: HostListener, args: ['mousedown', ['$event'],] }, { type: HostListener, args: ['touchstart', ['$event'],] }],
    panmove: [{ type: HostListener, args: ['mousemove', ['$event'],] }, { type: HostListener, args: ['touchmove', ['$event'],] }],
    panend: [{ type: HostListener, args: ['mouseup', ['$event'],] }, { type: HostListener, args: ['mouseleave', ['$event'],] }, { type: HostListener, args: ['touchend', ['$event'],] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PickerDirective {
    /**
     * @param {?} _viewContainerRef
     * @param {?} _elm
     * @param {?} _defaultOptions
     * @param {?} _cfr
     * @param {?} _renderer
     * @param {?} _zone
     */
    constructor(_viewContainerRef, _elm, _defaultOptions, _cfr, _renderer, _zone) {
        this._viewContainerRef = _viewContainerRef;
        this._elm = _elm;
        this._defaultOptions = _defaultOptions;
        this._cfr = _cfr;
        this._renderer = _renderer;
        this._zone = _zone;
        this._eventListeners = [];
        this.onVisibleChange = new EventEmitter(true);
        this.onPickerChange = new EventEmitter();
        this.onDismiss = new EventEmitter();
        this.onChange = (/**
         * @return {?}
         */
        () => null);
        this.onTouched = (/**
         * @return {?}
         */
        () => null);
    }
    /**
     * @return {?}
     */
    togglePicker() {
        if (!this.picker) {
            this.showPicker();
        }
        else {
            this.hidePicker();
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.onVisibleChange.emit(false);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    ngOnChanges(value) {
        if (value.cols && this.picker) {
            this.picker.instance.options.cols = value.cols.currentValue;
        }
        if (value.data && this.picker) {
            this.picker.instance.options.data = value.data.currentValue;
            this.showPicker();
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.hidePicker();
    }
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    onDocumentClick(event) {
        if (this.picker &&
            !this._elm.nativeElement.contains(event.target) &&
            !this.picker.location.nativeElement.contains(event.target)) {
            this.hidePicker();
        }
    }
    /**
     * @private
     * @return {?}
     */
    showPicker() {
        if (this.picker) {
            this._zone.run((/**
             * @return {?}
             */
            () => {
                this.picker.instance.init();
            }));
        }
        else if (!this.picker && !this.disabled) {
            setTimeout((/**
             * @return {?}
             */
            () => {
                this._eventListeners = [
                    this._renderer.listen('document', 'click', (/**
                     * @param {?} event
                     * @return {?}
                     */
                    (event) => this.onDocumentClick(event))),
                    this._renderer.listen('document', 'touchend', (/**
                     * @param {?} event
                     * @return {?}
                     */
                    (event) => this.onDocumentClick(event)))
                ];
            }));
            /** @type {?} */
            const options = new PickerOptions();
            Object.assign(options, this._defaultOptions, {
                hidePicker: (/**
                 * @param {?} event
                 * @return {?}
                 */
                (event) => {
                    this.hidePicker();
                }),
                updateNgModel: (/**
                 * @param {?} value
                 * @return {?}
                 */
                (value) => {
                    this.onChange(value);
                })
            });
            /** @type {?} */
            const optionalParams = [
                'data',
                'value',
                'cols',
                'mask',
                'title',
                'okText',
                'dismissText',
                'disabled',
                'cascade',
                'appendToBody',
                'indicatorStyle',
                'onPickerChange',
                'onVisibleChange',
                'onDismiss'
            ];
            optionalParams.forEach((/**
             * @param {?} param
             * @return {?}
             */
            param => {
                if (typeof this[param] !== 'undefined') {
                    ((/** @type {?} */ (options)))[param] = this[param];
                }
            }));
            /** @type {?} */
            const componentFactory = this._cfr.resolveComponentFactory(PickerComponent);
            /** @type {?} */
            const childInjector = Injector.create([
                {
                    provide: PickerOptions,
                    useValue: options
                }
            ]);
            this.picker = this._viewContainerRef.createComponent(componentFactory, this._viewContainerRef.length, childInjector);
            if (options.appendToBody) {
                document.body.appendChild(this.picker.location.nativeElement);
            }
            this.onVisibleChange.emit(true);
        }
    }
    /**
     * @private
     * @return {?}
     */
    hidePicker() {
        if (this.picker) {
            this.picker.destroy();
            delete this.picker;
            this.onVisibleChange.emit(false);
            this._eventListeners.forEach((/**
             * @param {?} fn
             * @return {?}
             */
            fn => fn()));
            this._eventListeners = [];
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        this.value = Array.isArray(value) ? value : [];
        if (this.picker) {
            this.picker.instance.options.value = this.value;
            this.showPicker();
            this.picker.instance.reloadPicker();
        }
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.onChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    /**
     * @param {?} isDisabled
     * @return {?}
     */
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
}
PickerDirective.decorators = [
    { type: Directive, args: [{
                selector: '[Picker], [nzm-picker]',
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => PickerDirective)),
                        multi: true
                    }
                ]
            },] }
];
/** @nocollapse */
PickerDirective.ctorParameters = () => [
    { type: ViewContainerRef },
    { type: ElementRef },
    { type: PickerOptions },
    { type: ComponentFactoryResolver },
    { type: Renderer2 },
    { type: NgZone }
];
PickerDirective.propDecorators = {
    data: [{ type: Input }],
    cols: [{ type: Input }],
    mask: [{ type: Input }],
    title: [{ type: Input }],
    visible: [{ type: Input }],
    okText: [{ type: Input }],
    dismissText: [{ type: Input }],
    disabled: [{ type: Input }],
    cascade: [{ type: Input }],
    appendToBody: [{ type: Input }],
    indicatorStyle: [{ type: Input }],
    onVisibleChange: [{ type: Output }],
    onPickerChange: [{ type: Output }],
    onDismiss: [{ type: Output }],
    togglePicker: [{ type: HostListener, args: ['click',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PickerService extends PopupService {
    /**
     * @param {?=} config
     * @param {?=} confirmCallback
     * @param {?=} cancelCallback
     * @return {?}
     */
    static showPicker(config = PickerService.defaultOptions, confirmCallback, cancelCallback) {
        /** @type {?} */
        const options = new PickerOptions();
        Object.assign(options, config, {
            hidePicker: (/**
             * @param {?} event
             * @return {?}
             */
            (event) => {
                this.hidePicker();
            }),
            confirm: (/**
             * @param {?} event
             * @return {?}
             */
            (event) => {
                if (confirmCallback) {
                    confirmCallback(event);
                }
            }),
            cancel: (/**
             * @return {?}
             */
            () => {
                if (cancelCallback) {
                    cancelCallback();
                }
            })
        });
        /** @type {?} */
        const childInjector = Injector.create([
            {
                provide: PickerOptions,
                useValue: options
            }
        ]);
        PickerService.showPopup('PickerComponent', PickerComponent, childInjector);
    }
    /**
     * @return {?}
     */
    static hidePicker() {
        PickerService.hidePopup('PickerComponent');
    }
}
PickerService.defaultOptions = new PickerOptions();
PickerService.decorators = [
    { type: Injectable }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PickerModule {
}
PickerModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, OverlayModule],
                exports: [PickerComponent, PickerDirective],
                declarations: [PickerComponent, PickerDirective],
                providers: [PickerOptions, PopupService, PickerService],
                entryComponents: [PickerComponent]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PickerViewComponent extends PickerComponent {
    constructor() {
        super(...arguments);
        this.data = [];
        this.cols = 3;
        this.indicatorStyle = {};
        this.itemStyle = {};
    }
    /**
     * @return {?}
     */
    pickerViewInit() {
        this.options.data = this.data;
        this.options.cols = this.cols;
        this.options.cascade = this.cascade;
        this.init();
    }
    /**
     * @return {?}
     */
    init() {
        this.selectedTarget = [];
        if (this.dataForRender.length === 0 && this.generateArrayData(this.options.data).length > 0) {
            this.dataForRender.push(this.generateArrayData(this.options.data));
        }
        if (this.options.value.length > 0) {
            this.getInitValueIndex(this.dataForRender);
        }
        else {
            for (let index = 0; index < this.dataForRender.length; index++) {
                this.selectedTarget.push({ targetId: `${index}`, currentY: 0 });
            }
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        if (value) {
            this.options.value = value;
            this.init();
        }
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.onChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) { }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.pickerViewInit();
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.currentPicker = this.elementRef.nativeElement;
        this.reloadPicker();
    }
}
PickerViewComponent.decorators = [
    { type: Component, args: [{
                selector: 'PickerView, nzm-picker-view',
                template: "<div #picker class=\"am-picker\" style=\"flex-direction: row; align-items: center;\">\n  <div *ngFor=\"let item of dataForRender; let i = index\" class=\"am-picker-col\">\n    <div #indicator class=\"am-picker-col-indicator \" [ngStyle]=\"indicatorStyle\"></div>\n    <div id={{i}} class=\"am-picker-col-mask\" style=\"background-size: 100% 102px;\"></div>\n    <div class=\"am-picker-col-content\">\n      <div *ngFor=\"let val of item; let i = index\"\n           id={{i}}\n           class=\"am-picker-col-item\"\n           [ngStyle]=\"itemStyle\"\n      >\n        {{val.label?val.label:val}}\n      </div>\n    </div>\n  </div>\n</div>\n",
                encapsulation: ViewEncapsulation.None,
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => PickerViewComponent)),
                        multi: true
                    }
                ]
            }] }
];
PickerViewComponent.propDecorators = {
    data: [{ type: Input }],
    cols: [{ type: Input }],
    cascade: [{ type: Input }],
    indicatorStyle: [{ type: Input }],
    itemStyle: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PickerViewModule {
}
PickerViewModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    FormsModule,
                    CommonModule,
                    PickerModule,
                    LocaleProviderModule
                ],
                exports: [PickerViewComponent],
                declarations: [PickerViewComponent]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ImagePickerComponent {
    constructor() {
        this.prefixCls = 'am-image-picker';
        this.flexEl = [];
        this._accept = 'image/*';
        this._count = 4;
        this._selectable = true;
        this._files = [];
        this._multiple = false;
        this.capture = false;
        this.disableDelete = false;
        this.onFail = new EventEmitter();
        this.onChange = new EventEmitter();
        this.onImageClick = new EventEmitter();
        this.onAddImageClick = new EventEmitter();
    }
    /**
     * @return {?}
     */
    get files() {
        return this._files;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set files(value) {
        this._files = value;
        this.sortItem();
    }
    /**
     * @return {?}
     */
    get accept() {
        return this._accept;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set accept(value) {
        this._accept = value;
        this.sortItem();
    }
    /**
     * @return {?}
     */
    get length() {
        return this._count;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set length(value) {
        if (value > 0) {
            this._count = value;
        }
        else {
            this._count = 4;
        }
        this.sortItem();
    }
    /**
     * @return {?}
     */
    get multiple() {
        return this._multiple;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set multiple(value) {
        this._multiple = value;
        this.sortItem();
    }
    /**
     * @return {?}
     */
    get selectable() {
        return this._selectable;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set selectable(value) {
        this._selectable = value;
        this.sortItem();
    }
    /**
     * @return {?}
     */
    sortItem() {
        if (!this._files) {
            return;
        }
        /** @type {?} */
        let count = parseInt('' + this._count, 10);
        if (count <= 0) {
            count = 4;
        }
        /** @type {?} */
        let allEl = this._files.map((/**
         * @param {?} item
         * @return {?}
         */
        item => {
            return {
                type: 'img',
                backgroundImage: 'url(' + item.url + ')',
                transform: 'rotate(' + this.getRotation(item.orientation) + ')deg'
            };
        }));
        if (this._selectable) {
            allEl.push({
                type: 'select',
                backgroundImage: '',
                transform: ''
            });
        }
        /** @type {?} */
        const length = allEl.length;
        if (length !== 0 && length % count !== 0) {
            /** @type {?} */
            const blankCount = count - (length % count);
            /** @type {?} */
            const fillBlankEl = [];
            for (let i = 0; i < blankCount; i++) {
                fillBlankEl.push({
                    type: 'white',
                    backgroundImage: '',
                    transform: ''
                });
            }
            allEl = allEl.concat(fillBlankEl);
        }
        this.flexEl = [];
        for (let i = 0; i < allEl.length / count; i++) {
            /** @type {?} */
            const rowEl = allEl.slice(i * count, i * count + count);
            this.flexEl.push(rowEl);
        }
    }
    /**
     * @param {?} imgItem
     * @return {?}
     */
    addImage(imgItem) {
        this._files.push({
            type: 'img',
            url: imgItem.url,
            orientation: imgItem.orientation
        });
        this.sortItem();
        this.onChange.emit({
            files: this._files,
            operationType: 'add',
            index: this._files.length - 1
        });
    }
    /**
     * @param {?} index
     * @return {?}
     */
    removeImage(index) {
        this._files.splice(index, 1);
        this.sortItem();
        this.onChange.emit({
            files: this._files,
            operationType: 'remove',
            index: index
        });
    }
    /**
     * @param {?} index
     * @return {?}
     */
    imageClick(index) {
        this.onImageClick.emit({
            index: index,
            files: this._files
        });
    }
    /**
     * @param {?} e
     * @return {?}
     */
    addImageClick(e) {
        this.onAddImageClick.emit(e);
    }
    /**
     * @param {?} file
     * @param {?} index
     * @return {?}
     */
    parseFile(file, index) {
        /** @type {?} */
        const reader = new FileReader();
        reader.onload = (/**
         * @param {?} e
         * @return {?}
         */
        e => {
            /** @type {?} */
            const dataURL = ((/** @type {?} */ (e.target))).result;
            if (!dataURL) {
                this.onFail.emit(`Fail to get the ${index} image`);
                return;
            }
            /** @type {?} */
            let orientation = 1;
            this.getOrientation(file, (/**
             * @param {?} res
             * @return {?}
             */
            res => {
                // -2: not jpeg , -1: not defined
                if (res > 0) {
                    orientation = res;
                }
                this.addImage({
                    url: dataURL,
                    orientation,
                    file
                });
            }));
        });
        reader.readAsDataURL(file);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    fileChange(event) {
        /** @type {?} */
        const fileList = event.target.files;
        if (fileList && fileList.length) {
            for (let i = 0; i < fileList.length; i++) {
                this.parseFile(fileList[i], i);
            }
        }
    }
    /**
     * @param {?=} orientation
     * @return {?}
     */
    getRotation(orientation = 1) {
        /** @type {?} */
        let imgRotation = 0;
        switch (orientation) {
            case 3:
                imgRotation = 180;
                break;
            case 6:
                imgRotation = 90;
                break;
            case 8:
                imgRotation = 270;
                break;
            default:
        }
        return imgRotation;
    }
    // https://stackoverflow.com/questions/7584794/accessing-jpeg-exif-rotation-data-in-javascript-on-the-client-side
    /**
     * @param {?} file
     * @param {?} callback
     * @return {?}
     */
    getOrientation(file, callback) {
        /** @type {?} */
        const reader = new FileReader();
        reader.onload = (/**
         * @param {?} e
         * @return {?}
         */
        e => {
            /** @type {?} */
            const view = new DataView(((/** @type {?} */ (e.target))).result);
            if (view.getUint16(0, false) !== 0xffd8) {
                return callback(-2);
            }
            /** @type {?} */
            const length = view.byteLength;
            /** @type {?} */
            let offset = 2;
            while (offset < length) {
                /** @type {?} */
                const marker = view.getUint16(offset, false);
                offset += 2;
                if (marker === 0xffe1) {
                    /** @type {?} */
                    const tmp = view.getUint32((offset += 2), false);
                    if (tmp !== 0x45786966) {
                        return callback(-1);
                    }
                    /** @type {?} */
                    const little = view.getUint16((offset += 6), false) === 0x4949;
                    offset += view.getUint32(offset + 4, little);
                    /** @type {?} */
                    const tags = view.getUint16(offset, little);
                    offset += 2;
                    for (let i = 0; i < tags; i++) {
                        if (view.getUint16(offset + i * 12, little) === 0x0112) {
                            return callback(view.getUint16(offset + i * 12 + 8, little));
                        }
                    }
                }
                else if ((marker & 0xff00) !== 0xff00) {
                    break;
                }
                else {
                    offset += view.getUint16(offset, false);
                }
            }
            return callback(-1);
        });
        reader.readAsArrayBuffer(file.slice(0, 64 * 1024));
    }
}
ImagePickerComponent.decorators = [
    { type: Component, args: [{
                selector: 'ImagePicker, nzm-image-picker',
                template: "<div class=\"{{prefixCls}}-list\" role=\"group\">\n  <Flex *ngFor=\"let rowItem of flexEl;let i = index;\">\n    <FlexItem *ngFor=\"let item of rowItem;let j =index;\">\n      <div *ngIf=\"item && 'img' === item.type && item.backgroundImage\" class=\"{{prefixCls}}-item\">\n        <div role=\"button\"\n             *ngIf=\"!disableDelete\"\n             aria-label=\"Click and Remove this image\"\n             class=\"{{prefixCls}}-item-remove\"\n             (click)=\"removeImage(i * length + j)\"\n        ></div>\n        <div role=\"button\"\n             aria-label=\"Image can be clicked\"\n             class=\"{{prefixCls}}-item-content\"\n             [ngStyle]=\"{'background-image': item.backgroundImage, 'transform': item.transform}\"\n             (click)=\"imageClick(i * length + j)\"\n        ></div>\n      </div>\n      <div role=\"button\"\n           aria-label=\"Choose and add image\"\n           *ngIf=\"item && 'select' === item.type\"\n           class=\"{{prefixCls}}-item {{prefixCls}}-upload-btn\"\n           (click)=\"addImageClick($event)\"\n      >\n        <input #fileSelectorInput\n               type=\"file\"\n               [accept]=\"accept\"\n               [multiple]=\"multiple\"\n               [attr.capture]=\"capture ? capture : null\"\n               (change)=\"fileChange($event)\"\n        />\n      </div>\n      <div *ngIf=\"item && 'white' === item.type\" class=\"{{prefixCls}}-item-white\">\n      </div>\n    </FlexItem>\n  </Flex>\n</div>\n"
            }] }
];
/** @nocollapse */
ImagePickerComponent.ctorParameters = () => [];
ImagePickerComponent.propDecorators = {
    _fileSelectorInput: [{ type: ViewChild, args: ['fileSelectorInput', { read: ViewContainerRef },] }],
    capture: [{ type: Input }],
    disableDelete: [{ type: Input }],
    files: [{ type: Input }],
    accept: [{ type: Input }],
    length: [{ type: Input }],
    multiple: [{ type: Input }],
    selectable: [{ type: Input }],
    onFail: [{ type: Output }],
    onChange: [{ type: Output }],
    onImageClick: [{ type: Output }],
    onAddImageClick: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ImagePickerModule {
}
ImagePickerModule.decorators = [
    { type: NgModule, args: [{
                declarations: [ImagePickerComponent],
                exports: [ImagePickerComponent],
                imports: [CommonModule, FlexModule]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ResultComponent {
    constructor() {
        this.prefixCls = 'am-result';
        this.isTitleString = true;
        this.isMessageString = true;
        this.onButtonClick = new EventEmitter();
        this.role = 'alert';
        this.amResult = true;
    }
    /**
     * @return {?}
     */
    get title() {
        return this._title;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set title(value) {
        if (this.isTemplateRef(value)) {
            this.isTitleString = false;
        }
        else {
            this.isTitleString = true;
        }
        this._title = value;
    }
    /**
     * @return {?}
     */
    get message() {
        return this._message;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set message(value) {
        if (this.isTemplateRef(value)) {
            this.isMessageString = false;
        }
        else {
            this.isMessageString = true;
        }
        this._message = value;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    buttonClick(event) {
        this.onButtonClick.emit(event);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    isTemplateRef(value) {
        if (value) {
            return value instanceof TemplateRef;
        }
        return false;
    }
}
ResultComponent.decorators = [
    { type: Component, args: [{
                selector: 'Result, nzm-result',
                template: "<div *ngIf=\"img\" class=\"{{prefixCls}}-pic\">\n  <ng-template [ngTemplateOutlet]=\"img\"></ng-template>\n</div>\n<div *ngIf=\"!img && imgUrl\"\n     class=\"{{prefixCls}}-pic\"\n     [ngStyle]=\"{ backgroundImage: 'url('+ imgUrl +')' }\"\n></div>\n<div *ngIf=\"title\" class=\"{{prefixCls}}-title\">\n  <ng-template *ngIf=\"!isTitleString\" [ngTemplateOutlet]=\"title\"></ng-template>\n  <span *ngIf=\"isTitleString\">{{title}}</span>\n</div>\n<div [ngClass]=\"prefixCls+'-message'\">\n  <ng-template *ngIf=\"!isMessageString\" [ngTemplateOutlet]=\"message\"></ng-template>\n  <span *ngIf=\"isMessageString\">{{message}}</span>\n</div>\n<div *ngIf=\"buttonText\" class=\"{{prefixCls}}-button\">\n  <a Button [type]=\"buttonType\" (click)=\"buttonClick($event)\">\n    {{buttonText}}\n  </a>\n</div>\n",
                encapsulation: ViewEncapsulation.None
            }] }
];
/** @nocollapse */
ResultComponent.ctorParameters = () => [];
ResultComponent.propDecorators = {
    title: [{ type: Input }],
    imgUrl: [{ type: Input }],
    buttonText: [{ type: Input }],
    buttonType: [{ type: Input }],
    img: [{ type: Input }],
    message: [{ type: Input }],
    onButtonClick: [{ type: Output }],
    role: [{ type: HostBinding, args: ['attr.role',] }],
    amResult: [{ type: HostBinding, args: ['class.am-result',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ResultModule {
}
ResultModule.decorators = [
    { type: NgModule, args: [{
                declarations: [ResultComponent],
                exports: [ResultComponent],
                imports: [CommonModule, IconModule]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class RangeComponent {
    /**
     * @param {?} _elf
     */
    constructor(_elf) {
        this._elf = _elf;
        this.prefixCls = 'am-slider';
        this.offset = [];
        this.length = [];
        this._min = 0;
        this._max = 100;
        this._step = 1;
        this._defaultValue = [0, 0, 0];
        this._disabled = false;
        this._marks = {};
        this._dots = false;
        this._included = true;
        this._count = 1;
        this._allowCross = true;
        this._handleStyle = [];
        this._trackStyle = [];
        this.onChange = new EventEmitter();
        this.onAfterChange = new EventEmitter();
        this.amWrapper = true;
        this._ngModelOnChange = (/**
         * @return {?}
         */
        () => { });
        this._ngModelOnTouched = (/**
         * @return {?}
         */
        () => { });
    }
    /**
     * @return {?}
     */
    get min() {
        return this._min;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set min(value) {
        this._min = value;
    }
    /**
     * @return {?}
     */
    get max() {
        return this._max;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set max(value) {
        this._max = value;
    }
    /**
     * @return {?}
     */
    get step() {
        return this._step;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set step(value) {
        this._step = value;
    }
    /**
     * @return {?}
     */
    get value() {
        return this._value;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set value(value) {
        this.setValue(value);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set defaultValue(value) {
        this._defaultValue = value;
        this._value = this._defaultValue;
        this.setValue(value);
    }
    /**
     * @return {?}
     */
    get disabled() {
        return this._disabled;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set disabled(value) {
        this._disabled = value;
    }
    /**
     * @return {?}
     */
    get marks() {
        return this._marks;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set marks(value) {
        this._marks = value;
    }
    /**
     * @return {?}
     */
    get dots() {
        return this._dots;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set dots(value) {
        this._dots = value;
    }
    /**
     * @return {?}
     */
    get included() {
        return this._included;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set included(value) {
        this._included = value;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set count(value) {
        this._count = value;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set allowCross(value) {
        this._allowCross = value;
        this.setValueBound();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set pushable(value) {
        this._pushable = value;
        if (this.verifyPushable()) {
            this.setValueBound();
        }
    }
    /**
     * @return {?}
     */
    get handleStyle() {
        return this._handleStyle;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set handleStyle(value) {
        this._handleStyle = value;
    }
    /**
     * @return {?}
     */
    get trackStyle() {
        return this._trackStyle;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set trackStyle(value) {
        this._trackStyle = value;
    }
    /**
     * @return {?}
     */
    get railStyle() {
        return this._railStyle;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set railStyle(value) {
        this._railStyle = value;
    }
    /**
     * @return {?}
     */
    setCls() {
        this.sliderCls = {
            [`${this.prefixCls}-disabled`]: this._disabled
        };
    }
    /**
     * @return {?}
     */
    initialValue() {
        /** @type {?} */
        const minTemp = this._min;
        if (!this.verifyPushable()) {
            this._pushable = 0;
            console.log('pushable设置无效，已大于有些value间隔，被强制设为0');
        }
        /** @type {?} */
        const initialValue = Array.apply(null, Array(this._count + 1)).map((/**
         * @return {?}
         */
        function () {
            return minTemp;
        }));
        this._defaultValue = this._defaultValue !== undefined ? this._defaultValue : initialValue;
        this._value = this._value !== undefined ? this._value : this._defaultValue;
        // 验证count值
        this._count = this._value.length - 1;
        // 验证value区间
        for (let i = 0; i < this._value.length; i++) {
            if (this._value[i] < this._min) {
                this._value[i] = this._min;
            }
            else if (this._value[i] > this._max) {
                this._value[i] = this._max;
            }
        }
        if (this._count > 0) {
            this.upperBound = Math.max(...this._value);
            this.lowerBound = Math.min(...this._value);
        }
    }
    /**
     * @param {?} e
     * @param {?} i
     * @return {?}
     */
    handleChange(e, i) {
        /** @type {?} */
        let temp = [...this._value];
        temp[i] = e;
        this.upperBound = Math.max(...temp);
        this.lowerBound = Math.min(...temp);
        this.setTrackStyle(temp);
        this.onChange.emit(temp);
    }
    /**
     * @param {?} e
     * @param {?} i
     * @return {?}
     */
    handleAfterChange(e, i) {
        setTimeout((/**
         * @return {?}
         */
        () => {
            this._value[i] = e;
            this.upperBound = Math.max(...this._value);
            this.lowerBound = Math.min(...this._value);
            this.setTrackStyle(this._value);
            this.onAfterChange.emit(this._value);
            this._ngModelOnChange(this._value);
            this.setValueBound();
        }), 0);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    setTrackStyle(value) {
        if (value && value.length === this._count + 1) {
            value.sort((/**
             * @param {?} a
             * @param {?} b
             * @return {?}
             */
            (a, b) => a - b));
            for (let i = 0; i < this._count; i++) {
                this.offset[i] = (value[i] * 100) / (this._max - this._min);
                this.length[i] = ((value[i + 1] - value[i]) * 100) / (this._max - this._min);
            }
        }
    }
    /**
     * @return {?}
     */
    setValueBound() {
        this.maxBound = [];
        this.minBound = [];
        if ((this._allowCross && this._pushable === undefined) || this._handleCount <= 1) {
            for (let i = 0; i < this._handleCount; i++) {
                this.maxBound[i] = this._max;
                this.minBound[i] = this._min;
            }
        }
        else {
            if (this._pushable === undefined) {
                this._pushable = 0;
            }
            for (let i = 0; i < this._handleCount; i++) {
                this.maxBound[i] = i === this._handleCount - 1 ? this._max : this._value[i + 1] - this._pushable;
                this.minBound[i] = i === 0 ? this._min : this._value[i - 1] + this._pushable;
            }
        }
    }
    /**
     * @return {?}
     */
    verifyPushable() {
        for (let i = 1; i < this._handleCount; i++) {
            /** @type {?} */
            const diff = this._value[i] - this._value[i - 1];
            if (diff < this._pushable) {
                return false;
            }
        }
        return true;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        this.setValue(value, true);
    }
    /**
     * @param {?} value
     * @param {?=} isWriteValue
     * @return {?}
     */
    setValue(value, isWriteValue = false) {
        if (value) {
            this._value = value;
            this._handleCount = this._value.length + 1;
            this.initialValue();
            this.setValueBound();
            this.setCls();
            this.setTrackStyle(this._value);
            if (isWriteValue) {
                this._ngModelOnChange(this._value);
            }
            else {
                this.onAfterChange.emit(this._value);
            }
        }
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this._ngModelOnChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this._ngModelOnTouched = fn;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.initialValue();
        this.setValueBound();
        this._handleCount = this._count + 1;
        this.setCls();
        /** @type {?} */
        const sliderCoords = this._elf.nativeElement.getElementsByClassName('am-slider')[0].getBoundingClientRect();
        this.sliderLength = sliderCoords.width;
        this.sliderStart = sliderCoords.left;
    }
}
RangeComponent.decorators = [
    { type: Component, args: [{
                selector: 'Range , nzm-range',
                template: "<div class=\"am-slider\" [ngClass]=\"sliderCls\">\n  <div class=\"am-slider-rail\" [ngStyle]=\"railStyle\"></div>\n  <SliderTrack *ngFor=\"let off of offset ; let i = index\"\n               [className]=\"'am-slider-track'\"\n               [included]=\"included\"\n               [style]=\"trackStyle[i]\"\n               [offset]=\"off\"\n               [length]=\"length[i]\"\n  ></SliderTrack>\n  <SliderSteps [max]=\"max\"\n               [min]=\"min\"\n               [dots]=\"dots\"\n               [step]=\"step\"\n               [marks]=\"marks\"\n               [upperBound]=\"upperBound\"\n               [lowerBound]=\"lowerBound\"\n  ></SliderSteps>\n  <SliderHandle *ngFor=\"let val of value ; let i = index\"\n                [max]=\"max\"\n                [min]=\"min\"\n                [maxBound]=\"maxBound[i]\"\n                [minBound]=\"minBound[i]\"\n                [value]=\"val\"\n                [step]=\"step\"\n                [disabled]=\"disabled\"\n                [sliderLength]=\"sliderLength\"\n                [sliderStart]=\"sliderStart\"\n                [handleStyle]=\"handleStyle[i]\"\n                (onChange)=\"handleChange($event , i)\"\n                (onAfterChange)=\"handleAfterChange($event , i)\"\n  ></SliderHandle>\n  <SliderMarks [max]=\"max\"\n               [min]=\"min\"\n               [marks]=\"marks\"\n               [upperBound]=\"upperBound\"\n               [lowerBound]=\"lowerBound\"\n  ></SliderMarks>\n</div>\n",
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => RangeComponent)),
                        multi: true
                    }
                ]
            }] }
];
/** @nocollapse */
RangeComponent.ctorParameters = () => [
    { type: ElementRef }
];
RangeComponent.propDecorators = {
    min: [{ type: Input }],
    max: [{ type: Input }],
    step: [{ type: Input }],
    value: [{ type: Input }],
    defaultValue: [{ type: Input }],
    disabled: [{ type: Input }],
    marks: [{ type: Input }],
    dots: [{ type: Input }],
    included: [{ type: Input }],
    count: [{ type: Input }],
    allowCross: [{ type: Input }],
    pushable: [{ type: Input }],
    handleStyle: [{ type: Input }],
    trackStyle: [{ type: Input }],
    railStyle: [{ type: Input }],
    onChange: [{ type: Output }],
    onAfterChange: [{ type: Output }],
    amWrapper: [{ type: HostBinding, args: ['class.am-slider-wrapper',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SliderComponent {
    /**
     * @param {?} _elf
     */
    constructor(_elf) {
        this._elf = _elf;
        this.prefixCls = 'am-slider';
        this.offset = 0;
        this.length = 0;
        this._min = 0;
        this._max = 100;
        this._step = 1;
        this._defaultValue = 0;
        this._disabled = false;
        this._marks = {};
        this._dots = false;
        this._included = true;
        this._trackStyle = {};
        this.onAfterChange = new EventEmitter();
        this.onChange = new EventEmitter();
        this.amSliderWrapper = true;
        this._ngModelOnChange = (/**
         * @return {?}
         */
        () => { });
        this._ngModelOnTouched = (/**
         * @return {?}
         */
        () => { });
    }
    /**
     * @return {?}
     */
    get min() {
        return this._min;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set min(value) {
        this._min = value;
    }
    /**
     * @return {?}
     */
    get max() {
        return this._max;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set max(value) {
        this._max = value;
    }
    /**
     * @return {?}
     */
    get step() {
        return this._step;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set step(value) {
        this._step = value;
    }
    /**
     * @return {?}
     */
    get value() {
        return this._value;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set value(value) {
        this.setValue(value);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set defaultValue(value) {
        this._defaultValue = value;
        this.setValue(value);
    }
    /**
     * @return {?}
     */
    get disabled() {
        return this._disabled;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set disabled(value) {
        this._disabled = value;
        this.setCls();
    }
    /**
     * @return {?}
     */
    get marks() {
        return this._marks;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set marks(value) {
        this._marks = value;
    }
    /**
     * @return {?}
     */
    get dots() {
        return this._dots;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set dots(value) {
        this._dots = value;
    }
    /**
     * @return {?}
     */
    get included() {
        return this._included;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set included(value) {
        this._included = value;
    }
    /**
     * @return {?}
     */
    get handleStyle() {
        return this._handleStyle;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set handleStyle(value) {
        this._handleStyle = value;
    }
    /**
     * @return {?}
     */
    get trackStyle() {
        return this._trackStyle;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set trackStyle(value) {
        this._trackStyle = value;
    }
    /**
     * @return {?}
     */
    get railStyle() {
        return this._railStyle;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set railStyle(value) {
        this._railStyle = value;
    }
    /**
     * @return {?}
     */
    setCls() {
        this.sliderCls = {
            [`${this.prefixCls}-disabled`]: this._disabled
        };
    }
    /**
     * @param {?} e
     * @return {?}
     */
    handleChange(e) {
        setTimeout((/**
         * @return {?}
         */
        () => {
            this.setTrack(e);
            this._value = e;
        }), 10);
        this.onChange.emit(e);
        this._ngModelOnChange(e);
    }
    /**
     * @param {?} e
     * @return {?}
     */
    handleAfterChange(e) {
        setTimeout((/**
         * @return {?}
         */
        () => {
            this.setTrack(e);
            this._value = e;
        }), 10);
        this.onAfterChange.emit(e);
    }
    /**
     * @return {?}
     */
    valueRange() {
        if (this._value < this._min) {
            this._value = this._min;
        }
        if (this._value > this._max) {
            this._value = this._max;
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.setCls();
        this.setValue(this._value);
        /** @type {?} */
        const sliderCoords = this._elf.nativeElement.getElementsByClassName('am-slider')[0].getBoundingClientRect();
        this.sliderLength = sliderCoords.width;
        this.sliderStart = sliderCoords.left;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        this.setValue(value, true);
    }
    /**
     * @param {?} value
     * @param {?=} isWriteValue
     * @return {?}
     */
    setValue(value, isWriteValue = false) {
        if (value === 0 || value) {
            this._value = value;
        }
        else {
            this._value = this._defaultValue;
        }
        this.valueRange();
        this.setTrack(this._value);
        if (isWriteValue) {
            this._ngModelOnChange(this._value);
        }
        else {
            this.onAfterChange.emit(this._value);
        }
    }
    /**
     * @param {?} e
     * @return {?}
     */
    setTrack(e) {
        this.offset = 0;
        this.length = ((e - this._min) * 100) / (this._max - this._min);
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this._ngModelOnChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this._ngModelOnTouched = fn;
    }
}
SliderComponent.decorators = [
    { type: Component, args: [{
                selector: 'Slider , nzm-slider',
                template: "<div class=\"am-slider\" [ngClass]=\"sliderCls\">\n  <div class=\"am-slider-rail\" [ngStyle]=\"railStyle\"></div>\n  <SliderTrack [className]=\"'am-slider-track'\"\n               [style]=\"trackStyle\"\n               [offset]=\"offset\"\n               [length]=\"length\"\n               [included]=\"included\"\n  ></SliderTrack>\n  <SliderSteps [max]=\"max\"\n               [min]=\"min\"\n               [dots]=\"dots\"\n               [step]=\"step\"\n               [marks]=\"marks\"\n               [lowerBound]=\"min\"\n               [upperBound]=\"value\"\n               [included]=\"included\"\n  ></SliderSteps>\n  <SliderHandle [max]=\"max\"\n                [min]=\"min\"\n                [value]=\"value\"\n                [step]=\"step\"\n                [disabled]=\"disabled\"\n                [handleStyle]=\"handleStyle\"\n                [sliderStart]=\"sliderStart\"\n                [sliderLength]=\"sliderLength\"\n                (onChange)=\"handleChange($event)\"\n                (onAfterChange)=\"handleAfterChange($event)\"\n  ></SliderHandle>\n  <SliderMarks [max]=\"max\"\n               [min]=\"min\"\n               [marks]=\"marks\"\n               [lowerBound]=\"min\"\n               [upperBound]=\"value\"\n               [included]=\"included\"\n  ></SliderMarks>\n</div>",
                encapsulation: ViewEncapsulation.None,
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => SliderComponent)),
                        multi: true
                    }
                ]
            }] }
];
/** @nocollapse */
SliderComponent.ctorParameters = () => [
    { type: ElementRef }
];
SliderComponent.propDecorators = {
    min: [{ type: Input }],
    max: [{ type: Input }],
    step: [{ type: Input }],
    value: [{ type: Input }],
    defaultValue: [{ type: Input }],
    disabled: [{ type: Input }],
    marks: [{ type: Input }],
    dots: [{ type: Input }],
    included: [{ type: Input }],
    handleStyle: [{ type: Input }],
    trackStyle: [{ type: Input }],
    railStyle: [{ type: Input }],
    onAfterChange: [{ type: Output }],
    onChange: [{ type: Output }],
    amSliderWrapper: [{ type: HostBinding, args: ['class.am-slider-wrapper',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SliderHandleComponent {
    /**
     * @param {?} _elf
     * @param {?} _sanitizer
     */
    constructor(_elf, _sanitizer) {
        this._elf = _elf;
        this._sanitizer = _sanitizer;
        this._disabled = false;
        this._marks = {};
        this._isDraging = false;
        this.onChange = new EventEmitter();
        this.onAfterChange = new EventEmitter();
        this.mouseDown = (/**
         * @param {?} event
         * @return {?}
         */
        event => {
            if (!this._disabled && this.isMouseTarget(event)) {
                this._startX = event.clientX;
                this._handleStatus = 'start';
                this._isDraging = true;
                document.addEventListener('mousemove', this.mouseMove, false);
                document.addEventListener('mouseup', this.mouseUp, false);
                this.pauseEvent(event);
            }
        });
        this.mouseMove = (/**
         * @param {?} event
         * @return {?}
         */
        event => {
            if (!this._disabled && this._isDraging) {
                this.pauseEvent(event);
                /** @type {?} */
                const pos = event.clientX;
                this._value = Math.round(this.calcValueByPos(pos));
                this.left = this.calcOffset(this._value);
                if (this._oldValue !== this._value) {
                    this._oldValue = this._value;
                    this.onChange.emit(this._value);
                }
            }
        });
        this.mouseUp = (/**
         * @param {?} event
         * @return {?}
         */
        event => {
            if (!this._disabled && this._isDraging) {
                this._handleStatus = 'end';
                this._isDraging = false;
                /** @type {?} */
                const pos = event.clientX;
                this._value = Math.round(this.calcValueByPos(pos));
                this.left = this.calcOffset(this._value);
                this.onAfterChange.emit(this._value);
            }
        });
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set min(value) {
        this._min = value;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set max(value) {
        this._max = value;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set minBound(value) {
        this._minBound = value;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set maxBound(value) {
        this._maxBound = value;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set step(value) {
        this._step = value;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set value(value) {
        this._value = value;
        if (this._value) {
            this.left = this.calcOffset(this._value);
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set disabled(value) {
        this._disabled = value;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set sliderLength(value) {
        this._sliderLength = value;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set sliderStart(value) {
        this._sliderStart = value;
    }
    /**
     * @return {?}
     */
    get handleStyle() {
        return this._handleStyle;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set handleStyle(value) {
        this._handleStyle = value;
    }
    /* 手势操作 */
    /**
     * @param {?} event
     * @return {?}
     */
    panstart(event) {
        // event.preventDefault();
        if (!this._disabled) {
            this._startX = event && event.changedTouches && event.changedTouches[0] && event.changedTouches[0].clientX;
            this._handleStatus = 'start';
            this._isDraging = true;
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    panmove(event) {
        event.preventDefault();
        if (!this._disabled && this._isDraging) {
            /** @type {?} */
            const pos = event.changedTouches[0].clientX;
            this._value = Math.round(this.calcValueByPos(pos));
            this.left = this.calcOffset(this._value);
            if (this._oldValue !== this._value) {
                this._oldValue = this._value;
                this.onChange.emit(this._value);
            }
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    panend(event) {
        event.preventDefault();
        if (!this._disabled && this._isDraging) {
            this._handleStatus = 'end';
            this._isDraging = false;
            /** @type {?} */
            const pos = event.changedTouches[0].clientX;
            this._value = Math.round(this.calcValueByPos(pos));
            this.left = this.calcOffset(this._value);
            this.onAfterChange.emit(this._value);
        }
    }
    /**
     * @param {?} pos
     * @return {?}
     */
    calcValueByPos(pos) {
        /** @type {?} */
        const offset = pos - this._sliderStart;
        /** @type {?} */
        let value = this.calcValue(offset);
        if (value <= this._minBound) {
            value = this._minBound;
        }
        if (value >= this._maxBound) {
            value = this._maxBound;
        }
        /** @type {?} */
        const closestPoint = this.getClosestPoint(value);
        return this._step === null ? closestPoint : parseFloat(closestPoint.toFixed(this.getPrecision(this._step)));
    }
    /**
     * @param {?} offset
     * @return {?}
     */
    calcValue(offset) {
        /** @type {?} */
        const ratio = Math.abs(Math.max(offset, 0) / this._sliderLength);
        /** @type {?} */
        const value = ratio * (this._max - this._min) + this._min;
        return value;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    getClosestPoint(val) {
        /** @type {?} */
        const points = Object.keys(this._marks).map(parseFloat);
        if (this._step !== null) {
            /** @type {?} */
            const closestStep = Math.round((val - this._min) / this._step) * this._step + this._min;
            points.push(closestStep);
        }
        /** @type {?} */
        const diffs = points.map((/**
         * @param {?} point
         * @return {?}
         */
        function (point) {
            return Math.abs(val - point);
        }));
        return points[diffs.indexOf(Math.min.apply(Math, this.toConsumableArray(diffs)))];
    }
    /**
     * @param {?} step
     * @return {?}
     */
    getPrecision(step) {
        /** @type {?} */
        const stepString = step.toString();
        /** @type {?} */
        let precision = 0;
        if (stepString.indexOf('.') >= 0) {
            precision = stepString.length - stepString.indexOf('.') - 1;
        }
        return precision;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    calcOffset(value) {
        /** @type {?} */
        const ratio = (value - this._min) / (this._max - this._min);
        return ratio * 100;
    }
    /**
     * @param {?} e
     * @return {?}
     */
    pauseEvent(e) {
        e.stopPropagation();
        e.preventDefault();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    isMouseTarget(event) {
        /** @type {?} */
        let target = event.target;
        /** @type {?} */
        let parentFound = false;
        while (target !== null && !parentFound) {
            if (target === this._elf.nativeElement) {
                parentFound = true;
            }
            target = target.parentElement;
        }
        return parentFound;
    }
    /**
     * @param {?} arr
     * @return {?}
     */
    toConsumableArray(arr) {
        if (Array.isArray(arr)) {
            /** @type {?} */
            const arr2 = Array(arr.length);
            for (let i = 0; i < arr.length; i++) {
                arr2[i] = arr[i];
            }
            return arr2;
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this._elf.nativeElement.addEventListener('mousedown', this.mouseDown, false);
        this._handleOffsetX = this._elf.nativeElement.getBoundingClientRect().x;
        this.left = this.calcOffset(this._value);
        this._minBound = this._minBound === undefined ? this._min : this._minBound;
        this._maxBound = this._maxBound === undefined ? this._max : this._maxBound;
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        document.removeEventListener('mousemove', this.mouseMove, false);
        document.removeEventListener('mouseup', this.mouseUp, false);
    }
}
SliderHandleComponent.decorators = [
    { type: Component, args: [{
                selector: 'SliderHandle, nzm-slider-handle',
                template: "<div role=\"slider\"\n     class=\"am-slider-handle\"\n     [ngStyle]=\"handleStyle\"\n     [style.left.%]=\"left\">\n</div>",
                encapsulation: ViewEncapsulation.None
            }] }
];
/** @nocollapse */
SliderHandleComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: DomSanitizer }
];
SliderHandleComponent.propDecorators = {
    min: [{ type: Input }],
    max: [{ type: Input }],
    minBound: [{ type: Input }],
    maxBound: [{ type: Input }],
    step: [{ type: Input }],
    value: [{ type: Input }],
    disabled: [{ type: Input }],
    sliderLength: [{ type: Input }],
    sliderStart: [{ type: Input }],
    handleStyle: [{ type: Input }],
    onChange: [{ type: Output }],
    onAfterChange: [{ type: Output }],
    panstart: [{ type: HostListener, args: ['touchstart', ['$event'],] }],
    panmove: [{ type: HostListener, args: ['touchmove', ['$event'],] }],
    panend: [{ type: HostListener, args: ['touchend', ['$event'],] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SliderMarksComponent {
    /**
     * @param {?} _elf
     */
    constructor(_elf) {
        this._elf = _elf;
        this.markArray = [];
        this._min = 0;
        this._max = 100;
        this._marks = {};
        this._included = true;
        this._className = 'am-slider-mark';
        this.onChange = new EventEmitter();
        this.onAfterChange = new EventEmitter();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set min(value) {
        if (value && value <= this._max) {
            this._min = value;
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set max(value) {
        if (value && value >= this._min) {
            this._max = value;
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set marks(value) {
        this._marks = value;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set included(value) {
        this._included = value;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set upperBound(value) {
        if (value && value !== this._upperBound) {
            this._upperBound = value;
            this.setActiveCls();
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set lowerBound(value) {
        if (value && value !== this.lowerBound) {
            this._lowerBound = value;
            this.setActiveCls();
        }
    }
    /**
     * @return {?}
     */
    get class() {
        return this._className;
    }
    /**
     * @param {?} marksKeys
     * @return {?}
     */
    getMarks(marksKeys) {
        this.markArray = [];
        marksKeys
            .map(parseFloat)
            .sort((/**
         * @param {?} a
         * @param {?} b
         * @return {?}
         */
        (a, b) => a - b))
            .map((/**
         * @param {?} point
         * @return {?}
         */
        point => {
            /** @type {?} */
            const markItem = {
                markLabel: '',
                point: '',
                className: {},
                style: {}
            };
            /** @type {?} */
            const markPoint = this._marks[point];
            /** @type {?} */
            const markPointIsObject = typeof markPoint === 'object';
            /** @type {?} */
            const markLabel = markPointIsObject ? markPoint.label : markPoint;
            if (!markLabel && markLabel !== 0) {
                return null;
            }
            /** @type {?} */
            const isActive = (!this._included && point === this._upperBound) ||
                (this._included && point <= this._upperBound && point >= this._lowerBound);
            /** @type {?} */
            const markClassName = {
                [`${this._className}-text`]: true,
                [`${this._className}-text-active`]: isActive
            };
            /** @type {?} */
            const bottomStyle = {
                marginBottom: '-50%',
                bottom: `${((point - this._min) / this._range) * 100}%`
            };
            /** @type {?} */
            const leftStyle = {
                width: `${this._markWidth}%`,
                marginLeft: `${-this._markWidth / 2}%`,
                left: `${((point - this._min) / this._range) * 100}%`
            };
            /** @type {?} */
            const style = leftStyle;
            /** @type {?} */
            const markStyle = markPointIsObject ? Object.assign({}, style, markPoint.style) : style;
            markItem.markLabel = markLabel;
            markItem.point = point;
            markItem.className = Object.keys(markClassName).join(' ');
            markItem.style = markStyle;
            this.markArray.push(markItem);
        }));
    }
    /**
     * @return {?}
     */
    setActiveCls() {
        for (let i = 0; i < this.markArray.length; i++) {
            /** @type {?} */
            const point = this.markArray[i].point;
            /** @type {?} */
            const isActive = (!this._included && point === this._upperBound) ||
                (this._included && point <= this._upperBound && point >= this._lowerBound);
            this.markArray[i].className = {
                [`${this._className}-text`]: true,
                [`${this._className}-text-active`]: isActive
            };
        }
    }
    /**
     * @return {?}
     */
    setMarksLable() {
        for (let i = 0; i < this.markArray.length; i++) {
            /** @type {?} */
            const markEle = this._elf.nativeElement.getElementsByClassName(this._className + '-text')[i];
            markEle.innerHTML = this.markArray[i].markLabel;
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        /** @type {?} */
        const marksKeys = Object.keys(this._marks);
        /** @type {?} */
        const marksCount = marksKeys.length;
        /** @type {?} */
        const unit = marksCount > 1 ? 100 / (marksCount - 1) : 100;
        this._markWidth = unit * 0.9;
        this._range = this._max - this._min;
        this.getMarks(marksKeys);
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.setMarksLable();
    }
}
SliderMarksComponent.decorators = [
    { type: Component, args: [{
                selector: 'SliderMarks, nzm-slider-marks',
                template: "<span *ngFor=\"let item of markArray\"\n      [ngClass]=\"item.className\"\n      [ngStyle]=\"item.style\">\n</span>",
                encapsulation: ViewEncapsulation.None
            }] }
];
/** @nocollapse */
SliderMarksComponent.ctorParameters = () => [
    { type: ElementRef }
];
SliderMarksComponent.propDecorators = {
    min: [{ type: Input }],
    max: [{ type: Input }],
    marks: [{ type: Input }],
    included: [{ type: Input }],
    upperBound: [{ type: Input }],
    lowerBound: [{ type: Input }],
    onChange: [{ type: Output }],
    onAfterChange: [{ type: Output }],
    class: [{ type: HostBinding }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SliderStepsComponent {
    /**
     * @param {?} _elf
     */
    constructor(_elf) {
        this._elf = _elf;
        this.prefixCls = 'am-slider';
        this.stepArray = [];
        this._min = 0;
        this._max = 100;
        this._marks = {};
        this._included = true;
        this._dots = false;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set min(value) {
        if (value && value <= this._max) {
            this._min = value;
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set max(value) {
        if (value && value >= this._min) {
            this._max = value;
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set marks(value) {
        this._marks = value;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set step(value) {
        this._step = value;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set included(value) {
        this._included = value;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set dots(value) {
        this._dots = value;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set upperBound(value) {
        if (value !== undefined && value !== this._upperBound) {
            this._upperBound = value;
            this.setActiveCls();
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set lowerBound(value) {
        if (value !== undefined && value !== this.lowerBound) {
            this._lowerBound = value;
            this.setActiveCls();
        }
    }
    /**
     * @return {?}
     */
    get class() {
        return 'am-slider-step';
    }
    /**
     * @return {?}
     */
    calPoints() {
        /** @type {?} */
        const points = Object.keys(this._marks).map(parseFloat);
        if (this._dots) {
            for (let i = this._min; i <= this._max; i = i + this._step) {
                if (points.indexOf(i) < 0) {
                    points.push(i);
                }
            }
        }
        return points;
    }
    /**
     * @param {?} points
     * @return {?}
     */
    getSteps(points) {
        /** @type {?} */
        const range = this._max - this._min;
        this.stepArray = [];
        points.map((/**
         * @param {?} point
         * @return {?}
         */
        point => {
            /** @type {?} */
            const stepItem = {
                stepStyle: {},
                stepClass: {},
                point: null
            };
            /** @type {?} */
            const offset = `${(Math.abs(point - this._min) / range) * 100}%`;
            /** @type {?} */
            const isActived = (!this._included && point === this._upperBound) ||
                (this._included && point <= this._upperBound && point >= this._lowerBound);
            /** @type {?} */
            let style = Object.assign({ left: offset }, this._dotStyle);
            if (isActived) {
                style = Object.assign({}, style, this._activeDotStyle);
            }
            /** @type {?} */
            const pointClassName = {
                [`${this.prefixCls}-dot`]: true,
                [`${this.prefixCls}-dot-active`]: isActived
            };
            stepItem.point = point;
            stepItem.stepStyle = style;
            stepItem.stepClass = pointClassName;
            this.stepArray.push(stepItem);
        }));
    }
    /**
     * @return {?}
     */
    setActiveCls() {
        for (let i = 0; i < this.stepArray.length; i++) {
            /** @type {?} */
            const point = this.stepArray[i].point;
            /** @type {?} */
            const isActived = (!this._included && point === this._upperBound) ||
                (this._included && point <= this._upperBound && point >= this._lowerBound);
            this.stepArray[i].stepClass = {
                [`${this.prefixCls}-dot`]: true,
                [`${this.prefixCls}-dot-active`]: isActived
            };
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        /** @type {?} */
        const points = this.calPoints();
        this.getSteps(points);
    }
}
SliderStepsComponent.decorators = [
    { type: Component, args: [{
                selector: 'SliderSteps, nzm-slider-steps',
                template: "<span *ngFor=\"let item of stepArray\"\n      [ngClass]=\"item.stepClass\"\n      [ngStyle]=\"item.stepStyle\">\n</span>",
                encapsulation: ViewEncapsulation.None
            }] }
];
/** @nocollapse */
SliderStepsComponent.ctorParameters = () => [
    { type: ElementRef }
];
SliderStepsComponent.propDecorators = {
    min: [{ type: Input }],
    max: [{ type: Input }],
    marks: [{ type: Input }],
    step: [{ type: Input }],
    included: [{ type: Input }],
    dots: [{ type: Input }],
    upperBound: [{ type: Input }],
    lowerBound: [{ type: Input }],
    class: [{ type: HostBinding }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SliderTrackComponent {
    /**
     * @param {?} _elf
     * @param {?} _sanitizer
     */
    constructor(_elf, _sanitizer) {
        this._elf = _elf;
        this._sanitizer = _sanitizer;
        this.prefixCls = 'am-slider';
        this._included = true;
    }
    /**
     * @return {?}
     */
    get className() {
        return this._className;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set className(value) {
        this._className = value;
    }
    /**
     * @return {?}
     */
    get included() {
        return this._included;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set included(value) {
        this._included = value;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set offset(value) {
        this._offset = value;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set length(value) {
        this._length = value;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set style(value) {
        this._style = value;
    }
    /**
     * @return {?}
     */
    ngOnChanges() {
        /** @type {?} */
        const positonStyle = {
            left: `${this._offset}%`,
            width: `${this._length}%`
        };
        this.elStyle = Object.assign({}, this._style, positonStyle);
    }
}
SliderTrackComponent.decorators = [
    { type: Component, args: [{
                selector: 'SliderTrack, nzm-slider-track',
                template: "<div *ngIf=\"included\" \n     [ngClass]=\"className\" \n     [ngStyle]=\"elStyle\" >\n</div>",
                encapsulation: ViewEncapsulation.None
            }] }
];
/** @nocollapse */
SliderTrackComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: DomSanitizer }
];
SliderTrackComponent.propDecorators = {
    className: [{ type: Input }],
    included: [{ type: Input }],
    offset: [{ type: Input }],
    length: [{ type: Input }],
    style: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SliderModule {
}
SliderModule.decorators = [
    { type: NgModule, args: [{
                exports: [
                    SliderComponent,
                    SliderHandleComponent,
                    SliderMarksComponent,
                    SliderStepsComponent,
                    SliderTrackComponent
                ],
                declarations: [
                    SliderComponent,
                    SliderHandleComponent,
                    SliderMarksComponent,
                    SliderStepsComponent,
                    SliderTrackComponent
                ],
                imports: [CommonModule]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class RangeModule {
}
RangeModule.decorators = [
    { type: NgModule, args: [{
                exports: [RangeComponent],
                declarations: [RangeComponent],
                imports: [CommonModule, SliderModule]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PaginationComponent {
    /**
     * @param {?} _localeProviderService
     */
    constructor(_localeProviderService) {
        this._localeProviderService = _localeProviderService;
        this.prefixCls = 'am-pagination';
        this._locale = {
            prevText: '',
            nextText: ''
        };
        this._unsubscribe$ = new Subject();
        this.mode = 'button';
        this.current = 1;
        this.total = 0;
        this.simple = false;
        this.disabled = false;
        this.onChange = new EventEmitter();
    }
    /**
     * @return {?}
     */
    get locale() {
        return this._locale;
    }
    /**
     * @param {?} v
     * @return {?}
     */
    set locale(v) {
        this._locale = v;
        this._unsubscribe$.next();
        this._unsubscribe$.complete();
    }
    /**
     * @param {?} key
     * @return {?}
     */
    isTemplateRef(key) {
        return (/** @type {?} */ (key)) instanceof TemplateRef;
    }
    /**
     * @param {?} p
     * @return {?}
     */
    onClick(p) {
        this.current = p;
        this.onChange.emit(p);
    }
    /**
     * @param {?} p
     * @return {?}
     */
    getNumber(p) {
        return new Array(p);
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this._localeProviderService.localeChange.pipe(takeUntil(this._unsubscribe$)).subscribe((/**
         * @param {?} _
         * @return {?}
         */
        _ => {
            this._locale = (/** @type {?} */ (this._localeProviderService.getLocaleSubObj('Pagination')));
        }));
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._unsubscribe$.next();
        this._unsubscribe$.complete();
    }
}
PaginationComponent.decorators = [
    { type: Component, args: [{
                selector: 'Pagination, nzm-pagination',
                template: "<div class=\"{{prefixCls}} {{prefixCls}}-align-center\">\n  <Flex *ngIf=\"mode === 'button'\">\n    <FlexItem class=\"{{prefixCls}}-wrap-btn {{prefixCls}}-wrap-btn-prev\">\n      <a Button [inline]=\"true\" [disabled]=\"current <= 1\" (onClick)=\"onClick(current - 1)\">\n        <ng-container *ngIf=\"!isTemplateRef(locale.prevText)\">\n          {{locale.prevText}}\n        </ng-container>\n        <ng-template *ngIf=\"isTemplateRef(locale.prevText)\" [ngTemplateOutlet]=\"locale.prevText\"></ng-template>\n      </a>\n    </FlexItem>\n    <FlexItem class=\"{{prefixCls}}-wrap\" aria-live=\"assertive\" *ngIf=\"!simple\">\n      <span class=\"active\">{{current}}</span>/\n      <span>{{total}}</span>\n    </FlexItem>\n    <FlexItem class=\"{{prefixCls}}-wrap-btn {{prefixCls}}-wrap-btn-next\">\n      <a Button [inline]=\"true\" [disabled]=\"current>= total\" (onClick)=\"onClick(current + 1)\">\n        <ng-container *ngIf=\"!isTemplateRef(locale.nextText)\">\n          {{locale.nextText}}\n        </ng-container>\n        <ng-template *ngIf=\"isTemplateRef(locale.nextText)\" [ngTemplateOutlet]=\"locale.nextText\"></ng-template>\n      </a>\n    </FlexItem>\n  </Flex>\n\n  <div class=\"{{prefixCls}}-wrap\" *ngIf=\"mode === 'number'\">\n    <span class=\"active\">{{current}}</span>/<span>{{total}}</span>\n  </div>\n\n  <div class=\"{{prefixCls}}-wrap\" *ngIf=\"mode === 'pointer'\">\n    <div *ngFor=\"let number of getNumber(total); let i = index\" class=\"{{prefixCls}}-wrap-dot {{current === i+1 ? (prefixCls + '-wrap-dot-active') : ''}}\">\n      <span></span>\n    </div>\n  </div>\n</div>\n",
                encapsulation: ViewEncapsulation.None
            }] }
];
/** @nocollapse */
PaginationComponent.ctorParameters = () => [
    { type: LocaleProviderService }
];
PaginationComponent.propDecorators = {
    mode: [{ type: Input }],
    current: [{ type: Input }],
    total: [{ type: Input }],
    simple: [{ type: Input }],
    disabled: [{ type: Input }],
    locale: [{ type: Input }],
    onChange: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PaginationModule {
}
PaginationModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, ButtonModule, FlexModule, IconModule, LocaleProviderModule],
                declarations: [PaginationComponent],
                exports: [PaginationComponent],
                providers: [LocaleProviderModule]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TagComponent {
    constructor() {
        this.prefixCls = 'am-tag';
        this.closed = false;
        this.wrapCls = {};
        this._small = false;
        this._closable = false;
        this._selected = false;
        this._disabled = false;
        this.onChange = new EventEmitter();
        this.onClose = new EventEmitter();
        this.afterClose = new EventEmitter();
    }
    /**
     * @return {?}
     */
    get small() {
        return this._small;
    }
    /**
     * @param {?} v
     * @return {?}
     */
    set small(v) {
        this._small = v;
        this.setClassMap();
    }
    /**
     * @return {?}
     */
    get closable() {
        return this._closable;
    }
    /**
     * @param {?} v
     * @return {?}
     */
    set closable(v) {
        this._closable = v;
        this.setClassMap();
    }
    /**
     * @param {?} v
     * @return {?}
     */
    set selected(v) {
        this._selected = v;
        this.setClassMap();
    }
    /**
     * @return {?}
     */
    get disabled() {
        return this._disabled;
    }
    /**
     * @param {?} v
     * @return {?}
     */
    set disabled(v) {
        this._disabled = v;
        this.setClassMap();
    }
    /**
     * @return {?}
     */
    onClick() {
        if (this._disabled) {
            return;
        }
        this._selected = !this._selected;
        this.onChange.emit(this._selected);
        this.setClassMap();
    }
    /**
     * @return {?}
     */
    onTagClose() {
        this.onClose.emit();
        this.closed = true;
        this.afterClose.emit();
    }
    /**
     * @return {?}
     */
    setClassMap() {
        this.wrapCls = {
            [this.prefixCls]: true,
            [`${this.prefixCls}-normal`]: !this._disabled && (!this._selected || this._small || this._closable),
            [`${this.prefixCls}-small`]: this._small,
            [`${this.prefixCls}-active`]: this._selected && !this._disabled && !this._small && !this._closable,
            [`${this.prefixCls}-disabled`]: this._disabled,
            [`${this.prefixCls}-closable`]: this._closable
        };
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.setClassMap();
    }
}
TagComponent.decorators = [
    { type: Component, args: [{
                selector: 'Tag, nzm-tag',
                template: "<div *ngIf=\"!closed\" [ngClass]=\"wrapCls\" (click)=\"onClick()\">\n  <div class=\"{{prefixCls}}-text\">\n    <ng-content></ng-content>\n  </div>\n  <div *ngIf=\"closable && !disabled && !small\"\n       role=\"button\"\n       class=\"{{prefixCls}}-close\"\n       aria-label=\"remove tag\"\n       (click)=\"onTagClose()\">\n    <Icon aria-hidden=\"true\" [type]=\"'cross-circle'\" [size]=\"'xs'\"></Icon>\n  </div>\n</div>\n",
                encapsulation: ViewEncapsulation.None
            }] }
];
/** @nocollapse */
TagComponent.ctorParameters = () => [];
TagComponent.propDecorators = {
    small: [{ type: Input }],
    closable: [{ type: Input }],
    selected: [{ type: Input }],
    disabled: [{ type: Input }],
    onChange: [{ type: Output }],
    onClose: [{ type: Output }],
    afterClose: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TagModule {
}
TagModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, IconModule],
                declarations: [TagComponent],
                exports: [TagComponent]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class MenuComponent {
    /**
     * @param {?} _localeProviderService
     */
    constructor(_localeProviderService) {
        this._localeProviderService = _localeProviderService;
        this.prefixCls = 'am-menu';
        this.subMenuPrefixCls = 'am-sub-menu';
        this.radioPrefixCls = 'am-radio';
        this.multiSelectMenuBtnsCls = 'am-multi-select-btns';
        this.menuSelectContanerPrefixCls = 'am-menu-select-container';
        this.locale = {
            okText: '',
            cancelText: ''
        };
        this._data = [];
        this._unsubscribe$ = new Subject();
        this.level = 2;
        this.value = [];
        this.height = document.documentElement.clientHeight / 2;
        this.multiSelect = false;
        this.onChange = new EventEmitter();
        this.onOk = new EventEmitter();
        this.onCancel = new EventEmitter();
    }
    /**
     * @return {?}
     */
    get data() {
        return this._data;
    }
    /**
     * @param {?} v
     * @return {?}
     */
    set data(v) {
        this._data = v;
        this.initData();
    }
    /**
     * @return {?}
     */
    onMenuOk() {
        this.onOk.emit(this.value);
    }
    /**
     * @return {?}
     */
    onMenuCancel() {
        this.onCancel.emit();
    }
    /**
     * @return {?}
     */
    getNewFsv() {
        /** @type {?} */
        let firstValue = '';
        if (this.value && this.value.length) {
            firstValue = (/** @type {?} */ (this.value[0]));
        }
        else if (this._data && this._data.length && !this._data[0].isLeaf) {
            firstValue = this._data[0].value;
        }
        return firstValue;
    }
    /**
     * @param {?} dataItem
     * @return {?}
     */
    onClickFirstLevelItem(dataItem) {
        this.firstLevelSelectValue = dataItem.value;
        if (dataItem.isLeaf && this.onChange) {
            this.onChange.emit([dataItem.value]);
        }
        this.initData();
    }
    /**
     * @param {?} dataItem
     * @return {?}
     */
    onClickSubMenuItem(dataItem) {
        this.value = this.getSelectValue(dataItem);
        this.initData();
        setTimeout((/**
         * @return {?}
         */
        () => {
            this.onChange.emit(this.value);
        }), 300);
    }
    /**
     * @param {?} dataItem
     * @return {?}
     */
    getSelectValue(dataItem) {
        if (this.multiSelect) {
            if (this.value && this.value.length > 0) {
                if (this.level === 2 && this.value[0] !== this.firstLevelSelectValue) {
                    return [this.firstLevelSelectValue, [dataItem.value]];
                }
                else {
                    if (this.level == 1) {
                        /** @type {?} */
                        const chosenValues = Array.from(this.value);
                        /** @type {?} */
                        const existIndex = chosenValues.indexOf(dataItem.value);
                        if (existIndex === -1) {
                            chosenValues.push(dataItem.value);
                        }
                        else {
                            chosenValues.splice(existIndex, 1);
                        }
                        return chosenValues;
                    }
                    else {
                        /** @type {?} */
                        const chosenValues = Array.from(this.value[1]);
                        /** @type {?} */
                        const existIndex = chosenValues.indexOf(dataItem.value);
                        if (existIndex === -1) {
                            chosenValues.push(dataItem.value);
                        }
                        else {
                            chosenValues.splice(existIndex, 1);
                        }
                        return [this.firstLevelSelectValue, chosenValues];
                    }
                }
            }
            else {
                return this.level === 2 ? [this.firstLevelSelectValue, [dataItem.value]] : [dataItem.value];
            }
        }
        return this.level === 2 ? [this.firstLevelSelectValue, dataItem.value] : [dataItem.value];
    }
    /**
     * @return {?}
     */
    initData() {
        this.subMenuData = this._data;
        if (this.level === 2) {
            /** @type {?} */
            let parent = this._data;
            if (this.firstLevelSelectValue && this.firstLevelSelectValue !== '') {
                parent = this._data.filter((/**
                 * @param {?} dataItem
                 * @return {?}
                 */
                dataItem => dataItem.value === this.firstLevelSelectValue));
            }
            if (parent[0] && parent[0].children && parent[0].isLeaf !== true) {
                this.subMenuData = parent[0].children;
            }
            else {
                this.subMenuData = [];
            }
        }
        /** @type {?} */
        let subValue = (this.value && this.value.length > 0 && [...this.value]) || [];
        if (this.level === 2 && subValue.length > 1) {
            subValue.shift();
            if (this.multiSelect) {
                subValue = (/** @type {?} */ (subValue[0]));
            }
        }
        this.subSelInitItem = this.subMenuData.filter((/**
         * @param {?} dataItem
         * @return {?}
         */
        dataItem => subValue.indexOf(dataItem.value) !== -1)).map((/**
         * @param {?} item
         * @return {?}
         */
        item => {
            return item.value;
        }));
        /** @type {?} */
        const parentValue = this.value && this.value.length > 1 && this.level === 2 ? this.value[0] : null;
        this.showSelect = true;
        if (this.level === 2 && parentValue !== this.firstLevelSelectValue) {
            this.showSelect = false;
        }
    }
    /**
     * @param {?} dataItem
     * @return {?}
     */
    getClass(dataItem) {
        return this.dataItemSelected(dataItem) ? this.prefixCls + '-selected' : '';
    }
    /**
     * @param {?} dataItem
     * @return {?}
     */
    dataItemSelected(dataItem) {
        return dataItem.value === this.firstLevelSelectValue;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this._localeProviderService.localeChange.pipe(takeUntil(this._unsubscribe$)).subscribe((/**
         * @param {?} _
         * @return {?}
         */
        _ => {
            this.locale = (/** @type {?} */ (this._localeProviderService.getLocaleSubObj('Menu')));
        }));
        this.firstLevelSelectValue = this.getNewFsv();
        this.heightStyle = {
            height: this.height + 'px'
        };
        this.initData();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._unsubscribe$.next();
        this._unsubscribe$.complete();
    }
}
MenuComponent.decorators = [
    { type: Component, args: [{
                selector: 'Menu, nzm-menu',
                template: "<Flex class=\"{{prefixCls}}\"\n      [ngStyle]=\"heightStyle\"\n      [direction]=\"'column'\"\n      [align]=\"'stretch'\"\n>\n  <Flex class=\"{{menuSelectContanerPrefixCls}}\" [align]=\"'start'\">\n    <FlexItem *ngIf=\"level == 2\">\n      <List role=\"tablist\">\n        <ListItem role=\"tab\"\n                  *ngFor=\"let dataItem of data, let i = index\"\n                  [className]=\"getClass(dataItem)\"\n                  (click)=\"onClickFirstLevelItem(dataItem)\"\n        >\n          {{dataItem.label}}\n        </ListItem>\n      </List>\n    </FlexItem>\n\n    <FlexItem role=\"tabpanel\" aria-hidden=\"false\" class=\"{{menuSelectContanerPrefixCls}}-submenu\">\n      <SubMenu [subMenuPrefixCls]=\"subMenuPrefixCls\"\n               [radioPrefixCls]=\"radioPrefixCls\"\n               [subMenuData]=\"subMenuData\"\n               [selItem]=\"subSelInitItem\"\n               [showSelect]=\"showSelect\"\n               [multiSelect]=\"multiSelect\"\n               (onSel)=\"onClickSubMenuItem($event)\">\n      </SubMenu>\n    </FlexItem>\n  </Flex>\n\n  <div *ngIf=\"multiSelect\" class=\"{{multiSelectMenuBtnsCls}}\">\n    <a Button\n       [className]=\"'am-multi-select-btns-btn'\"\n       [inline]=\"true\"\n       (onClick)=\"onMenuCancel()\"\n    >\n      {{locale.cancelText}}\n    </a>\n    <a Button\n       [className]=\"'am-multi-select-btns-btn'\"\n       [inline]=\"true\" [type]=\"'primary'\"\n       (onClick)=\"onMenuOk()\"\n    >\n      {{locale.okText}}\n    </a>\n  </div>\n</Flex>\n",
                encapsulation: ViewEncapsulation.None
            }] }
];
/** @nocollapse */
MenuComponent.ctorParameters = () => [
    { type: LocaleProviderService }
];
MenuComponent.propDecorators = {
    data: [{ type: Input }],
    level: [{ type: Input }],
    value: [{ type: Input }],
    height: [{ type: Input }],
    multiSelect: [{ type: Input }],
    onChange: [{ type: Output }],
    onOk: [{ type: Output }],
    onCancel: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SubMenuComponent {
    constructor() {
        this.prefixCls = 'am-sub-menu';
        this.onSel = new EventEmitter();
    }
    /**
     * @return {?}
     */
    get subMenuPrefixCls() {
        return this._subMenuPrefixCls;
    }
    /**
     * @param {?} v
     * @return {?}
     */
    set subMenuPrefixCls(v) {
        this._subMenuPrefixCls = v;
    }
    /**
     * @return {?}
     */
    get subMenuData() {
        return this._subMenuData;
    }
    /**
     * @param {?} v
     * @return {?}
     */
    set subMenuData(v) {
        this._subMenuData = v;
    }
    /**
     * @return {?}
     */
    get multiSelect() {
        return this._multiSelect;
    }
    /**
     * @param {?} v
     * @return {?}
     */
    set multiSelect(v) {
        this._multiSelect = v;
    }
    /**
     * @param {?} dataItem
     * @return {?}
     */
    onClick(dataItem) {
        this.onSel.emit(dataItem);
    }
    /**
     * @param {?} dataItem
     * @return {?}
     */
    selected(dataItem) {
        return this.showSelect && (this.selItem.length > 0 && this.selItem.indexOf(dataItem.value) !== -1);
    }
    /**
     * @param {?} dataItem
     * @return {?}
     */
    getClass(dataItem) {
        /** @type {?} */
        let name = this.radioPrefixCls + '-item ';
        name += this.selected(dataItem) ? this._subMenuPrefixCls + '-item-selected' : '';
        name += dataItem.disabled ? this._subMenuPrefixCls + '-item-disabled' : '';
        return name;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        this._subMenuData.map((/**
         * @param {?} item
         * @return {?}
         */
        item => {
            item.checked = this.selected(item);
        }));
    }
}
SubMenuComponent.decorators = [
    { type: Component, args: [{
                selector: 'SubMenu, nzm-sub-menu',
                template: "<List class=\"{{subMenuPrefixCls}}\" style=\"padding: 0\">\n  <ListItem *ngFor=\"let dataItem of subMenuData; let i = index;\"\n            key=\"i\"\n            [className]=\"getClass(dataItem)\"\n            [extra]=\"extra\"\n  >\n    {{dataItem.label}}\n\n    <ng-template #extra>\n      <label Radio\n             *ngIf=\"!multiSelect\"\n             [checked]=\"dataItem.checked\"\n             [disabled]=\"dataItem.disabled\"\n             (onChange)=\"onClick(dataItem)\"\n      >\n      </label>\n      <label Checkbox\n             *ngIf=\"multiSelect\"\n             [checked]=\"dataItem.checked\"\n             [disabled]=\"dataItem.disabled\"\n             (onChange)=\"onClick(dataItem)\"\n      >\n      </label>\n    </ng-template>\n  </ListItem>\n</List>\n",
                encapsulation: ViewEncapsulation.None
            }] }
];
/** @nocollapse */
SubMenuComponent.ctorParameters = () => [];
SubMenuComponent.propDecorators = {
    onSel: [{ type: Output }],
    radioPrefixCls: [{ type: Input }],
    showSelect: [{ type: Input }],
    selItem: [{ type: Input }],
    subMenuPrefixCls: [{ type: Input }],
    subMenuData: [{ type: Input }],
    multiSelect: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class MenuModule {
}
MenuModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, FlexModule, ListModule, RadioModule, CheckboxModule, ButtonModule, LocaleProviderModule, FormsModule],
                exports: [MenuComponent, SubMenuComponent],
                declarations: [MenuComponent, SubMenuComponent],
                providers: [LocaleProviderModule]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DrawerComponent {
    /**
     * @param {?} _el
     */
    constructor(_el) {
        this._el = _el;
        this.prefixCls = 'am-drawer';
        this.sidebarStyleFinal = {};
        this.contentStyleFinal = {};
        this.overlayStyleFinal = {};
        this.sidebarWidth = 0;
        this.sidebarHeight = 0;
        this.sidebarTop = 0;
        this.dragHandleTop = 0;
        this.touchIdentifier = null;
        this.touchStartX = null;
        this.touchStartY = null;
        this.touchCurrentX = null;
        this.touchCurrentY = null;
        this.touchSupported = typeof window === 'object' && 'ontouchstart' in window;
        this._docked = false;
        this._open = false;
        this._position = 'left';
        this.sidebarStyle = {};
        this.contentStyle = {};
        this.overlayStyle = {};
        this.dragHandleStyle = {};
        this.transitions = true;
        this.touch = true;
        this.enableDragHandle = false;
        this.dragToggleDistance = 30;
        this.onOpenChange = new EventEmitter();
        this.am = true;
        this.left = this._position === 'left';
        this.right = this._position === 'right';
        this.top = this._position == 'top';
        this.bottom = this._position == 'bottom';
        this.dockedCls = this._docked;
        this.openCls = this._open;
    }
    /**
     * @return {?}
     */
    get docked() {
        return this._docked;
    }
    /**
     * @param {?} v
     * @return {?}
     */
    set docked(v) {
        this._docked = v;
        this.dockedCls = v;
    }
    /**
     * @return {?}
     */
    get open() {
        return this._open;
    }
    /**
     * @param {?} v
     * @return {?}
     */
    set open(v) {
        this._open = v;
        this.openCls = v;
    }
    /**
     * @param {?} v
     * @return {?}
     */
    set position(v) {
        this._position = v;
        this.right = false;
        this.left = false;
        this.top = false;
        this.bottom = false;
        switch (v) {
            case 'right':
                this.right = true;
                break;
            case 'left':
                this.left = true;
                break;
            case 'top':
                this.top = true;
                break;
            case 'bottom':
                this.bottom = true;
                break;
        }
    }
    /**
     * @return {?}
     */
    onOverlayClicked() {
        if (this._open) {
            this.onOpenChange.emit(true);
        }
    }
    /**
     * @return {?}
     */
    isTouching() {
        return this.touchIdentifier !== null;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onTouchStart(event) {
        /** @type {?} */
        const touch = event.changedTouches[0];
        this.touchIdentifier = touch.identifier;
        this.touchStartX = touch.clientX;
        this.touchStartY = touch.clientY;
        this.touchCurrentX = touch.clientX;
        this.touchCurrentY = touch.clientY;
    }
    /**
     * @param {?} ev
     * @return {?}
     */
    onTouchMove(ev) {
        for (let ind = 0; ind < ev.changedTouches.length; ind++) {
            if (ev.changedTouches[ind].identifier === this.touchIdentifier) {
                this.touchCurrentX = ev.changedTouches[ind].clientX;
                this.touchCurrentY = ev.changedTouches[ind].clientY;
                break;
            }
        }
        this.update();
    }
    /**
     * @return {?}
     */
    onTouchEnd() {
        /** @type {?} */
        const touchWidth = this.touchSidebarWidth();
        if (!this._open && touchWidth > this.dragToggleDistance) {
            this.onOpenChange.emit(!this._open);
        }
        /** @type {?} */
        const touchHeight = this.touchSidebarHeight();
        if (!this._open && touchHeight > this.dragToggleDistance) {
            this.onOpenChange.emit(!this._open);
        }
        this.touchIdentifier = null;
        this.touchStartX = null;
        this.touchStartY = null;
        this.touchCurrentX = null;
        this.touchCurrentY = null;
        this.update();
    }
    /**
     * @return {?}
     */
    saveSidebarSize() {
        /** @type {?} */
        const sidebar = this._el.nativeElement.querySelector('#sidebar');
        /** @type {?} */
        const dragHandle = this._el.nativeElement.querySelector('#dragHandle');
        /** @type {?} */
        const width = sidebar.offsetWidth;
        /** @type {?} */
        const height = sidebar.offsetHeight;
        /** @type {?} */
        const sidebarTop = this.getOffset(sidebar).top;
        /** @type {?} */
        const dragHandleTop = this.getOffset(dragHandle).top;
        if (width !== this.sidebarWidth) {
            this.sidebarWidth = width;
        }
        if (height !== this.sidebarHeight) {
            this.sidebarHeight = height;
        }
        if (sidebarTop !== this.sidebarTop) {
            this.sidebarTop = sidebarTop;
        }
        if (dragHandleTop !== this.dragHandleTop) {
            this.dragHandleTop = dragHandleTop;
        }
    }
    /**
     * @return {?}
     */
    touchSidebarWidth() {
        if (this._position === 'right') {
            return Math.min(window.innerWidth - this.touchCurrentX, this.sidebarWidth);
        }
        if (this._position === 'left') {
            return Math.min(this.touchCurrentX, this.sidebarWidth);
        }
    }
    /**
     * @return {?}
     */
    touchSidebarHeight() {
        if (this._position === 'bottom') {
            return Math.min(this._el.nativeElement.offsetHeight - this.touchCurrentY + this._el.nativeElement.offsetTop, this.sidebarHeight);
        }
        if (this._position === 'top') {
            return Math.min(this.touchCurrentY - this.dragHandleTop, this.sidebarHeight);
        }
    }
    /**
     * @param {?} __0
     * @return {?}
     */
    renderStyle({ sidebarStyle, isTouching, overlayStyle, contentStyle }) {
        if (this._position === 'right' || this._position === 'left') {
            sidebarStyle.transform = `translateX(0%)`;
            sidebarStyle.WebkitTransform = `translateX(0%)`;
            if (isTouching) {
                /** @type {?} */
                const percentage = this.touchSidebarWidth() / this.sidebarWidth;
                // slide open to what we dragged
                if (this._position === 'right') {
                    sidebarStyle.transform = `translateX(${(1 - percentage) * 100}%)`;
                    sidebarStyle.WebkitTransform = `translateX(${(1 - percentage) * 100}%)`;
                }
                if (this._position === 'left') {
                    sidebarStyle.transform = `translateX(-${(1 - percentage) * 100}%)`;
                    sidebarStyle.WebkitTransform = `translateX(-${(1 - percentage) * 100}%)`;
                }
                overlayStyle.opacity = percentage;
                overlayStyle.visibility = 'visible';
            }
            if (contentStyle) {
                contentStyle[this._position] = `${this.sidebarWidth}px`;
            }
        }
        if (this._position === 'top' || this._position === 'bottom') {
            sidebarStyle.transform = `translateY(0%)`;
            sidebarStyle.WebkitTransform = `translateY(0%)`;
            if (isTouching) {
                /** @type {?} */
                const percentage = this.touchSidebarHeight() / this.sidebarHeight;
                if (this._position === 'bottom') {
                    sidebarStyle.transform = `translateY(${(1 - percentage) * 100}%)`;
                    sidebarStyle.WebkitTransform = `translateY(${(1 - percentage) * 100}%)`;
                }
                if (this._position === 'top') {
                    sidebarStyle.transform = `translateY(-${(1 - percentage) * 100}%)`;
                    sidebarStyle.WebkitTransform = `translateY(-${(1 - percentage) * 100}%)`;
                }
                overlayStyle.opacity = percentage;
                overlayStyle.visibility = 'visible';
            }
            if (contentStyle) {
                contentStyle[this._position] = `${this.sidebarHeight}px`;
            }
        }
    }
    /**
     * @return {?}
     */
    update() {
        /** @type {?} */
        const sidebarStyle = Object.assign({}, this.sidebarStyle);
        /** @type {?} */
        const contentStyle = Object.assign({}, this.contentStyle);
        /** @type {?} */
        const overlayStyle = Object.assign({}, this.overlayStyle);
        if (this.isTouching()) {
            this.renderStyle({
                sidebarStyle: sidebarStyle,
                isTouching: true,
                contentStyle: undefined,
                overlayStyle: overlayStyle
            });
        }
        else if (this._docked) {
            this.dockedCls = true;
            this.renderStyle({
                sidebarStyle: sidebarStyle,
                isTouching: undefined,
                contentStyle: contentStyle,
                overlayStyle: undefined
            });
        }
        else if (this._open) {
            this.openCls = true;
            this.renderStyle({
                sidebarStyle: sidebarStyle,
                isTouching: undefined,
                contentStyle: undefined,
                overlayStyle: undefined
            });
            overlayStyle.opacity = 1;
            overlayStyle.visibility = 'visible';
        }
        if (this.isTouching() || !this.transitions) {
            sidebarStyle.transition = 'none';
            sidebarStyle.WebkitTransition = 'none';
            contentStyle.transition = 'none';
            overlayStyle.transition = 'none';
        }
        this.sidebarStyleFinal = sidebarStyle;
        this.contentStyleFinal = contentStyle;
        this.overlayStyleFinal = overlayStyle;
    }
    /**
     * @param {?} ele
     * @return {?}
     */
    getOffset(ele) {
        /** @type {?} */
        let el = ele;
        /** @type {?} */
        let _x = 0;
        /** @type {?} */
        let _y = 0;
        while (el && !isNaN(el.offsetLeft) && !isNaN(el.offsetTop)) {
            _x += el.offsetLeft - el.scrollLeft;
            _y += el.offsetTop - el.scrollTop;
            el = el.offsetParent;
        }
        return { top: _y, left: _x };
    }
    /**
     * @return {?}
     */
    ngAfterViewChecked() {
        if (!this.isTouching()) {
            this.saveSidebarSize();
        }
    }
    /**
     * @return {?}
     */
    ngOnChanges() {
        this.update();
    }
}
DrawerComponent.decorators = [
    { type: Component, args: [{
                selector: 'Drawer, nzm-drawer',
                template: "<div class=\"{{prefixCls}}-sidebar\"\n     [ngStyle]=\"sidebarStyleFinal\"\n     id=\"sidebar\">\n  <ng-template [ngTemplateOutlet]=\"sidebar\"></ng-template>\n</div>\n<div class=\"{{prefixCls}}-overlay\"\n     [ngStyle]=\"overlayStyleFinal\"\n     role=\"presentation\"\n     ref=\"overlay\"\n     (click)=\"onOverlayClicked()\"\n></div>\n<div class=\"{{prefixCls}}-content\"\n     [ngStyle]=\"contentStyleFinal\"\n     ref=\"content\">\n  <div *ngIf=\"touch && touchSupported && !open && !docked && enableDragHandle\"\n       id=\"dragHandle\"\n       class=\"{{prefixCls}}-draghandle\"\n       [ngStyle]=\"dragHandleStyle\"\n       (touchstart)=\"onTouchStart($event)\"\n       (touchmove)=\"onTouchMove($event)\"\n       (touchend)=\"onTouchEnd()\"\n       (touchcancle)=\"onTouchEnd()\"\n  ></div>\n  <ng-content></ng-content>\n</div>\n",
                encapsulation: ViewEncapsulation.None
            }] }
];
/** @nocollapse */
DrawerComponent.ctorParameters = () => [
    { type: ElementRef }
];
DrawerComponent.propDecorators = {
    sidebar: [{ type: Input }],
    sidebarStyle: [{ type: Input }],
    contentStyle: [{ type: Input }],
    overlayStyle: [{ type: Input }],
    dragHandleStyle: [{ type: Input }],
    transitions: [{ type: Input }],
    touch: [{ type: Input }],
    enableDragHandle: [{ type: Input }],
    dragToggleDistance: [{ type: Input }],
    docked: [{ type: Input }],
    open: [{ type: Input }],
    position: [{ type: Input }],
    onOpenChange: [{ type: Output }],
    am: [{ type: HostBinding, args: ['class.am-drawer',] }],
    left: [{ type: HostBinding, args: ['class.am-drawer-left',] }],
    right: [{ type: HostBinding, args: ['class.am-drawer-right',] }],
    top: [{ type: HostBinding, args: ['class.am-drawer-top',] }],
    bottom: [{ type: HostBinding, args: ['class.am-drawer-bottom',] }],
    dockedCls: [{ type: HostBinding, args: ['class.am-drawer-docked',] }],
    openCls: [{ type: HostBinding, args: ['class.am-drawer-open',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DrawerModule {
}
DrawerModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                declarations: [DrawerComponent],
                exports: [DrawerComponent]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SwipeActionComponent {
    constructor() {
        this.prefixCls = 'am-swipe';
        this.wrapCls = {};
        this._swiping = false;
        this._openedLeft = false;
        this._openedRight = false;
        this.left = [];
        this.right = [];
        this.autoClose = false;
        this.disabled = false;
        this.onOpen = new EventEmitter();
        this.onClose = new EventEmitter();
        this.onCloseSwipe = (/**
         * @param {?} ev
         * @return {?}
         */
        (ev) => {
            if (!(this._openedLeft || this._openedRight)) {
                return;
            }
            /** @type {?} */
            const pNode = ev.target.closest(`.${this.prefixCls}-actions`);
            if (!pNode) {
                this.close();
            }
        });
    }
    /**
     * @return {?}
     */
    setClassMap() {
        this.wrapCls = {
            [this.prefixCls]: true,
            [`${this.prefixCls}-swiping`]: this._swiping
        };
    }
    /**
     * @return {?}
     */
    close() {
        if (this._openedLeft || this._openedRight) {
            this.onClose.emit();
        }
        this.setBtnStyle(0);
        this._openedLeft = false;
        this._openedRight = false;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    setBtnStyle(value) {
        /** @type {?} */
        const limit = value > 0 ? this._btnsLeftWidth : -this._btnsRightWidth;
        /** @type {?} */
        const contentLeft = this.getContentEasing(value, limit);
        this.content.nativeElement.style.left = `${contentLeft}px`;
        this.cover.nativeElement.style.display = Math.abs(value) > 0 ? 'block' : 'none';
        this.cover.nativeElement.style.left = `${contentLeft}px`;
    }
    /**
     * @param {?} value
     * @param {?} limit
     * @return {?}
     */
    getContentEasing(value, limit) {
        return Math.abs(value) - Math.abs(limit) > 0 ? limit : value;
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onTouchStart(e) {
        this._startX = e.changedTouches[0].clientX;
        this._swiping = true;
    }
    ;
    /**
     * @param {?} e
     * @return {?}
     */
    onTouchMove(e) {
        /** @type {?} */
        const deltaX = e.changedTouches[0].clientX - this._startX;
        this._needShowRight = deltaX < -5 && this.right.length > 0;
        this._needShowLeft = deltaX > 5 && this.left.length > 0;
        if (this.leftBtnRef) {
            this.leftBtnRef.nativeElement.style.visibility = this._needShowRight ? 'hidden' : 'visible';
        }
        if (this.rightBtnRef) {
            this.rightBtnRef.nativeElement.style.visibility = this._needShowLeft ? 'hidden' : 'visible';
        }
        this.setBtnStyle(deltaX);
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onTouchEnd(e) {
        /** @type {?} */
        const deltaX = e.changedTouches[0].clientX - this._startX;
        /** @type {?} */
        const needOpenRight = this._needShowRight && Math.abs(deltaX) > this._btnsRightWidth / 2;
        /** @type {?} */
        const needOpenLeft = this._needShowLeft && Math.abs(deltaX) > this._btnsLeftWidth / 2;
        if (needOpenRight) {
            this.doOpenRight();
        }
        else if (needOpenLeft) {
            this.doOpenLeft();
        }
        else {
            this.close();
        }
        this._swiping = false;
        this._needShowLeft = false;
        this._needShowRight = false;
    }
    /**
     * @return {?}
     */
    doOpenLeft() {
        this.open(this._btnsLeftWidth, true, false);
    }
    /**
     * @return {?}
     */
    doOpenRight() {
        this.open(-this._btnsRightWidth, false, true);
    }
    /**
     * @param {?} ev
     * @param {?} btn
     * @return {?}
     */
    onBtnClick(ev, btn) {
        /** @type {?} */
        const onPress = btn.onPress;
        if (onPress) {
            onPress(ev);
        }
        if (this.autoClose) {
            this.close();
        }
    }
    /**
     * @param {?} value
     * @param {?} openedLeft
     * @param {?} openedRight
     * @return {?}
     */
    open(value, openedLeft, openedRight) {
        this.onOpen.emit();
        this._openedLeft = openedLeft;
        this._openedRight = openedRight;
        this.setBtnStyle(value);
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.setClassMap();
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this._btnsLeftWidth = this.leftBtnRef ? this.leftBtnRef.nativeElement.offsetWidth : 0;
        this._btnsRightWidth = this.rightBtnRef ? this.rightBtnRef.nativeElement.offsetWidth : 0;
        document.body.addEventListener('touchstart', this.onCloseSwipe, true);
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        document.body.removeEventListener('touchstart', this.onCloseSwipe, true);
    }
}
SwipeActionComponent.decorators = [
    { type: Component, args: [{
                selector: 'SwipeAction, nzm-swipe-action',
                template: "<div *ngIf=\"(left.length != 0 || right.length != 0) && !disabled\" [ngClass]=\"wrapCls\">\n  <div class=\"{{prefixCls}}-cover\" #coverRef></div>\n  <div *ngIf=\"left && left.length > 0\"\n       class=\"{{prefixCls}}-actions {{prefixCls}}-actions-left\"\n       #leftBtnRef>\n    <div *ngFor=\"let btn of left\"\n         class=\"{{prefixCls}}-btn {{btn.className}}\"\n         [ngStyle]=\"btn.style\"\n         role=\"button\"\n         (click)=\"onBtnClick($event, btn)\">\n      <div class=\"{{prefixCls}}-btn-text\">\n        {{btn.text || 'Click'}}\n      </div>\n    </div>\n  </div>\n  <div *ngIf=\"right && right.length > 0\"\n       class=\"{{prefixCls}}-actions {{prefixCls}}-actions-right\"\n       #rightBtnRef>\n    <div *ngFor=\"let btn of right\"\n         class=\"{{prefixCls}}-btn {{btn.className}}\"\n         [ngStyle]=\"btn.style\"\n         role=\"button\"\n         (click)=\"onBtnClick($event, btn)\"\n    >\n      <div class=\"{{prefixCls}}-btn-text\">\n        {{btn.text || 'Click'}}\n      </div>\n    </div>\n  </div>\n  <div class=\"{{prefixCls}}-content\"\n       #contentRef\n       (touchstart)=\"onTouchStart($event)\"\n       (touchmove)=\"onTouchMove($event)\"\n       (touchend)=\"onTouchEnd($event)\">\n    <ng-template [ngTemplateOutlet]=\"content\"></ng-template>\n  </div>\n</div>\n<div *ngIf=\"!((left.length != 0 || right.length != 0) && !disabled)\"\n     class=\"{{prefixCls}}-content\"\n     #contentRef>\n  <ng-template [ngTemplateOutlet]=\"content\"></ng-template>\n</div>\n\n<ng-template #content>\n  <ng-content></ng-content>\n</ng-template>\n",
                encapsulation: ViewEncapsulation.None
            }] }
];
/** @nocollapse */
SwipeActionComponent.ctorParameters = () => [];
SwipeActionComponent.propDecorators = {
    leftBtnRef: [{ type: ViewChild, args: ['leftBtnRef',] }],
    rightBtnRef: [{ type: ViewChild, args: ['rightBtnRef',] }],
    content: [{ type: ViewChild, args: ['contentRef',] }],
    cover: [{ type: ViewChild, args: ['coverRef',] }],
    left: [{ type: Input }],
    right: [{ type: Input }],
    autoClose: [{ type: Input }],
    disabled: [{ type: Input }],
    onOpen: [{ type: Output }],
    onClose: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SwipeActionModule {
}
SwipeActionModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                exports: [SwipeActionComponent],
                declarations: [SwipeActionComponent],
                providers: [],
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PullToRefreshComponent {
    /**
     * @param {?} ele
     */
    constructor(ele) {
        this.ele = ele;
        this.transtionCls = {};
        this.style = {
            '-webkit-transform': 'translate3d( 0, 0, 0 )',
            transform: 'translate3d( 0, 0, 0 )'
        };
        this.state = {
            currentState: 'deactivate',
            drag: false
        };
        this._headerIndicator = {
            activate: '松开立即刷新',
            deactivate: '下拉可以刷新',
            release: '刷新中。。。',
            finish: '完成刷新'
        };
        this._footerIndicator = {
            activate: '松开立即刷新',
            deactivate: '上拉可以刷新',
            release: '刷新中。。。',
            finish: '完成刷新'
        };
        this._startTime = 0;
        this._endTime = 0;
        this._endRreach = false;
        this._direction = '';
        this._clientHeight = 0;
        this._currentContentHeight = 0;
        this._lastcontentOffset = 0;
        this.distanceToRefresh = 25; //触发刷新距离
        //触发刷新距离
        this.damping = 100; // 下拉的最大距离
        // 下拉的最大距离
        this.endReachedRefresh = false;
        this.refreshing = false;
        this.onRefresh = new EventEmitter();
        this.refresh = true;
        this.container = true;
        this.refreshUp = false;
        this.refreshDown = true;
    }
    /**
     * @return {?}
     */
    get direction() {
        return this._direction;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set direction(value) {
        this._direction = value;
        this.refreshUp = this._direction === 'up' || this._direction === '';
        this.refreshDown = this._direction === 'down' || this._direction === '';
    }
    /**
     * @return {?}
     */
    get headerIndicator() {
        return this._headerIndicator;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set headerIndicator(value) {
        Object.assign(this._headerIndicator, value);
    }
    /**
     * @return {?}
     */
    get footerIndicator() {
        return this._footerIndicator;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set footerIndicator(value) {
        Object.assign(this._footerIndicator, value);
    }
    /**
     * @param {?} e
     * @return {?}
     */
    touchstart(e) {
        this._startTime = Date.now();
        if (this._direction === 'down' || (this._direction === '' && !this._endRreach)) {
            if (this.ele.nativeElement.scrollTop > 0) {
                this.startY = undefined;
                return;
            }
            this.startY = e && e.changedTouches && e.changedTouches[0] && e.changedTouches[0].clientY;
            this.state.drag = undefined;
        }
        else {
            this.startY = e && e.changedTouches && e.changedTouches[0] && e.changedTouches[0].clientY;
            this._clientHeight = this._pullToRefresh.element.nativeElement.clientHeight;
            this._currentContentHeight = document.getElementsByTagName('pulltorefresh')[0].clientHeight;
        }
        this.transtionCls = '';
    }
    /**
     * @param {?} e
     * @return {?}
     */
    touchmove(e) {
        if (this._direction === 'down' || (this._direction === '' && !this._endRreach)) {
            if (this.ele.nativeElement.scrollTop > 0) {
                return;
            }
            /** @type {?} */
            let distanceY = e.changedTouches[0].clientY - this.startY;
            if (distanceY < 0) {
                // 滚动
                this.state.drag = false;
            }
            else {
                // 下拉
                this.state.drag = true;
            }
            if (this.state.drag) {
                // 禁止滚动
                if (e.cancelable) {
                    e.preventDefault();
                }
            }
            else {
                return;
            }
            if (distanceY > this.damping) {
                //当超过设定阈值是，缓慢增加
                distanceY = (distanceY / (distanceY + this.damping)) * this.damping * 2;
            }
            else if (distanceY < 0) {
                distanceY = 0;
            }
            if (distanceY > this.distanceToRefresh) {
                this.state.currentState = 'activate';
                if (this._ngModelOnChange) {
                    this._ngModelOnChange(this.state);
                }
            }
            this.style = {
                '-webkit-transform': 'translate3d( 0, ' + distanceY + 'px, 0 )',
                transform: 'translate3d( 0, ' + distanceY + 'px, 0 )'
            };
        }
        else {
            /** @type {?} */
            let distanceY = e.changedTouches[0].clientY - this.startY;
            //向上拉动的时候，如果当前窗口内容没有滚到最后，则不实现拖动的动作；向下滚动不实现拖动动作
            if (Math.abs(this._lastcontentOffset) <= this._clientHeight - this._currentContentHeight - this.distanceToRefresh ||
                distanceY > 0) {
                // 滚动
                this.state.drag = false;
            }
            else {
                // 上拉
                this.state.drag = true;
            }
            if (this.state.drag) {
                // 禁止滚动
                if (e.cancelable) {
                    e.preventDefault();
                }
            }
            else {
                return;
            }
            //如果滑动到底部了，滑动距离随着拉动的距离增加缓慢增加
            distanceY = -(distanceY / (distanceY - this.damping)) * this.damping;
            if (Math.abs(distanceY) > this.distanceToRefresh) {
                this.state.currentState = 'activate';
                if (this._ngModelOnChange) {
                    this._ngModelOnChange(this.state);
                }
            }
            this.style = {
                '-webkit-transform': 'translate3d( 0, ' + distanceY + 'px, 0 )',
                transform: 'translate3d( 0, ' + distanceY + 'px, 0 )'
            };
        }
    }
    /**
     * @param {?} e
     * @return {?}
     */
    touchend(e) {
        if (!this.startY || this.state.drag === false) {
            return;
        }
        /** @type {?} */
        const distanceY = e.changedTouches[0].clientY - this.startY;
        if (Math.abs(distanceY) >= this.distanceToRefresh) {
            this.state.currentState = 'release';
            if (this._direction === 'down' || (this._direction === '' && !this._endRreach)) {
                this.translateY(this.distanceToRefresh + 1);
            }
            else {
                this.translateY(-this.distanceToRefresh - 1);
            }
            if (this._ngModelOnChange) {
                this._ngModelOnChange(this.state);
            }
            setTimeout((/**
             * @return {?}
             */
            () => {
                this.state.currentState = 'finish';
                if (this._ngModelOnChange) {
                    this._ngModelOnChange(this.state);
                }
                if (this._direction === 'down' || (this._direction === '' && !this._endRreach)) {
                    this.onRefresh.emit('down');
                }
                else {
                    this.translateY(-this.distanceToRefresh - 1);
                    this.onRefresh.emit('up');
                }
                setTimeout((/**
                 * @return {?}
                 */
                () => {
                    this.state.currentState = 'deactivate';
                    if (this._ngModelOnChange) {
                        this._ngModelOnChange(this.state);
                    }
                    this.translateY(0);
                }), 0);
            }), 500);
        }
        else {
            this.translateY(0);
        }
    }
    /**
     * @param {?} evt
     * @return {?}
     */
    touchcancel(evt) {
        this.translateY(0);
    }
    /**
     * @param {?} evt
     * @return {?}
     */
    scroll(evt) {
        this._endTime = Date.now();
        /** @type {?} */
        const contentOffset = evt.target.scrollTop;
        /** @type {?} */
        const offset = contentOffset - this._lastcontentOffset;
        this._lastcontentOffset = contentOffset;
        if (this._direction === '') {
            if (offset > 0 &&
                contentOffset > 0 &&
                evt.target.scrollTop + this.ele.nativeElement.clientHeight === evt.target.scrollHeight) {
                setTimeout((/**
                 * @return {?}
                 */
                () => {
                    this._endRreach = true;
                }), 500);
            }
            else {
                this._endRreach = false;
            }
        }
        if (!this.endReachedRefresh) {
            return;
        }
        if (this._direction === 'down' &&
            offset > 0 &&
            contentOffset > 0 &&
            evt.target.scrollTop + this.ele.nativeElement.clientHeight > evt.target.scrollHeight - this.distanceToRefresh &&
            this._endTime - this._startTime >= 100) {
            this._startTime = this._endTime;
            if (this.refreshing) {
                this.state.currentState = 'release';
                if (this._ngModelOnChange) {
                    this._ngModelOnChange(this.state);
                }
            }
            setTimeout((/**
             * @return {?}
             */
            () => {
                if (this._direction === '') {
                    this._endRreach = true;
                }
                if (this.endReachedRefresh) {
                    this.onRefresh.emit('endReachedRefresh');
                }
                if (this.refreshing) {
                    this.state.currentState = 'finish';
                    if (this._ngModelOnChange) {
                        this._ngModelOnChange(this.state);
                    }
                }
            }), 500);
        }
        else {
            setTimeout((/**
             * @return {?}
             */
            () => {
                if (this._direction === '') {
                    this._endRreach = false;
                }
                if (this.refreshing) {
                    this.state.currentState = 'finish';
                    if (this._ngModelOnChange) {
                        this._ngModelOnChange(this.state);
                    }
                }
            }), 500);
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    isTemplateRef(value) {
        if (value) {
            return value instanceof TemplateRef;
        }
    }
    /**
     * @param {?} distanceY
     * @return {?}
     */
    translateY(distanceY) {
        this.transtionCls = 'am-pull-to-refresh-transition';
        this.style = {
            '-webkit-transform': 'translate3d( 0, ' + distanceY + 'px, 0 )',
            transform: 'translate3d( 0, ' + distanceY + 'px, 0 )'
        };
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        if (value !== null) {
            this.state = value;
        }
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this._ngModelOnChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this._ngModelOnTouched = fn;
    }
}
PullToRefreshComponent.decorators = [
    { type: Component, args: [{
                selector: 'PullToRefresh, nzm-pull-to-refresh',
                template: "<div class=\"am-pull-to-refresh-content-wrapper\">\n  <div class=\"am-pull-to-refresh-content\" [ngClass]=\"transtionCls\" [ngStyle]=\"style\">\n    <div *ngIf=\"direction === 'down' || direction === ''\" class=\"am-pull-to-refresh-indicator am-pull-to-refresh-header-indicator\">\n      <ng-template *ngIf=\"isTemplateRef(headerIndicator[state.currentState])\" [ngTemplateOutlet]=\"headerIndicator[state.currentState]\"></ng-template>\n      <ng-container *ngIf=\"!isTemplateRef(headerIndicator[state.currentState])\">{{headerIndicator[state.currentState]}}</ng-container>\n    </div>\n    <div #pullToRefresh>\n      <ng-content></ng-content>\n      <div *ngIf=\"direction === 'down' && endReachedRefresh\" class=\"am-pull-to-refresh-indicator am-pull-to-refresh-footer-indicator\">\n        <ng-template *ngIf=\"isTemplateRef(footerIndicator[state.currentState])\" [ngTemplateOutlet]=\"footerIndicator[state.currentState]\"></ng-template>\n        <ng-container *ngIf=\"!isTemplateRef(footerIndicator[state.currentState])\">{{footerIndicator[state.currentState]}}</ng-container>\n      </div>\n    </div>\n    <div *ngIf=\"direction === 'up' || direction === ''\" class=\"am-pull-to-refresh-indicator am-pull-to-refresh-footer-indicator\">\n      <ng-template *ngIf=\"isTemplateRef(footerIndicator[state.currentState])\" [ngTemplateOutlet]=\"footerIndicator[state.currentState]\"></ng-template>\n      <ng-container *ngIf=\"!isTemplateRef(footerIndicator[state.currentState])\">{{footerIndicator[state.currentState]}}</ng-container>\n    </div>\n  </div>\n</div>\n",
                encapsulation: ViewEncapsulation.None,
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => PullToRefreshComponent)),
                        multi: true
                    }
                ]
            }] }
];
/** @nocollapse */
PullToRefreshComponent.ctorParameters = () => [
    { type: ElementRef }
];
PullToRefreshComponent.propDecorators = {
    _pullToRefresh: [{ type: ViewChild, args: ['pullToRefresh', { read: ViewContainerRef },] }],
    distanceToRefresh: [{ type: Input }],
    damping: [{ type: Input }],
    endReachedRefresh: [{ type: Input }],
    refreshing: [{ type: Input }],
    direction: [{ type: Input }],
    headerIndicator: [{ type: Input }],
    footerIndicator: [{ type: Input }],
    onRefresh: [{ type: Output }],
    refresh: [{ type: HostBinding, args: ['class.am-pull-to-refresh',] }],
    container: [{ type: HostBinding, args: ['class.super-container',] }],
    refreshUp: [{ type: HostBinding, args: ['class.am-pull-to-refresh-up',] }],
    refreshDown: [{ type: HostBinding, args: ['class.am-pull-to-refresh-down',] }],
    touchstart: [{ type: HostListener, args: ['touchstart', ['$event'],] }],
    touchmove: [{ type: HostListener, args: ['touchmove', ['$event'],] }],
    touchend: [{ type: HostListener, args: ['touchend', ['$event'],] }],
    touchcancel: [{ type: HostListener, args: ['touchcancel', ['$event'],] }],
    scroll: [{ type: HostListener, args: ['scroll', ['$event'],] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PullToRefreshModule {
}
PullToRefreshModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule, IconModule, FormsModule, ReactiveFormsModule],
                exports: [PullToRefreshComponent],
                declarations: [PullToRefreshComponent]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgZorroAntdMobileModule {
    /**
     * @return {?}
     */
    static forRoot() {
        return {
            ngModule: NgZorroAntdMobileModule
        };
    }
}
NgZorroAntdMobileModule.decorators = [
    { type: NgModule, args: [{
                providers: [],
                exports: [
                    ActivityIndicatorModule,
                    CardModule,
                    TabsModule,
                    TabBarModule,
                    ButtonModule,
                    SwitchModule,
                    SearchBarModule,
                    StepperModule,
                    StepsModule,
                    CheckboxModule,
                    ProgressModule,
                    SegmentedControlModule,
                    BadgeModule,
                    CarouselModule,
                    ActionSheetModule,
                    AccordionModule,
                    NoticeBarModule,
                    IconModule,
                    ToastModule,
                    RadioModule,
                    ModalModule,
                    PopoverModule,
                    PopoverItemModule,
                    NavBarModule,
                    ListModule,
                    CalendarModule,
                    InputItemModule,
                    FlexModule,
                    GridModule,
                    RangeModule,
                    SliderModule,
                    TextareaItemModule,
                    NgZorroAntdMobilePipesModule,
                    PickerModule,
                    PickerViewModule,
                    ImagePickerModule,
                    ResultModule,
                    WhiteSpaceModule,
                    WingBlankModule,
                    LocaleProviderModule,
                    NgZorroAntdMobilePipesModule,
                    PaginationModule,
                    TagModule,
                    MenuModule,
                    DatePickerModule,
                    DatePickerViewModule,
                    DrawerModule,
                    PullToRefreshModule,
                    SwipeActionModule
                ]
            },] }
];

export { AccordionComponent, AccordionGroupComponent, AccordionModule, AccordionService, Action, ActionSheetService as ActionSheet, ActionSheetComponent, ActionSheetModule, ActionSheetOptions, ActionSheetService, ActionSheetSubjectService, ActionSheetWithOptions, ActivityIndicatorComponent, ActivityIndicatorModule, AgreeItemComponent, AlertOptions, BadgeComponent, BadgeModule, BriefComponent, ButtonComponent, ButtonModule, CalendarComponent, CalendarConfirmPanelComponent, CalendarDatePickerComponent, CalendarHeaderComponent, CalendarModule, CalendarShortcutPanelComponent, CalendarSingleMonthComponent, CalendarTimePickerComponent, CalendarWeekPanelComponent, CardBodyComponent, CardComponent, CardFooterComponent, CardHeaderComponent, CardModule, CarouselComponent, CarouselModule, CarouselSlideComponent, CheckboxComponent, CheckboxItemComponent, CheckboxModule, CustomInputComponent, CustomInputService, CustomKeyboardComponent, DateModels, DatePickerComponent, DatePickerDirective, DatePickerModule, DatePickerOptions, DatePickerViewComponent, DatePickerViewModule, DefaultTabBarComponent, DotIndicatorComponent, DrawerComponent, DrawerModule, FlexComponent, FlexItemComponent, FlexModule, GridComponent, GridModule, IconComponent, IconModule, ImagePickerComponent, ImagePickerModule, InputItemComponent, InputItemModule, LOCAL_PROVIDER_TOKEN, ListComponent, ListItemComponent, ListModule, LocaleProviderModule, LocaleProviderPipe, LocaleProviderService, MenuComponent, MenuModule, ModalService as Modal, ModalBaseOptions, ModalComponent, ModalModule, ModalOptions, ModalService, ModalServiceComponent, NavBarComponent, NavBarModule, NgZorroAntdMobileModule, NgZorroAntdMobilePipesModule, NoticeBarComponent, NoticeBarModule, PaginationComponent, PaginationModule, PickerService as Picker, PickerComponent, PickerDirective, PickerModule, PickerOptions, PickerService, PickerViewComponent, PickerViewModule, PopoverComponent, PopoverComponentOptions, PopoverDirective, PopoverItemComponent, PopoverItemModule, PopoverModule, PopoverOptions, PopoverOptionsFactory, ProgressComponent, ProgressModule, PullToRefreshComponent, PullToRefreshModule, RadioComponent, RadioItemComponent, RadioItemGroupComponent, RadioModule, RangeComponent, RangeModule, ResultComponent, ResultModule, SafeHTMLPipe, SearchBarComponent, SearchBarModule, SegmentedControlComponent, SegmentedControlModule, ShareActionSheetWithOptions, ShareOption, SliderComponent, SliderHandleComponent, SliderMarksComponent, SliderModule, SliderStepsComponent, SliderTrackComponent, StepComponent, StepDirectionEnum, StepStatusEnum, StepperComponent, StepperModule, StepsComponent, StepsModule, SubMenuComponent, SwipeActionComponent, SwipeActionModule, SwitchComponent, SwitchModule, TabBarComponent, TabBarItemComponent, TabBarModule, TabPaneBodyComponent, TabPaneComponent, TabsComponent, TabsModule, TagComponent, TagModule, TextareaItemComponent, TextareaItemModule, ToastService as Toast, ToastComponent, ToastModule, ToastOptions, ToastService, WhiteSpaceComponent, WhiteSpaceModule, WingBlankComponent, WingBlankModule, da_DK, en_US, formatDate, mergeDateTime, ru_RU, sv_SE, zh_CN, RADIO_ITEM_GROUP_VALUE_ACCESSOR as ɵa, NZ_BUTTON_DIRECTIVES as ɵb, LOCALE_PROVIDER_SERVICE_FACTORY as ɵc, LOCALE_PROVIDER_SERVICE_PROVIDER as ɵd, IconHandler as ɵe, PopupService as ɵf, CalendarDatePickerBaseComponent as ɵg, TouchFeedbackModule as ɵh, TouchFeedbackDirective as ɵi, TouchFeedBackComponent as ɵj };
//# sourceMappingURL=ng-zorro-antd-mobile.js.map
